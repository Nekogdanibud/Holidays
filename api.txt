ОТЧЕТ О ФАЙЛАХ
Папка: /OTPUSK/otpusk-app/Holidays/src/app/api
Дата создания: 10/21/2025, 9:41:33 PM
Всего файлов: 39
Исключенные папки: api, node_modules, dist, build, .git, .next, cache, temp
Исключенные файлы: global.css, favicon.ico
================================================================================


================================================================================
ФАЙЛ: activities/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/activities/route.js
РАЗМЕР: 2924 символов
================================================================================

// src/app/api/activities/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    const { title, description, date, type, vacationId, locationId } = await request.json();

    if (!title || !date || !type || !vacationId) {
      return NextResponse.json(
        { message: 'Обязательные поля: название, дата, тип и ID отпуска' },
        { status: 400 }
      );
    }

    // Проверяем доступ к отпуску
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: vacationId,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    // Создаем активность
    const activity = await prisma.activity.create({
      data: {
        title,
        description,
        date: new Date(date),
        type,
        vacationId,
        locationId: locationId || null
      },
      include: {
        location: {
          select: { id: true, name: true, address: true }
        },
        participants: {
          include: {
            user: {
              select: { id: true, name: true, avatar: true }
            }
          }
        }
      }
    });

    // Автоматически добавляем создателя как участника
    await prisma.activityParticipant.create({
      data: {
        activityId: activity.id,
        userId: decoded.userId,
        status: 'going'
      }
    });

    // Обновляем активность с участниками
    const updatedActivity = await prisma.activity.findUnique({
      where: { id: activity.id },
      include: {
        location: {
          select: { id: true, name: true, address: true }
        },
        participants: {
          include: {
            user: {
              select: { id: true, name: true, avatar: true }
            }
          }
        }
      }
    });

    // Форматируем для ответа
    const formattedActivity = {
      ...updatedActivity,
      author: updatedActivity.participants[0]?.user || null,
      participants: updatedActivity.participants.map(p => p.user)
    };

    return NextResponse.json(formattedActivity, { status: 201 });

  } catch (error) {
    console.error('Ошибка создания активности:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: admin/check/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/admin/check/route.js
РАЗМЕР: 1037 символов
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: { role: true }
    });

    if (user?.role !== 'ADMIN') {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    return NextResponse.json({ isAdmin: true });

  } catch (error) {
    console.error('Ошибка проверки прав администратора:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: admin/groups/[id]/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/admin/groups/[id]/route.js
РАЗМЕР: 3983 символов
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

async function isAdmin(userId) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true }
  });
  return user?.role === 'ADMIN';
}

export async function GET(request, { params }) {
  try {
    // Ожидаем параметры
    const { id: groupId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    const group = await prisma.group.findUnique({
      where: { id: groupId },
      include: {
        _count: {
          select: {
            userGroups: true
          }
        },
        userGroups: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                usertag: true,
                avatar: true,
                experiencePoints: true
              }
            }
          },
          orderBy: { joinedAt: 'desc' }
        }
      }
    });

    if (!group) {
      return NextResponse.json({ message: 'Группа не найдена' }, { status: 404 });
    }

    return NextResponse.json({ group });

  } catch (error) {
    console.error('Ошибка получения группы:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}

export async function PUT(request, { params }) {
  try {
    // Ожидаем параметры
    const { id: groupId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    const updates = await request.json();

    const validFields = [
      'name', 'description', 'level', 'minPoints', 'maxPoints',
      'color', 'bgColor', 'icon', 'badgeText', 'isExclusive'
    ];

    const updateData = {};
    Object.keys(updates).forEach(key => {
      if (validFields.includes(key)) {
        updateData[key] = updates[key];
      }
    });

    const updatedGroup = await prisma.group.update({
      where: { id: groupId },
      data: updateData
    });

    return NextResponse.json({
      message: 'Группа обновлена',
      group: updatedGroup
    });

  } catch (error) {
    console.error('Ошибка обновления группы:', error);
    
    if (error.code === 'P2002') {
      return NextResponse.json(
        { message: 'Группа с таким именем или уровнем уже существует' },
        { status: 409 }
      );
    }

    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}

export async function DELETE(request, { params }) {
  try {
    // Ожидаем параметры
    const { id: groupId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    await prisma.group.delete({
      where: { id: groupId }
    });

    return NextResponse.json({ message: 'Группа удалена' });

  } catch (error) {
    console.error('Ошибка удаления группы:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: admin/groups/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/admin/groups/route.js
РАЗМЕР: 3608 символов
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

async function isAdmin(userId) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true }
  });
  return user?.role === 'ADMIN';
}

export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');
    const search = searchParams.get('search') || '';
    const skip = (page - 1) * limit;

    const where = search ? {
      OR: [
        { name: { contains: search, mode: 'insensitive' } },
        { description: { contains: search, mode: 'insensitive' } }
      ]
    } : {};

    const [groups, total] = await Promise.all([
      prisma.group.findMany({
        where,
        include: {
          _count: {
            select: {
              userGroups: true
            }
          }
        },
        orderBy: { level: 'asc' },
        skip,
        take: limit
      }),
      prisma.group.count({ where })
    ]);

    return NextResponse.json({
      groups,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('Ошибка получения групп:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    const groupData = await request.json();

    const requiredFields = ['name', 'description', 'level', 'minPoints', 'color', 'icon', 'badgeText'];
    for (const field of requiredFields) {
      if (!groupData[field]) {
        return NextResponse.json(
          { message: `Поле ${field} обязательно` },
          { status: 400 }
        );
      }
    }

    const newGroup = await prisma.group.create({
      data: {
        name: groupData.name,
        description: groupData.description,
        level: groupData.level,
        minPoints: groupData.minPoints,
        maxPoints: groupData.maxPoints,
        color: groupData.color,
        bgColor: groupData.bgColor,
        icon: groupData.icon,
        badgeText: groupData.badgeText,
        isExclusive: groupData.isExclusive || false
      }
    });

    return NextResponse.json({
      message: 'Группа создана',
      group: newGroup
    });

  } catch (error) {
    console.error('Ошибка создания группы:', error);
    
    if (error.code === 'P2002') {
      return NextResponse.json(
        { message: 'Группа с таким именем или уровнем уже существует' },
        { status: 409 }
      );
    }

    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: admin/stats/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/admin/stats/route.js
РАЗМЕР: 1391 символов
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

async function isAdmin(userId) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true }
  });
  return user?.role === 'ADMIN';
}

export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    const [totalUsers, totalVacations, activeVacations, totalGroups] = await Promise.all([
      prisma.user.count(),
      prisma.vacation.count(),
      prisma.vacation.count({
        where: {
          startDate: { lte: new Date() },
          endDate: { gte: new Date() }
        }
      }),
      prisma.group.count()
    ]);

    return NextResponse.json({
      totalUsers,
      totalVacations,
      activeVacations,
      totalGroups
    });

  } catch (error) {
    console.error('Ошибка загрузки статистики:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: admin/users/[id]/groups/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/admin/users/[id]/groups/route.js
РАЗМЕР: 6471 символов
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../../lib/auth';
import { prisma } from '../../../../../../lib/prisma';

async function isAdmin(userId) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true }
  });
  return user?.role === 'ADMIN';
}

export async function GET(request, { params }) {
  try {
    // Ожидаем параметры
    const { id: userId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    const userGroups = await prisma.userGroup.findMany({
      where: { userId },
      include: {
        group: {
          select: {
            id: true,
            name: true,
            description: true,
            level: true,
            minPoints: true,
            maxPoints: true,
            color: true,
            bgColor: true,
            icon: true,
            badgeText: true,
            isExclusive: true
          }
        }
      }
    });

    return NextResponse.json({ userGroups });

  } catch (error) {
    console.error('Ошибка получения групп пользователя:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}

export async function POST(request, { params }) {
  try {
    // Ожидаем параметры
    const { id: userId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    const { groupId } = await request.json();

    if (!groupId) {
      return NextResponse.json(
        { message: 'Group ID обязателен' },
        { status: 400 }
      );
    }

    console.log('Adding user', userId, 'to group', groupId);

    // Проверяем существование пользователя
    const user = await prisma.user.findUnique({ 
      where: { id: userId } 
    });

    if (!user) {
      console.log('User not found:', userId);
      return NextResponse.json({ message: 'Пользователь не найден' }, { status: 404 });
    }

    // Проверяем существование группы
    const group = await prisma.group.findUnique({ 
      where: { id: groupId } 
    });

    if (!group) {
      console.log('Group not found:', groupId);
      return NextResponse.json({ message: 'Группа не найдена' }, { status: 404 });
    }

    console.log('User and group found, creating userGroup...');

    // Проверяем, не состоит ли пользователь уже в этой группе
    const existingUserGroup = await prisma.userGroup.findUnique({
      where: {
        userId_groupId: {
          userId,
          groupId
        }
      }
    });

    if (existingUserGroup) {
      return NextResponse.json(
        { message: 'Пользователь уже состоит в этой группе' },
        { status: 409 }
      );
    }

    // Создаем связь пользователя с группой
    const userGroup = await prisma.userGroup.create({
      data: {
        userId,
        groupId,
        joinedAt: new Date()
      },
      include: {
        group: {
          select: {
            id: true,
            name: true,
            description: true,
            level: true,
            minPoints: true,
            maxPoints: true,
            color: true,
            bgColor: true,
            icon: true,
            badgeText: true,
            isExclusive: true
          }
        }
      }
    });

    console.log('UserGroup created successfully:', userGroup);

    return NextResponse.json({
      message: 'Пользователь добавлен в группу',
      userGroup
    });

  } catch (error) {
    console.error('Ошибка добавления пользователя в группу:', error);
    
    if (error.code === 'P2002') {
      return NextResponse.json(
        { message: 'Пользователь уже состоит в этой группе' },
        { status: 409 }
      );
    }

    if (error.code === 'P2003') {
      return NextResponse.json(
        { message: 'Пользователь или группа не найдены' },
        { status: 404 }
      );
    }

    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера: ' + error.message },
      { status: 500 }
    );
  }
}

export async function DELETE(request, { params }) {
  try {
    // Ожидаем параметры
    const { id: userId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    const { searchParams } = new URL(request.url);
    const groupId = searchParams.get('groupId');

    if (!groupId) {
      return NextResponse.json(
        { message: 'Group ID обязателен' },
        { status: 400 }
      );
    }

    console.log('Removing user', userId, 'from group', groupId);

    // Проверяем существование связи
    const existingUserGroup = await prisma.userGroup.findUnique({
      where: {
        userId_groupId: {
          userId,
          groupId
        }
      }
    });

    if (!existingUserGroup) {
      return NextResponse.json(
        { message: 'Пользователь не состоит в этой группе' },
        { status: 404 }
      );
    }

    await prisma.userGroup.delete({
      where: {
        userId_groupId: {
          userId,
          groupId
        }
      }
    });

    console.log('UserGroup deleted successfully');

    return NextResponse.json({ message: 'Пользователь удален из группы' });

  } catch (error) {
    console.error('Ошибка удаления пользователя из группы:', error);
    
    if (error.code === 'P2025') {
      return NextResponse.json(
        { message: 'Пользователь не состоит в этой группе' },
        { status: 404 }
      );
    }

    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера: ' + error.message },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: admin/users/[id]/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/admin/users/[id]/route.js
РАЗМЕР: 5095 символов
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

async function isAdmin(userId) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true }
  });
  return user?.role === 'ADMIN';
}

export async function GET(request, { params }) {
  try {
    // Ожидаем параметры
    const { id: userId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        name: true,
        usertag: true,
        email: true,
        avatar: true,
        banner: true,
        bio: true,
        role: true,
        location: true,
        website: true,
        profileVisibility: true,
        experiencePoints: true,
        createdAt: true,
        updatedAt: true,
        _count: {
          select: {
            vacationMembers: true,
            ownedVacations: true,
            posts: true,
            friendsAsUser1: true,
            friendsAsUser2: true,
            memories: true,
            achievements: true
          }
        },
        ownedVacations: {
          select: {
            id: true,
            title: true,
            startDate: true,
            endDate: true,
            destination: true,
            coverImage: true,
            _count: {
              select: {
                members: true,
                memories: true,
                activities: true
              }
            }
          },
          orderBy: { createdAt: 'desc' },
          take: 5
        },
        posts: {
          select: {
            id: true,
            content: true,
            createdAt: true,
            _count: {
              select: {
                comments: true,
                likes: true
              }
            }
          },
          orderBy: { createdAt: 'desc' },
          take: 10
        },
        userGroups: {
          include: {
            group: {
              select: {
                id: true,
                name: true,
                icon: true,
                badgeText: true,
                bgColor: true,
                color: true,
                isExclusive: true
              }
            }
          }
        },
        achievements: {
          select: {
            id: true,
            type: true,
            title: true,
            description: true,
            icon: true,
            earnedAt: true
          },
          orderBy: { earnedAt: 'desc' },
          take: 10
        }
      }
    });

    if (!user) {
      return NextResponse.json({ message: 'Пользователь не найден' }, { status: 404 });
    }

    return NextResponse.json({ user });

  } catch (error) {
    console.error('Ошибка получения данных пользователя:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}

export async function PUT(request, { params }) {
  try {
    // Ожидаем параметры
    const { id: userId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    const updates = await request.json();

    const validFields = [
      'name', 'email', 'usertag', 'bio', 'location', 'website', 
      'profileVisibility', 'experiencePoints', 'avatar', 'banner'
    ];

    const updateData = {};
    Object.keys(updates).forEach(key => {
      if (validFields.includes(key)) {
        updateData[key] = updates[key];
      }
    });

    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: updateData,
      select: {
        id: true,
        name: true,
        usertag: true,
        email: true,
        bio: true,
        location: true,
        website: true,
        profileVisibility: true,
        experiencePoints: true,
        avatar: true,
        banner: true
      }
    });

    return NextResponse.json({
      message: 'Данные пользователя обновлены',
      user: updatedUser
    });

  } catch (error) {
    console.error('Ошибка обновления пользователя:', error);
    
    if (error.code === 'P2002') {
      return NextResponse.json(
        { message: 'Пользователь с таким email или usertag уже существует' },
        { status: 409 }
      );
    }

    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: admin/users/role/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/admin/users/role/route.js
РАЗМЕР: 1838 символов
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

async function isAdmin(userId) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true }
  });
  return user?.role === 'ADMIN';
}

export async function PUT(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    const { userId, role } = await request.json();

    if (!userId || !role) {
      return NextResponse.json(
        { message: 'User ID и роль обязательны' },
        { status: 400 }
      );
    }

    const validRoles = ['USER', 'ADMIN', 'MODERATOR'];
    if (!validRoles.includes(role)) {
      return NextResponse.json(
        { message: 'Недопустимая роль' },
        { status: 400 }
      );
    }

    if (userId === decoded.userId) {
      return NextResponse.json(
        { message: 'Нельзя изменить собственную роль' },
        { status: 400 }
      );
    }

    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: { role },
      select: {
        id: true,
        name: true,
        email: true,
        role: true
      }
    });

    return NextResponse.json({
      message: 'Роль пользователя обновлена',
      user: updatedUser
    });

  } catch (error) {
    console.error('Ошибка обновления роли:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: admin/users/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/admin/users/route.js
РАЗМЕР: 3496 символов
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

async function isAdmin(userId) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true }
  });
  return user?.role === 'ADMIN';
}

export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');
    const search = searchParams.get('search') || '';
    const skip = (page - 1) * limit;

    const where = search ? {
      OR: [
        { name: { contains: search, mode: 'insensitive' } },
        { email: { contains: search, mode: 'insensitive' } },
        { usertag: { contains: search, mode: 'insensitive' } }
      ]
    } : {};

    const [users, total] = await Promise.all([
      prisma.user.findMany({
        where,
        select: {
          id: true,
          name: true,
          usertag: true,
          email: true,
          avatar: true,
          role: true,
          createdAt: true,
          location: true,
          website: true,
          experiencePoints: true,
          _count: {
            select: {
              vacationMembers: {
                where: { status: 'accepted' }
              }
            }
          }
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit
      }),
      prisma.user.count({ where })
    ]);

    const formattedUsers = users.map(user => ({
      ...user,
      vacationCount: user._count.vacationMembers
    }));

    return NextResponse.json({
      users: formattedUsers,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('Ошибка получения пользователей:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}

export async function DELETE(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    const { userId } = await request.json();

    if (!userId) {
      return NextResponse.json({ message: 'User ID обязателен' }, { status: 400 });
    }

    if (userId === decoded.userId) {
      return NextResponse.json(
        { message: 'Нельзя удалить собственный аккаунт' },
        { status: 400 }
      );
    }

    await prisma.user.delete({
      where: { id: userId }
    });

    return NextResponse.json({ message: 'Пользователь удален' });

  } catch (error) {
    console.error('Ошибка удаления пользователя:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: auth/login/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/auth/login/route.js
РАЗМЕР: 2408 символов
================================================================================

// src/app/api/auth/login/route.js
import { NextResponse } from 'next/server';
import { verifyPassword, createSession } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const { email, password, rememberMe = false } = await request.json();

    // Валидация
    if (!email || !password) {
      return NextResponse.json(
        { message: 'Email и пароль обязательны' },
        { status: 400 }
      );
    }

    // Поиск пользователя
    const user = await prisma.user.findUnique({
      where: { email }
    });

    if (!user) {
      return NextResponse.json(
        { message: 'Неверный email или пароль' },
        { status: 401 }
      );
    }

    // Проверка пароля
    const isPasswordValid = await verifyPassword(password, user.password);
    if (!isPasswordValid) {
      return NextResponse.json(
        { message: 'Неверный email или пароль' },
        { status: 401 }
      );
    }

    // Получаем информацию о клиенте
    const userAgent = request.headers.get('user-agent');
    const ipAddress = request.headers.get('x-forwarded-for') || request.ip;

    // Создаем сессию с учетом rememberMe
    const { accessToken, refreshToken, sessionId } = await createSession(
      user.id, 
      userAgent, 
      ipAddress,
      rememberMe
    );

    const userData = {
      id: user.id,
      name: user.name,
      email: user.email,
      createdAt: user.createdAt
    };

    const response = NextResponse.json(
      { 
        message: 'Вход выполнен успешно',
        user: userData
      },
      { status: 200 }
    );

    // Устанавливаем httpOnly куки с разным временем жизни
    response.cookies.set('accessToken', accessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 1000 // 1 час
    });

    response.cookies.set('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: rememberMe 
        ? 365 * 24 * 60 * 60 * 1000 // 1 год для "Запомнить меня"
        : 30 * 24 * 60 * 60 * 1000 // 30 дней для обычной сессии
    });

    return response;

  } catch (error) {
    console.error('Ошибка входа:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: auth/logout/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/auth/logout/route.js
РАЗМЕР: 1175 символов
================================================================================

// src/app/api/auth/logout/route.js
import { NextResponse } from 'next/server';
import { deleteSession } from '../../../../lib/auth';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (accessToken) {
      const { verifyAccessToken } = await import('../../../../lib/auth');
      const decoded = verifyAccessToken(accessToken);
      
      if (decoded?.sessionId) {
        await deleteSession(decoded.sessionId);
      }
    }

    const response = NextResponse.json(
      { message: 'Выход выполнен успешно' },
      { status: 200 }
    );

    // Очищаем куки
    response.cookies.set('accessToken', '', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 0
    });

    response.cookies.set('refreshToken', '', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 0
    });

    return response;

  } catch (error) {
    console.error('Ошибка выхода:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: auth/me/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/auth/me/route.js
РАЗМЕР: 1665 символов
================================================================================

// src/app/api/auth/me/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function GET(request) {
  try {
    console.log('🔍 Checking auth...');
    
    const accessToken = request.cookies.get('accessToken')?.value;
    console.log('Access token exists:', !!accessToken);

    if (!accessToken) {
      console.log('❌ No access token');
      return NextResponse.json(
        { message: 'Не авторизован' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    console.log('Decoded token:', decoded);

    if (!decoded) {
      console.log('❌ Invalid token');
      return NextResponse.json(
        { message: 'Недействительный токен' },
        { status: 401 }
      );
    }

    // Получаем пользователя из базы с usertag
    console.log('👤 Fetching user:', decoded.userId);
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: {
        id: true,
        name: true,
        usertag: true, // ДОБАВЛЕНО
        email: true,
        avatar: true,
        createdAt: true
      }
    });

    console.log('User found:', !!user);
    console.log('User usertag:', user?.usertag);

    if (!user) {
      return NextResponse.json(
        { message: 'Пользователь не найден' },
        { status: 404 }
      );
    }

    return NextResponse.json(user);

  } catch (error) {
    console.error('❌ Ошибка получения пользователя:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: auth/refresh/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/auth/refresh/route.js
РАЗМЕР: 1271 символов
================================================================================

// src/app/api/auth/refresh/route.js
import { NextResponse } from 'next/server';
import { verifySession, generateAccessToken } from '../../../../lib/auth';

export async function POST(request) {
  try {
    const refreshToken = request.cookies.get('refreshToken')?.value;

    if (!refreshToken) {
      return NextResponse.json(
        { message: 'Refresh token не найден' },
        { status: 401 }
      );
    }

    // Проверяем сессию
    const session = await verifySession(refreshToken);
    if (!session) {
      return NextResponse.json(
        { message: 'Недействительная сессия' },
        { status: 401 }
      );
    }

    // Генерируем новый access token
    const newAccessToken = generateAccessToken(session.userId, session.id);

    const response = NextResponse.json(
      { message: 'Token обновлен' },
      { status: 200 }
    );

    response.cookies.set('accessToken', newAccessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 1000 // 1 час
    });

    return response;

  } catch (error) {
    console.error('Ошибка обновления токена:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: auth/register/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/auth/register/route.js
РАЗМЕР: 3926 символов
================================================================================

// src/app/api/auth/register/route.js (обновленная версия)
import { NextResponse } from 'next/server';
import { hashPassword, createSession } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const { name, usertag, email, password, rememberMe = false } = await request.json();

    // Валидация
    if (!name || !usertag || !email || !password) {
      return NextResponse.json(
        { message: 'Все поля обязательны для заполнения' },
        { status: 400 }
      );
    }

    if (password.length < 6) {
      return NextResponse.json(
        { message: 'Пароль должен содержать минимум 6 символов' },
        { status: 400 }
      );
    }

    // Проверка формата usertag
    if (!/^[a-z0-9-]+$/.test(usertag)) {
      return NextResponse.json(
        { message: 'Usertag может содержать только латинские буквы в нижнем регистре, цифры и дефисы' },
        { status: 400 }
      );
    }

    if (usertag.length < 3 || usertag.length > 20) {
      return NextResponse.json(
        { message: 'Usertag должен быть от 3 до 20 символов' },
        { status: 400 }
      );
    }

    // Проверка существующего пользователя по email и usertag
    const existingUser = await prisma.user.findFirst({
      where: {
        OR: [
          { email },
          { usertag }
        ]
      }
    });

    if (existingUser) {
      if (existingUser.email === email) {
        return NextResponse.json(
          { message: 'Пользователь с таким email уже существует' },
          { status: 409 }
        );
      }
      if (existingUser.usertag === usertag) {
        return NextResponse.json(
          { message: 'Этот usertag уже занят' },
          { status: 409 }
        );
      }
    }

    // Хеширование пароля
    const hashedPassword = await hashPassword(password);

    // Создание пользователя
    const newUser = await prisma.user.create({
      data: {
        name,
        usertag,
        email,
        password: hashedPassword,
      },
      select: {
        id: true,
        name: true,
        usertag: true,
        email: true,
        createdAt: true
      }
    });

    // Получаем информацию о клиенте
    const userAgent = request.headers.get('user-agent');
    const ipAddress = request.headers.get('x-forwarded-for') || request.ip;

    // Создаем сессию с учетом rememberMe
    const { accessToken, refreshToken, sessionId } = await createSession(
      newUser.id, 
      userAgent, 
      ipAddress,
      rememberMe
    );

    const response = NextResponse.json(
      { 
        message: 'Пользователь успешно зарегистрирован',
        user: newUser
      },
      { status: 201 }
    );

    // Устанавливаем httpOnly куки с разным временем жизни
    response.cookies.set('accessToken', accessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 1000 // 1 час
    });

    response.cookies.set('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: rememberMe 
        ? 365 * 24 * 60 * 60 * 1000 // 1 год для "Запомнить меня"
        : 30 * 24 * 60 * 60 * 1000 // 30 дней для обычной сессии
    });

    return response;

  } catch (error) {
    console.error('Ошибка регистрации:', error);
    
    if (error.code === 'P2002') {
      const field = error.meta?.target?.[0];
      if (field === 'email') {
        return NextResponse.json(
          { message: 'Пользователь с таким email уже существует' },
          { status: 409 }
        );
      }
      if (field === 'usertag') {
        return NextResponse.json(
          { message: 'Этот usertag уже занят' },
          { status: 409 }
        );
      }
    }

    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: auth/sessions/all/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/auth/sessions/all/route.js
РАЗМЕР: 1334 символов
================================================================================

// src/app/api/auth/sessions/all/route.js
import { NextResponse } from 'next/server';
import { deleteAllUserSessions } from '../../../../../lib/auth';
import { verifyAccessToken } from '../../../../../lib/auth';

// Удалить все сессии пользователя (кроме текущей)
export async function DELETE(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json(
        { message: 'Не авторизован' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: 'Недействительный токен' },
        { status: 401 }
      );
    }

    // Получаем все сессии пользователя
    const { getUserSessions, deleteSession } = await import('../../../../../lib/auth');
    const sessions = await getUserSessions(decoded.userId);

    // Удаляем все сессии кроме текущей
    for (const session of sessions) {
      if (session.id !== decoded.sessionId) {
        await deleteSession(session.id);
      }
    }

    return NextResponse.json({ message: 'Все другие сессии удалены' });

  } catch (error) {
    console.error('Ошибка удаления сессий:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: auth/sessions/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/auth/sessions/route.js
РАЗМЕР: 1817 символов
================================================================================

// src/app/api/auth/sessions/route.js
import { NextResponse } from 'next/server';
import { getUserSessions, deleteSession, deleteAllUserSessions } from '../../../../lib/auth';
import { verifyAccessToken } from '../../../../lib/auth';

// Получить все активные сессии пользователя
export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json(
        { message: 'Не авторизован' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: 'Недействительный токен' },
        { status: 401 }
      );
    }

    const sessions = await getUserSessions(decoded.userId);

    return NextResponse.json({ sessions });

  } catch (error) {
    console.error('Ошибка получения сессий:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}

// Удалить конкретную сессию
export async function DELETE(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;
    const { sessionId } = await request.json();

    if (!accessToken) {
      return NextResponse.json(
        { message: 'Не авторизован' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: 'Недействительный токен' },
        { status: 401 }
      );
    }

    await deleteSession(sessionId);

    return NextResponse.json({ message: 'Сессия удалена' });

  } catch (error) {
    console.error('Ошибка удаления сессии:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: friends/request/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/friends/request/route.js
РАЗМЕР: 3203 символов
================================================================================

// src/app/api/friends/request/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    const { userId } = await request.json();

    if (!userId) {
      return NextResponse.json({ message: 'User ID обязателен' }, { status: 400 });
    }

    // Нельзя отправить запрос самому себе
    if (userId === decoded.userId) {
      return NextResponse.json(
        { message: 'Нельзя отправить запрос в друзья самому себе' },
        { status: 400 }
      );
    }

    // Проверяем существование пользователя
    const targetUser = await prisma.user.findUnique({
      where: { id: userId }
    });

    if (!targetUser) {
      return NextResponse.json({ message: 'Пользователь не найден' }, { status: 404 });
    }

    // Проверяем, не отправили ли уже запрос
    const existingRequest = await prisma.friendRequest.findFirst({
      where: {
        senderId: decoded.userId,
        receiverId: userId
      }
    });

    if (existingRequest) {
      return NextResponse.json(
        { message: 'Запрос в друзья уже отправлен' },
        { status: 409 }
      );
    }

    // Проверяем, не являются ли уже друзьями
    const existingFriendship = await prisma.friendship.findFirst({
      where: {
        OR: [
          { user1Id: decoded.userId, user2Id: userId },
          { user1Id: userId, user2Id: decoded.userId }
        ]
      }
    });

    if (existingFriendship) {
      return NextResponse.json(
        { message: 'Пользователь уже у вас в друзьях' },
        { status: 409 }
      );
    }

    // Создаем запрос в друзья
    const friendRequest = await prisma.friendRequest.create({
      data: {
        senderId: decoded.userId,
        receiverId: userId,
        status: 'PENDING'
      },
      include: {
        sender: {
          select: {
            id: true,
            name: true,
            avatar: true,
            usertag: true
          }
        }
      }
    });

    // Создаем уведомление для получателя
    await prisma.notification.create({
      data: {
        userId: userId,
        type: 'friend_request',
        title: 'Новый запрос в друзья',
        message: `${friendRequest.sender.name} хочет добавить вас в друзья`,
        data: {
          requestId: friendRequest.id,
          senderId: decoded.userId,
          senderName: friendRequest.sender.name,
          senderAvatar: friendRequest.sender.avatar
        }
      }
    });

    return NextResponse.json({
      message: 'Запрос в друзья отправлен',
      request: friendRequest
    });

  } catch (error) {
    console.error('Ошибка отправки запроса в друзья:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: friends/respond/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/friends/respond/route.js
РАЗМЕР: 3626 символов
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    const { requestId, accept } = await request.json();

    console.log('📨 Обработка запроса дружбы:', { requestId, accept, userId: decoded.userId });

    if (!requestId) {
      return NextResponse.json({ message: 'Request ID обязателен' }, { status: 400 });
    }

    // Находим запрос
    const friendRequest = await prisma.friendRequest.findFirst({
      where: {
        id: requestId,
        receiverId: decoded.userId,
        status: 'PENDING'
      },
      include: {
        sender: {
          select: {
            id: true,
            name: true,
            avatar: true,
            usertag: true
          }
        },
        receiver: {
          select: {
            id: true,
            name: true,
            avatar: true,
            usertag: true
          }
        }
      }
    });

    console.log('🔍 Найден запрос дружбы:', friendRequest);

    if (!friendRequest) {
      return NextResponse.json({ message: 'Запрос не найден' }, { status: 404 });
    }

    if (accept) {
      // Принимаем запрос - создаем дружбу
      const result = await prisma.$transaction(async (tx) => {
        // Создаем запись о дружбе (убедимся, что user1Id всегда меньше user2Id для уникальности)
        const user1Id = friendRequest.senderId < decoded.userId ? friendRequest.senderId : decoded.userId;
        const user2Id = friendRequest.senderId < decoded.userId ? decoded.userId : friendRequest.senderId;

        console.log('👥 Создаем дружбу между:', { user1Id, user2Id });

        const friendship = await tx.friendship.create({
          data: {
            user1Id,
            user2Id
          }
        });

        // Обновляем статус запроса
        await tx.friendRequest.update({
          where: { id: requestId },
          data: { status: 'ACCEPTED' }
        });

        // Создаем уведомление для отправителя
        await tx.notification.create({
          data: {
            userId: friendRequest.senderId,
            type: 'friend_request_accepted',
            title: 'Запрос в друзья принят',
            message: `${friendRequest.receiver.name} принял(а) ваш запрос в друзья`,
            data: {
              friendId: decoded.userId,
              friendName: friendRequest.receiver.name,
              friendAvatar: friendRequest.receiver.avatar,
              friendUsertag: friendRequest.receiver.usertag
            }
          }
        });

        return friendship;
      });

      console.log('✅ Запрос дружбы принят:', result);

      return NextResponse.json({ 
        message: 'Запрос в друзья принят',
        friendship: result
      });

    } else {
      // Отклоняем запрос
      await prisma.friendRequest.update({
        where: { id: requestId },
        data: { status: 'REJECTED' }
      });

      console.log('❌ Запрос дружбы отклонен');

      return NextResponse.json({ message: 'Запрос в друзья отклонен' });
    }

  } catch (error) {
    console.error('❌ Ошибка обработки запроса в друзья:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: friends/status/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/friends/status/route.js
РАЗМЕР: 2043 символов
================================================================================

// src/app/api/friends/status/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const targetUserId = searchParams.get('targetUserId');
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    if (!targetUserId) {
      return NextResponse.json({ message: 'Target User ID обязателен' }, { status: 400 });
    }

    // Проверяем дружбу
    const friendship = await prisma.friendship.findFirst({
      where: {
        OR: [
          { user1Id: decoded.userId, user2Id: targetUserId },
          { user1Id: targetUserId, user2Id: decoded.userId }
        ]
      }
    });

    if (friendship) {
      return NextResponse.json({ status: 'friends' });
    }

    // Проверяем исходящий запрос
    const outgoingRequest = await prisma.friendRequest.findFirst({
      where: {
        senderId: decoded.userId,
        receiverId: targetUserId,
        status: 'PENDING'
      }
    });

    if (outgoingRequest) {
      return NextResponse.json({ status: 'pending' });
    }

    // Проверяем входящий запрос
    const incomingRequest = await prisma.friendRequest.findFirst({
      where: {
        senderId: targetUserId,
        receiverId: decoded.userId,
        status: 'PENDING'
      }
    });

    if (incomingRequest) {
      return NextResponse.json({ status: 'incoming' });
    }

    return NextResponse.json({ status: 'none' });

  } catch (error) {
    console.error('Ошибка проверки статуса дружбы:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: invitations/[id]/respond/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/invitations/[id]/respond/route.js
РАЗМЕР: 4777 символов
================================================================================

// src/app/api/invitations/[id]/respond/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function POST(request, { params }) {
  try {
    const { id: invitationId } = await params;
    const { accept } = await request.json();
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    // Получаем информацию о пользователе из базы
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: { id: true, name: true, email: true }
    });

    if (!user) {
      return NextResponse.json({ message: 'Пользователь не найден' }, { status: 404 });
    }

    // Находим приглашение
    const invitation = await prisma.invitation.findFirst({
      where: {
        id: invitationId,
        email: user.email // Используем email из базы данных
      },
      include: {
        vacation: true,
        invitedBy: {
          select: { name: true }
        }
      }
    });

    if (!invitation) {
      return NextResponse.json({ message: 'Приглашение не найдено' }, { status: 404 });
    }

    if (invitation.status !== 'pending') {
      return NextResponse.json({ message: 'Приглашение уже обработано' }, { status: 400 });
    }

    if (new Date() > invitation.expiresAt) {
      return NextResponse.json({ message: 'Приглашение истекло' }, { status: 400 });
    }

    if (accept) {
      // Принимаем приглашение
      await prisma.$transaction(async (tx) => {
        // Добавляем пользователя как участника
        await tx.vacationMember.create({
          data: {
            vacationId: invitation.vacationId,
            userId: user.id,
            role: 'member',
            status: 'accepted',
            joinedAt: new Date()
          }
        });

        // Обновляем статус приглашения
        await tx.invitation.update({
          where: { id: invitationId },
          data: { status: 'accepted' }
        });

        // Создаем уведомление для владельца
        await tx.notification.create({
          data: {
            userId: invitation.invitedById,
            type: 'info',
            title: 'Приглашение принято',
            message: `${user.name} принял(а) ваше приглашение в отпуск "${invitation.vacation.title}"`,
            data: {
              vacationId: invitation.vacationId,
              acceptedByName: user.name
            }
          }
        });

        // Обновляем уведомление приглашенного пользователя
        await tx.notification.updateMany({
          where: {
            userId: user.id,
            type: 'invitation',
            data: {
              path: ['invitationId'],
              equals: invitationId
            }
          },
          data: {
            data: {
              ...invitation.data,
              status: 'accepted'
            }
          }
        });
      });

      return NextResponse.json({ 
        message: 'Приглашение принято',
        vacationId: invitation.vacationId
      });
    } else {
      // Отклоняем приглашение
      await prisma.$transaction(async (tx) => {
        // Обновляем статус приглашения
        await tx.invitation.update({
          where: { id: invitationId },
          data: { status: 'rejected' }
        });

        // Создаем уведомление для владельца
        await tx.notification.create({
          data: {
            userId: invitation.invitedById,
            type: 'info',
            title: 'Приглашение отклонено',
            message: `${user.name} отклонил(а) ваше приглашение в отпуск "${invitation.vacation.title}"`,
            data: {
              vacationId: invitation.vacationId,
              rejectedByName: user.name
            }
          }
        });

        // Обновляем уведомление приглашенного пользователя
        await tx.notification.updateMany({
          where: {
            userId: user.id,
            type: 'invitation',
            data: {
              path: ['invitationId'],
              equals: invitationId
            }
          },
          data: {
            data: {
              ...invitation.data,
              status: 'rejected'
            }
          }
        });
      });

      return NextResponse.json({ message: 'Приглашение отклонено' });
    }

  } catch (error) {
    console.error('Ошибка обработки приглашения:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: memories/capture/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/memories/capture/route.js
РАЗМЕР: 3546 символов
================================================================================

// src/app/api/memories/capture/route.js
import { NextResponse } from 'next/server';
import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    const formData = await request.formData();
    const vacationId = formData.get('vacationId');
    const photos = formData.getAll('photos');

    if (!vacationId || photos.length === 0) {
      return NextResponse.json(
        { message: 'Отсутствуют обязательные данные' },
        { status: 400 }
      );
    }

    // Проверяем доступ к отпуску
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: vacationId,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    // Проверяем лимит фотографий на день (3 фото)
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const todayMemories = await prisma.memory.count({
      where: {
        vacationId,
        authorId: decoded.userId,
        createdAt: {
          gte: today,
          lt: tomorrow
        }
      }
    });

    if (todayMemories + photos.length > 3) {
      return NextResponse.json(
        { message: 'Превышен лимит в 3 фотографии в день' },
        { status: 400 }
      );
    }

    const createdMemories = [];

    // Создаем директорию для загрузок если её нет
    const uploadDir = join(process.cwd(), 'public', 'uploads', 'memories');
    try {
      await mkdir(uploadDir, { recursive: true });
    } catch (error) {
      // Директория уже существует
    }

    for (const photo of photos) {
      const bytes = await photo.arrayBuffer();
      const buffer = Buffer.from(bytes);
      
      // Генерируем уникальное имя файла
      const timestamp = Date.now();
      const filename = `${timestamp}-${photo.name}`;
      const filepath = join(uploadDir, filename);

      // Сохраняем файл
      await writeFile(filepath, buffer);

      // Создаем запись в базе
      const memory = await prisma.memory.create({
        data: {
          title: `Фото дня - ${new Date().toLocaleDateString('ru-RU')}`,
          description: 'Запечатленный момент',
          imageUrl: `/uploads/memories/${filename}`,
          takenAt: new Date(),
          vacationId,
          authorId: decoded.userId,
          tags: ['captured_moment']
        },
        include: {
          author: {
            select: { id: true, name: true, avatar: true }
          }
        }
      });

      createdMemories.push(memory);
    }

    return NextResponse.json({ 
      message: 'Фотографии успешно сохранены',
      memories: createdMemories 
    }, { status: 201 });

  } catch (error) {
    console.error('Ошибка сохранения фотографий:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: notifications/invite/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/notifications/invite/route.js
РАЗМЕР: 1259 символов
================================================================================

// src/app/api/notifications/invite/route.js
import { NextResponse } from 'next/server';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const { userId, vacationId, invitedByName, vacationTitle } = await request.json();

    if (!userId || !vacationId || !invitedByName) {
      return NextResponse.json(
        { message: 'Отсутствуют обязательные данные' },
        { status: 400 }
      );
    }

    // Создаем уведомление о приглашении
    const notification = await prisma.notification.create({
      data: {
        userId,
        type: 'invitation',
        title: 'Приглашение в отпуск',
        message: `${invitedByName} пригласил(а) вас в отпуск "${vacationTitle}"`,
        data: {
          vacationId,
          invitedByName,
          vacationTitle
        }
      },
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            avatar: true 
          }
        }
      }
    });

    return NextResponse.json(notification, { status: 201 });

  } catch (error) {
    console.error('Ошибка создания уведомления:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: notifications/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/notifications/route.js
РАЗМЕР: 2505 символов
================================================================================

// src/app/api/notifications/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

// Получить уведомления пользователя
export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    const notifications = await prisma.notification.findMany({
      where: { 
        userId: decoded.userId 
      },
      orderBy: { 
        createdAt: 'desc' 
      },
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            avatar: true 
          }
        }
      },
      take: 50
    });

    return NextResponse.json(notifications);

  } catch (error) {
    console.error('Ошибка получения уведомлений:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}

// Пометить уведомления как прочитанные
export async function PUT(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    const { notificationIds } = await request.json();

    if (notificationIds && notificationIds.length > 0) {
      // Пометить конкретные уведомления как прочитанные
      await prisma.notification.updateMany({
        where: { 
          id: { in: notificationIds },
          userId: decoded.userId 
        },
        data: { isRead: true }
      });
    } else {
      // Пометить все как прочитанные
      await prisma.notification.updateMany({
        where: { 
          userId: decoded.userId,
          isRead: false 
        },
        data: { isRead: true }
      });
    }

    return NextResponse.json({ message: 'Уведомления помечены как прочитанные' });

  } catch (error) {
    console.error('Ошибка обновления уведомлений:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: notifications/test/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/notifications/test/route.js
РАЗМЕР: 2783 символов
================================================================================

// src/app/api/notifications/test/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    const { type = 'info' } = await request.json();

    // Создаем тестовое уведомление
    let notificationData;

    switch (type) {
      case 'invitation':
        notificationData = {
          userId: decoded.userId,
          type: 'invitation',
          title: 'Приглашение в отпуск',
          message: 'Анна пригласила вас в отпуск "Отдых на Бали"',
          data: {
            invitationId: 'test-invitation-123',
            vacationId: 'test-vacation-456',
            invitedByName: 'Анна',
            vacationTitle: 'Отдых на Бали'
          }
        };
        break;

      case 'activity_update':
        notificationData = {
          userId: decoded.userId,
          type: 'activity_update',
          title: 'Обновление планов',
          message: 'В вашем отпуске "Горные походы" добавлена новая активность',
          data: {
            vacationId: 'test-vacation-789',
            activityId: 'test-activity-123'
          }
        };
        break;

      case 'memory_comment':
        notificationData = {
          userId: decoded.userId,
          type: 'memory_comment',
          title: 'Новый комментарий',
          message: 'Иван прокомментировал ваше воспоминание',
          data: {
            memoryId: 'test-memory-123',
            commentId: 'test-comment-456'
          }
        };
        break;

      default:
        notificationData = {
          userId: decoded.userId,
          type: 'info',
          title: 'Тестовое уведомление',
          message: 'Это тестовое уведомление для проверки системы',
          data: {
            test: true
          }
        };
    }

    const notification = await prisma.notification.create({
      data: notificationData,
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            avatar: true 
          }
        }
      }
    });

    return NextResponse.json({
      message: 'Тестовое уведомление создано',
      notification
    });

  } catch (error) {
    console.error('Ошибка создания тестового уведомления:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: posts/[id]/comments/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/posts/[id]/comments/route.js
РАЗМЕР: 4155 символов
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';
import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';

// Получить комментарии поста
export async function GET(request, { params }) {
  try {
    const { id: postId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    const comments = await prisma.comment.findMany({
      where: { postId },
      include: {
        author: {
          select: { id: true, name: true, avatar: true, usertag: true }
        },
        // ПРАВИЛЬНО: images (согласно схеме)
        images: true
      },
      orderBy: { createdAt: 'asc' }
    });

    return NextResponse.json(comments);

  } catch (error) {
    console.error('Ошибка получения комментариев:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}

// Создать комментарий
export async function POST(request, { params }) {
  try {
    const { id: postId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    const formData = await request.formData();
    const content = formData.get('content');
    const images = formData.getAll('images');

    if (!content || content.trim().length === 0) {
      return NextResponse.json(
        { message: 'Содержание комментария обязательно' },
        { status: 400 }
      );
    }

    // Проверяем существование поста
    const post = await prisma.post.findUnique({
      where: { id: postId }
    });

    if (!post) {
      return NextResponse.json({ message: 'Пост не найден' }, { status: 404 });
    }

    const result = await prisma.$transaction(async (tx) => {
      // Создаем комментарий
      const comment = await tx.comment.create({
        data: {
          content: content.trim(),
          authorId: decoded.userId,
          postId
        },
        include: {
          author: {
            select: { id: true, name: true, avatar: true, usertag: true }
          },
          // ПРАВИЛЬНО: images (согласно схеме)
          images: true
        }
      });

      // Обрабатываем изображения
      if (images && images.length > 0) {
        const commentImages = [];

        for (const image of images) {
          if (image.size > 0) {
            // Создаем директорию для загрузок
            const uploadDir = join(process.cwd(), 'public', 'uploads', 'comments');
            await mkdir(uploadDir, { recursive: true });

            // Генерируем уникальное имя файла
            const timestamp = Date.now();
            const filename = `${timestamp}-${image.name}`;
            const filepath = join(uploadDir, filename);

            // Сохраняем файл
            const bytes = await image.arrayBuffer();
            const buffer = Buffer.from(bytes);
            await writeFile(filepath, buffer);

            // Создаем запись в базе - ПРАВИЛЬНО
            const commentImage = await tx.commentImage.create({
              data: {
                url: `/uploads/comments/${filename}`,
                commentId: comment.id
              }
            });

            commentImages.push(commentImage);
          }
        }

        comment.images = commentImages;
      }

      return comment;
    });

    return NextResponse.json(result, { status: 201 });

  } catch (error) {
    console.error('Ошибка создания комментария:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: posts/[id]/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/posts/[id]/route.js
РАЗМЕР: 4919 символов
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

// Получить пост
export async function GET(request, { params }) {
  try {
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    const post = await prisma.post.findUnique({
      where: { id },
      include: {
        author: {
          select: { id: true, name: true, avatar: true, usertag: true }
        },
        // ПРАВИЛЬНО: images (согласно схеме)
        images: true,
        likes: {
          select: { userId: true }
        },
        comments: {
          include: {
            author: {
              select: { id: true, name: true, avatar: true, usertag: true }
            },
            // ПРАВИЛЬНО: images (согласно схеме)
            images: true
          },
          orderBy: { createdAt: 'asc' }
        }
      }
    });

    if (!post) {
      return NextResponse.json({ message: 'Пост не найден' }, { status: 404 });
    }

    return NextResponse.json(post);

  } catch (error) {
    console.error('Ошибка получения поста:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}

// Обновить пост
export async function PUT(request, { params }) {
  try {
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    const { content, imageUrls } = await request.json();

    // Проверяем, что пользователь является автором поста
    const existingPost = await prisma.post.findFirst({
      where: { 
        id,
        authorId: decoded.userId 
      }
    });

    if (!existingPost) {
      return NextResponse.json({ message: 'Пост не найден или нет прав' }, { status: 404 });
    }

    const result = await prisma.$transaction(async (tx) => {
      // Обновляем пост
      const updatedPost = await tx.post.update({
        where: { id },
        data: { 
          content,
          updatedAt: new Date()
        },
        include: {
          author: {
            select: { id: true, name: true, avatar: true, usertag: true }
          },
          // ПРАВИЛЬНО: images (согласно схеме)
          images: true,
          likes: {
            select: { userId: true }
          }
        }
      });

      // Если есть новые изображения, обновляем их
      if (imageUrls && imageUrls.length > 0) {
        // Удаляем старые изображения
        await tx.postImage.deleteMany({
          where: { postId: id }
        });

        // Добавляем новые изображения
        const postImages = imageUrls.map(url => ({
          url,
          postId: id
        }));

        await tx.postImage.createMany({
          data: postImages
        });

        // Получаем обновленные изображения
        updatedPost.images = await tx.postImage.findMany({
          where: { postId: id }
        });
      }

      return updatedPost;
    });

    return NextResponse.json(result);

  } catch (error) {
    console.error('Ошибка обновления поста:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}

// Удалить пост
export async function DELETE(request, { params }) {
  try {
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    // Проверяем, что пользователь является автором поста
    const existingPost = await prisma.post.findFirst({
      where: { 
        id,
        authorId: decoded.userId 
      }
    });

    if (!existingPost) {
      return NextResponse.json({ message: 'Пост не найден или нет прав' }, { status: 404 });
    }

    // Удаляем пост (каскадно удалятся изображения, лайки и комментарии)
    await prisma.post.delete({
      where: { id }
    });

    return NextResponse.json({ message: 'Пост удален' });

  } catch (error) {
    console.error('Ошибка удаления поста:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: profile/delete-temp/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/profile/delete-temp/route.js
РАЗМЕР: 1401 символов
================================================================================

// src/app/api/profile/delete-temp/route.js
import { NextResponse } from 'next/server';
import { unlink } from 'fs/promises';
import { join } from 'path';
import { verifyAccessToken } from '../../../../lib/auth';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    const { imagePath } = await request.json();
    if (!imagePath || !imagePath.startsWith('/uploads/temp/')) {
      return NextResponse.json({ message: 'Недопустимый путь изображения' }, { status: 400 });
    }

    const filepath = join(process.cwd(), 'public', imagePath);
    try {
      await unlink(filepath);
      console.log(`Deleted temp file: ${filepath}`);
    } catch (error) {
      if (error.code !== 'ENOENT') {
        console.error(`Error deleting temp file ${filepath}:`, error);
      }
    }

    return NextResponse.json({ message: 'Временное изображение удалено' });

  } catch (error) {
    console.error('Ошибка удаления временного изображения:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: profile/posts/[id]/like/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/profile/posts/[id]/like/route.js
РАЗМЕР: 1929 символов
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function POST(request, { params }) {
  try {
    const { id: postId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    // Проверяем существование поста
    const post = await prisma.post.findUnique({
      where: { id: postId },
      include: {
        likes: {
          where: { userId: decoded.userId }
        }
      }
    });

    if (!post) {
      return NextResponse.json({ message: 'Запись не найдена' }, { status: 404 });
    }

    const isLiked = post.likes.length > 0;

    if (isLiked) {
      // Удаляем лайк
      await prisma.postLike.deleteMany({
        where: {
          postId: postId,
          userId: decoded.userId
        }
      });
    } else {
      // Добавляем лайк
      await prisma.postLike.create({
        data: {
          postId: postId,
          userId: decoded.userId
        }
      });
    }

    // Получаем обновленное количество лайков
    const updatedPost = await prisma.post.findUnique({
      where: { id: postId },
      include: {
        likes: {
          select: { userId: true }
        },
        _count: {
          select: {
            likes: true,
            comments: true
          }
        }
      }
    });

    return NextResponse.json({
      liked: !isLiked,
      likesCount: updatedPost._count.likes
    });

  } catch (error) {
    console.error('Ошибка лайка записи:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: profile/posts/[id]/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/profile/posts/[id]/route.js
РАЗМЕР: 2003 символов
================================================================================

// src/app/api/profile/posts/[id]/like/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

export async function POST(request, { params }) {
  try {
    const { id: postId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    // Проверяем, существует ли пост
    const post = await prisma.post.findUnique({
      where: { id: postId },
      include: {
        likes: {
          where: { userId: decoded.userId }
        }
      }
    });

    if (!post) {
      return NextResponse.json({ message: 'Запись не найдена' }, { status: 404 });
    }

    const isLiked = post.likes.length > 0;

    if (isLiked) {
      // Удаляем лайк
      await prisma.postLike.deleteMany({
        where: {
          postId: postId,
          userId: decoded.userId
        }
      });
    } else {
      // Добавляем лайк
      await prisma.postLike.create({
        data: {
          postId: postId,
          userId: decoded.userId
        }
      });
    }

    // Получаем обновленное количество лайков
    const updatedPost = await prisma.post.findUnique({
      where: { id: postId },
      include: {
        likes: {
          select: { userId: true }
        },
        _count: {
          select: {
            likes: true,
            comments: true
          }
        }
      }
    });

    return NextResponse.json({
      liked: !isLiked,
      likesCount: updatedPost._count.likes
    });

  } catch (error) {
    console.error('Ошибка лайка записи:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: profile/posts/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/profile/posts/route.js
РАЗМЕР: 7584 символов
================================================================================

// src/app/api/profile/posts/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';
import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';

export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const userId = searchParams.get('userId');
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    if (!userId) {
      return NextResponse.json({ message: 'User ID обязателен' }, { status: 400 });
    }

    // Находим пользователя и проверяем настройки приватности
    const profileUser = await prisma.user.findUnique({
      where: { id: userId },
      select: { 
        id: true,
        profileVisibility: true 
      }
    });

    if (!profileUser) {
      return NextResponse.json({ message: 'Пользователь не найден' }, { status: 404 });
    }

    const currentUserId = decoded.userId;
    const isOwnProfile = currentUserId === userId;

    // Проверяем видимость постов
    let canViewPosts = false;
    
    if (isOwnProfile) {
      canViewPosts = true;
    } else {
      switch (profileUser.profileVisibility) {
        case 'PUBLIC':
          canViewPosts = true;
          break;
        case 'FRIENDS_ONLY':
          // Проверяем дружбу
          const friendship = await prisma.friendship.findFirst({
            where: {
              OR: [
                { user1Id: currentUserId, user2Id: userId },
                { user1Id: userId, user2Id: currentUserId }
              ]
            }
          });
          canViewPosts = !!friendship;
          break;
        case 'PRIVATE':
          canViewPosts = false;
          break;
      }
    }

    if (!canViewPosts) {
      return NextResponse.json([], { status: 200 });
    }

    // Получаем посты
    const posts = await prisma.post.findMany({
      where: { authorId: userId },
      include: {
        author: {
          select: {
            id: true,
            name: true,
            avatar: true,
            usertag: true
          }
        },
        // ПРАВИЛЬНОЕ имя отношения согласно схеме
        images: {
          select: {
            id: true,
            url: true
          }
        },
        likes: {
          select: {
            userId: true
          }
        },
        comments: {
          include: {
            author: {
              select: {
                id: true,
                name: true,
                avatar: true
              }
            },
            // ПРАВИЛЬНОЕ имя отношения для комментариев
            images: true
          },
          orderBy: {
            createdAt: 'asc'
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    return NextResponse.json(posts);

  } catch (error) {
    console.error('Ошибка получения постов:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    const formData = await request.formData();
    const content = formData.get('content');
    const imageFiles = formData.getAll('images');

    // Валидация контента
    if (!content || typeof content !== 'string' || content.trim().length === 0) {
      return NextResponse.json(
        { message: 'Содержание обязательно' },
        { status: 400 }
      );
    }

    const trimmedContent = content.trim();
    if (trimmedContent.length > 500) {
      return NextResponse.json(
        { message: 'Содержание не должно превышать 500 символов' },
        { status: 400 }
      );
    }

    // Валидация изображений
    if (imageFiles && imageFiles.length > 0) {
      for (const image of imageFiles) {
        if (image.size === 0) continue;
        
        // Проверка типа файла
        const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
        if (!allowedTypes.includes(image.type)) {
          return NextResponse.json(
            { message: 'Разрешены только изображения в формате JPEG, PNG или WebP' },
            { status: 400 }
          );
        }

        // Проверка размера файла (5MB максимум)
        const maxSize = 5 * 1024 * 1024;
        if (image.size > maxSize) {
          return NextResponse.json(
            { message: 'Размер каждого изображения не должен превышать 5MB' },
            { status: 400 }
          );
        }
      }
    }

    // Создаем пост и изображения в транзакции
    const result = await prisma.$transaction(async (tx) => {
      // Создаем пост
      const post = await tx.post.create({
        data: {
          content: trimmedContent,
          authorId: decoded.userId
        }
      });

      // Обрабатываем изображения
      if (imageFiles && imageFiles.length > 0) {
        for (const image of imageFiles) {
          if (image.size === 0) continue;

          // Создаем директорию для загрузок
          const uploadDir = join(process.cwd(), 'public', 'uploads', 'posts');
          await mkdir(uploadDir, { recursive: true });

          // Генерируем уникальное имя файла
          const timestamp = Date.now();
          const randomString = Math.random().toString(36).substring(2, 15);
          const fileExtension = image.name.split('.').pop();
          const filename = `${timestamp}-${randomString}.${fileExtension}`;
          const filepath = join(uploadDir, filename);

          // Сохраняем файл
          const bytes = await image.arrayBuffer();
          const buffer = Buffer.from(bytes);
          await writeFile(filepath, buffer);

          // Создаем запись в базе
          await tx.postImage.create({
            data: {
              url: `/uploads/posts/${filename}`,
              postId: post.id
            }
          });
        }
      }

      // Получаем полные данные поста
      const postWithData = await tx.post.findUnique({
        where: { id: post.id },
        include: {
          author: {
            select: {
              id: true,
              name: true,
              avatar: true,
              usertag: true
            }
          },
          // ПРАВИЛЬНОЕ имя отношения
          images: {
            select: {
              id: true,
              url: true
            }
          },
          likes: {
            select: {
              userId: true
            }
          },
          comments: {
            include: {
              author: {
                select: {
                  id: true,
                  name: true,
                  avatar: true
                }
              }
            }
          }
        }
      });

      return postWithData;
    });

    return NextResponse.json(result, { status: 201 });

  } catch (error) {
    console.error('Ошибка создания поста:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: profile/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/profile/route.js
РАЗМЕР: 9507 символов
================================================================================

// src/app/api/profile/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';
import { getUserGroup, getLevelProgress } from '../../../lib/userLevels';
import { writeFile, mkdir, unlink, rename } from 'fs/promises';
import { join } from 'path';

export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const usertag = searchParams.get('usertag');
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    if (!usertag) {
      return NextResponse.json({ message: 'Usertag обязателен' }, { status: 400 });
    }

    // Находим пользователя по usertag
    const user = await prisma.user.findUnique({
      where: { usertag },
      select: {
        id: true,
        name: true,
        usertag: true,
        email: true,
        avatar: true,
        banner: true,
        bio: true,
        location: true,
        website: true,
        experiencePoints: true,
        createdAt: true,
        profileVisibility: true,
      }
    });

    if (!user) {
      return NextResponse.json({ message: 'Пользователь не найден' }, { status: 404 });
    }

    const isOwnProfile = decoded.userId === user.id;

    // Проверяем дружбу для определения видимости постов
    let canViewPosts = false;
    
    if (isOwnProfile) {
      canViewPosts = true;
    } else {
      switch (user.profileVisibility) {
        case 'PUBLIC':
          canViewPosts = true;
          break;
        case 'FRIENDS_ONLY':
          const friendship = await prisma.friendship.findFirst({
            where: {
              OR: [
                { user1Id: decoded.userId, user2Id: user.id },
                { user1Id: user.id, user2Id: decoded.userId }
              ]
            }
          });
          canViewPosts = !!friendship;
          break;
        case 'PRIVATE':
          canViewPosts = false;
          break;
      }
    }

    // Получаем посты в зависимости от прав доступа
    let posts = [];
    if (canViewPosts) {
      posts = await prisma.post.findMany({
        where: { authorId: user.id },
        orderBy: { createdAt: 'desc' },
        include: {
          author: {
            select: { id: true, name: true, avatar: true }
          },
          likes: {
            select: { userId: true }
          },
          comments: {
            select: { id: true }
          }
        }
      });
    }

    // Получаем ВСЕ отпуски пользователя через vacation_members
    const vacationMembers = await prisma.vacationMember.findMany({
      where: {
        userId: user.id,
        status: 'accepted'
      },
      include: {
        vacation: {
          include: {
            user: {
              select: { id: true, name: true, avatar: true }
            },
            members: {
              where: { status: 'accepted' },
              include: {
                user: {
                  select: { id: true, name: true, avatar: true }
                }
              }
            },
            _count: {
              select: {
                activities: true,
                memories: true,
                members: true
              }
            }
          }
        }
      },
      orderBy: { vacation: { startDate: 'desc' } }
    });

    // Преобразуем в формат отпусков
    const vacations = vacationMembers.map(member => ({
      ...member.vacation,
      userRole: member.role,
      isOwner: member.role === 'owner'
    }));

    // Получаем информацию об уровне пользователя
    const userGroup = await getUserGroup(user.id);
    const levelProgress = await getLevelProgress(user.id);

    // Формируем полный профиль
    const userProfile = {
      ...user,
      posts,
      vacations,
      canViewPosts,
      userGroup,
      levelProgress
    };

    return NextResponse.json(userProfile);

  } catch (error) {
    console.error('Ошибка получения профиля:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}

export async function PUT(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    const { name, usertag, bio, location, website, profileVisibility, avatar, banner } = await request.json();

    // Валидация
    if (!name || !usertag) {
      return NextResponse.json(
        { message: 'Имя и usertag обязательны' },
        { status: 400 }
      );
    }

    if (usertag.length < 3 || usertag.length > 20) {
      return NextResponse.json(
        { message: 'Usertag должен быть от 3 до 20 символов' },
        { status: 400 }
      );
    }

    if (!/^[a-z0-9-]+$/.test(usertag)) {
      return NextResponse.json(
        { message: 'Usertag может содержать только латинские буквы в нижнем регистре, цифры и дефисы' },
        { status: 400 }
      );
    }

    // Проверяем, не занят ли usertag другим пользователем
    const existingUser = await prisma.user.findFirst({
      where: {
        usertag,
        NOT: {
          id: decoded.userId
        }
      }
    });

    if (existingUser) {
      return NextResponse.json(
        { message: 'Этот usertag уже занят' },
        { status: 409 }
      );
    }

    // Получаем текущий профиль для проверки старых изображений
    const currentUser = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: { avatar: true, banner: true }
    });

    // Обрабатываем перемещение временных изображений
    const updateData = { name, usertag, bio, location, website, profileVisibility };
    
    if (avatar && avatar.startsWith('/uploads/temp/')) {
      const filename = avatar.split('/').pop();
      const tempPath = join(process.cwd(), 'public', avatar);
      const finalPath = join(process.cwd(), 'public', 'uploads', 'avatars', filename);
      await mkdir(join(process.cwd(), 'public', 'uploads', 'avatars'), { recursive: true });
      
      // Перемещаем файл
      try {
        await rename(tempPath, finalPath);
        updateData.avatar = `/uploads/avatars/${filename}`;
        
        // Удаляем старый аватар, если он существует
        if (currentUser.avatar && currentUser.avatar.startsWith('/uploads/avatars/')) {
          const oldAvatarPath = join(process.cwd(), 'public', currentUser.avatar);
          try {
            await unlink(oldAvatarPath);
            console.log(`Deleted old avatar: ${oldAvatarPath}`);
          } catch (error) {
            if (error.code !== 'ENOENT') {
              console.error(`Error deleting old avatar ${oldAvatarPath}:`, error);
            }
          }
        }
      } catch (error) {
        console.error(`Error moving avatar ${tempPath}:`, error);
        return NextResponse.json(
          { message: 'Ошибка при обработке аватара' },
          { status: 500 }
        );
      }
    }

    if (banner && banner.startsWith('/uploads/temp/')) {
      const filename = banner.split('/').pop();
      const tempPath = join(process.cwd(), 'public', banner);
      const finalPath = join(process.cwd(), 'public', 'uploads', 'banners', filename);
      await mkdir(join(process.cwd(), 'public', 'uploads', 'banners'), { recursive: true });
      
      // Перемещаем файл
      try {
        await rename(tempPath, finalPath);
        updateData.banner = `/uploads/banners/${filename}`;
        
        // Удаляем старый баннер, если он существует
        if (currentUser.banner && currentUser.banner.startsWith('/uploads/banners/')) {
          const oldBannerPath = join(process.cwd(), 'public', currentUser.banner);
          try {
            await unlink(oldBannerPath);
            console.log(`Deleted old banner: ${oldBannerPath}`);
          } catch (error) {
            if (error.code !== 'ENOENT') {
              console.error(`Error deleting old banner ${oldBannerPath}:`, error);
            }
          }
        }
      } catch (error) {
        console.error(`Error moving banner ${tempPath}:`, error);
        return NextResponse.json(
          { message: 'Ошибка при обработке баннера' },
          { status: 500 }
        );
      }
    }

    // Обновляем профиль
    const updatedUser = await prisma.user.update({
      where: { id: decoded.userId },
      data: updateData,
      select: {
        id: true,
        name: true,
        usertag: true,
        email: true,
        avatar: true,
        banner: true,
        bio: true,
        location: true,
        website: true,
        profileVisibility: true,
        createdAt: true
      }
    });

    return NextResponse.json(updatedUser);

  } catch (error) {
    console.error('Ошибка обновления профиля:', error);
    
    if (error.code === 'P2002') {
      return NextResponse.json(
        { message: 'Этот usertag уже занят' },
        { status: 409 }
      );
    }

    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: profile/upload/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/profile/upload/route.js
РАЗМЕР: 2575 символов
================================================================================

// src/app/api/profile/upload/route.js
import { NextResponse } from 'next/server';
import { writeFile, mkdir, unlink } from 'fs/promises';
import { join } from 'path';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    const formData = await request.formData();
    const image = formData.get('image');
    const type = formData.get('type'); // 'avatar' или 'banner'

    if (!image || !type) {
      return NextResponse.json(
        { message: 'Отсутствуют обязательные данные' },
        { status: 400 }
      );
    }

    if (!image.type.startsWith('image/')) {
      return NextResponse.json(
        { message: 'Файл должен быть изображением' },
        { status: 400 }
      );
    }

    if (image.size > 5 * 1024 * 1024) {
      return NextResponse.json(
        { message: 'Размер файла не должен превышать 5MB' },
        { status: 400 }
      );
    }

    // Создаем директорию для временных файлов
    const tempDir = join(process.cwd(), 'public', 'uploads', 'temp');
    await mkdir(tempDir, { recursive: true });

    // Генерируем уникальное имя файла
    const timestamp = Date.now();
    const fileExtension = image.name.split('.').pop();
    const filename = `${decoded.userId}-${type}-${timestamp}.${fileExtension}`;
    const filepath = join(tempDir, filename);
    const tempPath = `/uploads/temp/${filename}`;

    // Сохраняем файл
    const bytes = await image.arrayBuffer();
    const buffer = Buffer.from(bytes);
    await writeFile(filepath, buffer);

    // Планируем удаление файла через 5 минут
    setTimeout(async () => {
      try {
        await unlink(filepath);
        console.log(`Deleted temp file: ${filepath}`);
      } catch (error) {
        console.error(`Error deleting temp file ${filepath}:`, error);
      }
    }, 5 * 60 * 1000); // 5 минут

    // Возвращаем временный путь
    return NextResponse.json({
      message: 'Изображение временно загружено',
      tempPath
    });

  } catch (error) {
    console.error('Ошибка загрузки изображения:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: users/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/users/route.js
РАЗМЕР: 2694 символов
================================================================================

// src/app/api/users/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const search = searchParams.get('search') || '';
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');
    const skip = (page - 1) * limit;

    // Базовые условия для поиска
    const where = {
      OR: [
        { name: { contains: search, mode: 'insensitive' } },
        { usertag: { contains: search, mode: 'insensitive' } }
      ],
      // Исключаем текущего пользователя
      NOT: {
        id: decoded.userId
      }
    };

    console.log('🔍 Поиск пользователей с условиями:', { search, page, limit });

    // Получаем пользователей с правильными полями
    const users = await prisma.user.findMany({
      where,
      select: {
        id: true,
        name: true,
        usertag: true,
        avatar: true,
        bio: true,
        location: true,
        createdAt: true,
        profileVisibility: true,
        _count: {
          select: {
            vacationMembers: {
              where: { status: 'accepted' }
            },
            posts: true,
            friendsAsUser1: true,
            friendsAsUser2: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      skip,
      take: limit
    });

    console.log('✅ Найдено пользователей:', users.length);

    // Форматируем данные для фронтенда
    const formattedUsers = users.map(user => ({
      ...user,
      vacationCount: user._count.vacationMembers,
      postCount: user._count.posts,
      friendCount: user._count.friendsAsUser1 + user._count.friendsAsUser2
    }));

    // Получаем общее количество для пагинации
    const total = await prisma.user.count({ where });

    return NextResponse.json({
      users: formattedUsers,
      pagination: {
        page,
        limit,
        total,
        hasNext: skip + users.length < total,
        hasPrev: page > 1
      }
    });

  } catch (error) {
    console.error('❌ Ошибка получения пользователей:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: vacations/[id]/activities/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/vacations/[id]/activities/route.js
РАЗМЕР: 2063 символов
================================================================================

// src/app/api/vacations/[id]/activities/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

export async function GET(request, { params }) {
  try {
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    // Проверяем доступ к отпуску
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: id,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    // ИСПРАВЛЕНО: правильные поля для модели Activity
    const activities = await prisma.activity.findMany({
      where: { vacationId: id },
      orderBy: { date: 'asc' },
      include: {
        location: {
          select: { id: true, name: true, address: true }
        },
        participants: {
          include: {
            user: {
              select: { id: true, name: true, avatar: true }
            }
          }
        }
      }
    });

    // Преобразуем данные для удобства использования
    const formattedActivities = activities.map(activity => ({
      ...activity,
      // Берем первого участника как "автора" активности
      author: activity.participants[0]?.user || null,
      participants: activity.participants.map(p => p.user)
    }));

    return NextResponse.json(formattedActivities);

  } catch (error) {
    console.error('Ошибка получения активностей:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: vacations/[id]/invite/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/vacations/[id]/invite/route.js
РАЗМЕР: 3568 символов
================================================================================

// src/app/api/vacations/[id]/invite/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';
import { randomBytes } from 'crypto';

export async function POST(request, { params }) {
  try {
    // Await params для Next.js 15
    const { id: vacationId } = await params;
    const { email } = await request.json();
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    // Проверяем, что пользователь - владелец отпуска
    const vacation = await prisma.vacation.findFirst({
      where: {
        id: vacationId,
        userId: decoded.userId
      },
      include: {
        user: {
          select: { name: true }
        }
      }
    });

    if (!vacation) {
      return NextResponse.json({ message: 'Отпуск не найден или нет прав' }, { status: 404 });
    }

    // Проверяем, существует ли пользователь с таким email
    const invitedUser = await prisma.user.findUnique({
      where: { email }
    });

    if (!invitedUser) {
      return NextResponse.json({ message: 'Пользователь с таким email не найден' }, { status: 404 });
    }

    // Проверяем, не приглашен ли уже этот пользователь
    const existingInvitation = await prisma.invitation.findFirst({
      where: {
        vacationId,
        email
      }
    });

    if (existingInvitation) {
      return NextResponse.json({ message: 'Пользователь уже приглашен' }, { status: 409 });
    }

    // Проверяем, не является ли пользователь уже участником
    const existingMember = await prisma.vacationMember.findFirst({
      where: {
        vacationId,
        userId: invitedUser.id
      }
    });

    if (existingMember) {
      return NextResponse.json({ message: 'Пользователь уже является участником' }, { status: 409 });
    }

    // Создаем приглашение
    const token = randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 дней

    const invitation = await prisma.invitation.create({
      data: {
        vacationId,
        email,
        token,
        invitedById: decoded.userId,
        expiresAt
      }
    });

    // Создаем уведомление для приглашенного пользователя
    const notification = await prisma.notification.create({
      data: {
        userId: invitedUser.id,
        type: 'invitation',
        title: 'Приглашение в отпуск',
        message: `${vacation.user.name} пригласил(а) вас в отпуск "${vacation.title}"`,
        data: {
          invitationId: invitation.id,
          vacationId: vacation.id,
          invitedByName: vacation.user.name,
          vacationTitle: vacation.title
        }
      },
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            avatar: true 
          }
        }
      }
    });

    return NextResponse.json({ 
      message: 'Приглашение отправлено',
      invitation: {
        id: invitation.id,
        email: invitation.email,
        status: invitation.status
      },
      notification
    });

  } catch (error) {
    console.error('Ошибка отправки приглашения:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: vacations/[id]/members/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/vacations/[id]/members/route.js
РАЗМЕР: 1629 символов
================================================================================

// src/app/api/vacations/[id]/members/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

export async function GET(request, { params }) {
  try {
    // Await params для Next.js 15
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    // Проверяем доступ к отпуску
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: id,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    const members = await prisma.vacationMember.findMany({
      where: { vacationId: id },
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            email: true, 
            avatar: true 
          }
        }
      },
      orderBy: { createdAt: 'asc' }
    });

    return NextResponse.json(members);

  } catch (error) {
    console.error('Ошибка получения участников:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: vacations/[id]/memories/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/vacations/[id]/memories/route.js
РАЗМЕР: 1553 символов
================================================================================

// src/app/api/vacations/[id]/memories/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

export async function GET(request, { params }) {
  try {
    // Await params для Next.js 15
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    // Проверяем доступ к отпуску
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: id,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: 'Доступ запрещен' }, { status: 403 });
    }

    const memories = await prisma.memory.findMany({
      where: { vacationId: id },
      orderBy: { createdAt: 'desc' },
      include: {
        author: {
          select: { id: true, name: true, avatar: true }
        }
      }
    });

    return NextResponse.json(memories);

  } catch (error) {
    console.error('Ошибка получения воспоминаний:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: vacations/[id]/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/vacations/[id]/route.js
РАЗМЕР: 3109 символов
================================================================================

// src/app/api/vacations/[id]/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function GET(request, { params }) {
  try {
    const { id } = await params;
    console.log('🔍 Получение отпуска с ID:', id);
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      console.log('❌ Нет access token');
      return NextResponse.json({ message: 'Не авторизован' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      console.log('❌ Невалидный токен');
      return NextResponse.json({ message: 'Недействительный токен' }, { status: 401 });
    }

    console.log('👤 ID пользователя:', decoded.userId);

    const vacation = await prisma.vacation.findFirst({
      where: {
        id: id,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      },
      include: {
        user: {
          select: { id: true, name: true, email: true, avatar: true }
        },
        members: {
          where: { status: 'accepted' },
          include: {
            user: {
              select: { id: true, name: true, email: true, avatar: true }
            }
          }
        },
        activities: {
          orderBy: { date: 'asc' },
          take: 10,
          include: {
            // ИСПРАВЛЕНО: правильные поля для модели Activity
            location: {
              select: { id: true, name: true, address: true }
            },
            participants: {
              include: {
                user: {
                  select: { id: true, name: true, avatar: true }
                }
              }
            }
          }
        },
        memories: {
          orderBy: { createdAt: 'desc' },
          take: 12,
          include: {
            author: {
              select: { id: true, name: true, avatar: true }
            }
          }
        },
        _count: {
          select: {
            activities: true,
            memories: true,
            members: true,
            locations: true
          }
        }
      }
    });

    if (!vacation) {
      console.log('❌ Отпуск не найден или нет доступа');
      return NextResponse.json({ message: 'Отпуск не найден' }, { status: 404 });
    }

    // Форматируем активности для удобства
    const formattedVacation = {
      ...vacation,
      activities: vacation.activities.map(activity => ({
        ...activity,
        // Берем первого участника как "автора" активности
        author: activity.participants[0]?.user || null,
        participants: activity.participants.map(p => p.user)
      }))
    };

    console.log('✅ Отпуск найден:', formattedVacation.title);
    return NextResponse.json(formattedVacation);

  } catch (error) {
    console.error('❌ Ошибка получения отпуска:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}



================================================================================
ФАЙЛ: vacations/route.js
ПОЛНЫЙ ПУТЬ: src/app/api/vacations/route.js
РАЗМЕР: 4163 символов
================================================================================

// src/app/api/vacations/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

// Получить все отпуски пользователя
export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json(
        { message: 'Не авторизован' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: 'Недействительный токен' },
        { status: 401 }
      );
    }

    // Получаем отпуски где пользователь является участником
    const vacations = await prisma.vacation.findMany({
      where: {
        OR: [
          { userId: decoded.userId }, // Владелец
          { members: { some: { userId: decoded.userId, status: 'accepted' } } } // Участник
        ]
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        members: {
          where: {
            status: 'accepted'
          },
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                avatar: true
              }
            }
          }
        },
        activities: {
          orderBy: { date: 'asc' }
        },
        memories: true,
        locations: true,
        _count: {
          select: {
            activities: true,
            memories: true,
            members: true,
            locations: true
          }
        }
      },
      orderBy: { startDate: 'asc' }
    });

    return NextResponse.json(vacations);

  } catch (error) {
    console.error('Ошибка получения отпусков:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}

// Создать новый отпуск
export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json(
        { message: 'Не авторизован' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: 'Недействительный токен' },
        { status: 401 }
      );
    }

    const { title, description, destination, startDate, endDate } = await request.json();

    if (!title || !startDate || !endDate) {
      return NextResponse.json(
        { message: 'Название и даты обязательны' },
        { status: 400 }
      );
    }

    // Создаем отпуск
    const vacation = await prisma.vacation.create({
      data: {
        title,
        description,
        destination,
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        userId: decoded.userId,
        // Автоматически добавляем владельца как участника
        members: {
          create: {
            userId: decoded.userId,
            role: 'owner',
            status: 'accepted'
          }
        }
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        members: {
          where: {
            status: 'accepted'
          },
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                avatar: true
              }
            }
          }
        },
        activities: true,
        memories: true,
        locations: true,
        _count: {
          select: {
            activities: true,
            memories: true,
            members: true,
            locations: true
          }
        }
      }
    });

    return NextResponse.json(vacation, { status: 201 });

  } catch (error) {
    console.error('Ошибка создания отпуска:', error);
    return NextResponse.json(
      { message: 'Внутренняя ошибка сервера' },
      { status: 500 }
    );
  }
}


