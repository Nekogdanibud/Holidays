–û–¢–ß–ï–¢ –û –§–ê–ô–õ–ê–•
–ü–∞–ø–∫–∞: /OTPUSK/otpusk-app/Holidays/src/app/api
–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è: 10/18/2025, 1:57:23 AM
–í—Å–µ–≥–æ —Ñ–∞–π–ª–æ–≤: 28
–ò—Å–∫–ª—é—á–µ–Ω–Ω—ã–µ –ø–∞–ø–∫–∏: api, node_modules, dist, build, .git, .next, cache, temp
–ò—Å–∫–ª—é—á–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã: global.css, favicon.ico
================================================================================


================================================================================
–§–ê–ô–õ: activities/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/activities/route.js
–†–ê–ó–ú–ï–†: 2924 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/activities/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { title, description, date, type, vacationId, locationId } = await request.json();

    if (!title || !date || !type || !vacationId) {
      return NextResponse.json(
        { message: '–û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è: –Ω–∞–∑–≤–∞–Ω–∏–µ, –¥–∞—Ç–∞, —Ç–∏–ø –∏ ID –æ—Ç–ø—É—Å–∫–∞' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ –æ—Ç–ø—É—Å–∫—É
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: vacationId,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    // –°–æ–∑–¥–∞–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
    const activity = await prisma.activity.create({
      data: {
        title,
        description,
        date: new Date(date),
        type,
        vacationId,
        locationId: locationId || null
      },
      include: {
        location: {
          select: { id: true, name: true, address: true }
        },
        participants: {
          include: {
            user: {
              select: { id: true, name: true, avatar: true }
            }
          }
        }
      }
    });

    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ–º —Å–æ–∑–¥–∞—Ç–µ–ª—è –∫–∞–∫ —É—á–∞—Å—Ç–Ω–∏–∫–∞
    await prisma.activityParticipant.create({
      data: {
        activityId: activity.id,
        userId: decoded.userId,
        status: 'going'
      }
    });

    // –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Å —É—á–∞—Å—Ç–Ω–∏–∫–∞–º–∏
    const updatedActivity = await prisma.activity.findUnique({
      where: { id: activity.id },
      include: {
        location: {
          select: { id: true, name: true, address: true }
        },
        participants: {
          include: {
            user: {
              select: { id: true, name: true, avatar: true }
            }
          }
        }
      }
    });

    // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–ª—è –æ—Ç–≤–µ—Ç–∞
    const formattedActivity = {
      ...updatedActivity,
      author: updatedActivity.participants[0]?.user || null,
      participants: updatedActivity.participants.map(p => p.user)
    };

    return NextResponse.json(formattedActivity, { status: 201 });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/login/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/login/route.js
–†–ê–ó–ú–ï–†: 2408 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/login/route.js
import { NextResponse } from 'next/server';
import { verifyPassword, createSession } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const { email, password, rememberMe = false } = await request.json();

    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    if (!email || !password) {
      return NextResponse.json(
        { message: 'Email –∏ –ø–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' },
        { status: 400 }
      );
    }

    // –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = await prisma.user.findUnique({
      where: { email }
    });

    if (!user) {
      return NextResponse.json(
        { message: '–ù–µ–≤–µ—Ä–Ω—ã–π email –∏–ª–∏ –ø–∞—Ä–æ–ª—å' },
        { status: 401 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ä–æ–ª—è
    const isPasswordValid = await verifyPassword(password, user.password);
    if (!isPasswordValid) {
      return NextResponse.json(
        { message: '–ù–µ–≤–µ—Ä–Ω—ã–π email –∏–ª–∏ –ø–∞—Ä–æ–ª—å' },
        { status: 401 }
      );
    }

    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–ª–∏–µ–Ω—Ç–µ
    const userAgent = request.headers.get('user-agent');
    const ipAddress = request.headers.get('x-forwarded-for') || request.ip;

    // –°–æ–∑–¥–∞–µ–º —Å–µ—Å—Å–∏—é —Å —É—á–µ—Ç–æ–º rememberMe
    const { accessToken, refreshToken, sessionId } = await createSession(
      user.id, 
      userAgent, 
      ipAddress,
      rememberMe
    );

    const userData = {
      id: user.id,
      name: user.name,
      email: user.email,
      createdAt: user.createdAt
    };

    const response = NextResponse.json(
      { 
        message: '–í—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ',
        user: userData
      },
      { status: 200 }
    );

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º httpOnly –∫—É–∫–∏ —Å —Ä–∞–∑–Ω—ã–º –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏
    response.cookies.set('accessToken', accessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 1000 // 1 —á–∞—Å
    });

    response.cookies.set('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: rememberMe 
        ? 365 * 24 * 60 * 60 * 1000 // 1 –≥–æ–¥ –¥–ª—è "–ó–∞–ø–æ–º–Ω–∏—Ç—å –º–µ–Ω—è"
        : 30 * 24 * 60 * 60 * 1000 // 30 –¥–Ω–µ–π –¥–ª—è –æ–±—ã—á–Ω–æ–π —Å–µ—Å—Å–∏–∏
    });

    return response;

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/logout/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/logout/route.js
–†–ê–ó–ú–ï–†: 1175 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/logout/route.js
import { NextResponse } from 'next/server';
import { deleteSession } from '../../../../lib/auth';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (accessToken) {
      const { verifyAccessToken } = await import('../../../../lib/auth');
      const decoded = verifyAccessToken(accessToken);
      
      if (decoded?.sessionId) {
        await deleteSession(decoded.sessionId);
      }
    }

    const response = NextResponse.json(
      { message: '–í—ã—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ' },
      { status: 200 }
    );

    // –û—á–∏—â–∞–µ–º –∫—É–∫–∏
    response.cookies.set('accessToken', '', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 0
    });

    response.cookies.set('refreshToken', '', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 0
    });

    return response;

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –≤—ã—Ö–æ–¥–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/me/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/me/route.js
–†–ê–ó–ú–ï–†: 1665 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/me/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function GET(request) {
  try {
    console.log('üîç Checking auth...');
    
    const accessToken = request.cookies.get('accessToken')?.value;
    console.log('Access token exists:', !!accessToken);

    if (!accessToken) {
      console.log('‚ùå No access token');
      return NextResponse.json(
        { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    console.log('Decoded token:', decoded);

    if (!decoded) {
      console.log('‚ùå Invalid token');
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' },
        { status: 401 }
      );
    }

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã —Å usertag
    console.log('üë§ Fetching user:', decoded.userId);
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: {
        id: true,
        name: true,
        usertag: true, // –î–û–ë–ê–í–õ–ï–ù–û
        email: true,
        avatar: true,
        createdAt: true
      }
    });

    console.log('User found:', !!user);
    console.log('User usertag:', user?.usertag);

    if (!user) {
      return NextResponse.json(
        { message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' },
        { status: 404 }
      );
    }

    return NextResponse.json(user);

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/refresh/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/refresh/route.js
–†–ê–ó–ú–ï–†: 1271 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/refresh/route.js
import { NextResponse } from 'next/server';
import { verifySession, generateAccessToken } from '../../../../lib/auth';

export async function POST(request) {
  try {
    const refreshToken = request.cookies.get('refreshToken')?.value;

    if (!refreshToken) {
      return NextResponse.json(
        { message: 'Refresh token –Ω–µ –Ω–∞–π–¥–µ–Ω' },
        { status: 401 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–µ—Å—Å–∏—é
    const session = await verifySession(refreshToken);
    if (!session) {
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞—è —Å–µ—Å—Å–∏—è' },
        { status: 401 }
      );
    }

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π access token
    const newAccessToken = generateAccessToken(session.userId, session.id);

    const response = NextResponse.json(
      { message: 'Token –æ–±–Ω–æ–≤–ª–µ–Ω' },
      { status: 200 }
    );

    response.cookies.set('accessToken', newAccessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 1000 // 1 —á–∞—Å
    });

    return response;

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/register/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/register/route.js
–†–ê–ó–ú–ï–†: 3926 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/register/route.js (–æ–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
import { NextResponse } from 'next/server';
import { hashPassword, createSession } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const { name, usertag, email, password, rememberMe = false } = await request.json();

    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    if (!name || !usertag || !email || !password) {
      return NextResponse.json(
        { message: '–í—Å–µ –ø–æ–ª—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è' },
        { status: 400 }
      );
    }

    if (password.length < 6) {
      return NextResponse.json(
        { message: '–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 6 —Å–∏–º–≤–æ–ª–æ–≤' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ usertag
    if (!/^[a-z0-9-]+$/.test(usertag)) {
      return NextResponse.json(
        { message: 'Usertag –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ –ª–∞—Ç–∏–Ω—Å–∫–∏–µ –±—É–∫–≤—ã –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ, —Ü–∏—Ñ—Ä—ã –∏ –¥–µ—Ñ–∏—Å—ã' },
        { status: 400 }
      );
    }

    if (usertag.length < 3 || usertag.length > 20) {
      return NextResponse.json(
        { message: 'Usertag –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 3 –¥–æ 20 —Å–∏–º–≤–æ–ª–æ–≤' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ email –∏ usertag
    const existingUser = await prisma.user.findFirst({
      where: {
        OR: [
          { email },
          { usertag }
        ]
      }
    });

    if (existingUser) {
      if (existingUser.email === email) {
        return NextResponse.json(
          { message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç' },
          { status: 409 }
        );
      }
      if (existingUser.usertag === usertag) {
        return NextResponse.json(
          { message: '–≠—Ç–æ—Ç usertag —É–∂–µ –∑–∞–Ω—è—Ç' },
          { status: 409 }
        );
      }
    }

    // –•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–æ–ª—è
    const hashedPassword = await hashPassword(password);

    // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const newUser = await prisma.user.create({
      data: {
        name,
        usertag,
        email,
        password: hashedPassword,
      },
      select: {
        id: true,
        name: true,
        usertag: true,
        email: true,
        createdAt: true
      }
    });

    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–ª–∏–µ–Ω—Ç–µ
    const userAgent = request.headers.get('user-agent');
    const ipAddress = request.headers.get('x-forwarded-for') || request.ip;

    // –°–æ–∑–¥–∞–µ–º —Å–µ—Å—Å–∏—é —Å —É—á–µ—Ç–æ–º rememberMe
    const { accessToken, refreshToken, sessionId } = await createSession(
      newUser.id, 
      userAgent, 
      ipAddress,
      rememberMe
    );

    const response = NextResponse.json(
      { 
        message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω',
        user: newUser
      },
      { status: 201 }
    );

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º httpOnly –∫—É–∫–∏ —Å —Ä–∞–∑–Ω—ã–º –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏
    response.cookies.set('accessToken', accessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 1000 // 1 —á–∞—Å
    });

    response.cookies.set('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: rememberMe 
        ? 365 * 24 * 60 * 60 * 1000 // 1 –≥–æ–¥ –¥–ª—è "–ó–∞–ø–æ–º–Ω–∏—Ç—å –º–µ–Ω—è"
        : 30 * 24 * 60 * 60 * 1000 // 30 –¥–Ω–µ–π –¥–ª—è –æ–±—ã—á–Ω–æ–π —Å–µ—Å—Å–∏–∏
    });

    return response;

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:', error);
    
    if (error.code === 'P2002') {
      const field = error.meta?.target?.[0];
      if (field === 'email') {
        return NextResponse.json(
          { message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç' },
          { status: 409 }
        );
      }
      if (field === 'usertag') {
        return NextResponse.json(
          { message: '–≠—Ç–æ—Ç usertag —É–∂–µ –∑–∞–Ω—è—Ç' },
          { status: 409 }
        );
      }
    }

    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/sessions/all/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/sessions/all/route.js
–†–ê–ó–ú–ï–†: 1334 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/sessions/all/route.js
import { NextResponse } from 'next/server';
import { deleteAllUserSessions } from '../../../../../lib/auth';
import { verifyAccessToken } from '../../../../../lib/auth';

// –£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Å–µ—Å—Å–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–∫—Ä–æ–º–µ —Ç–µ–∫—É—â–µ–π)
export async function DELETE(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json(
        { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' },
        { status: 401 }
      );
    }

    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Å–µ—Å—Å–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const { getUserSessions, deleteSession } = await import('../../../../../lib/auth');
    const sessions = await getUserSessions(decoded.userId);

    // –£–¥–∞–ª—è–µ–º –≤—Å–µ —Å–µ—Å—Å–∏–∏ –∫—Ä–æ–º–µ —Ç–µ–∫—É—â–µ–π
    for (const session of sessions) {
      if (session.id !== decoded.sessionId) {
        await deleteSession(session.id);
      }
    }

    return NextResponse.json({ message: '–í—Å–µ –¥—Ä—É–≥–∏–µ —Å–µ—Å—Å–∏–∏ —É–¥–∞–ª–µ–Ω—ã' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å–µ—Å—Å–∏–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/sessions/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/sessions/route.js
–†–ê–ó–ú–ï–†: 1817 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/sessions/route.js
import { NextResponse } from 'next/server';
import { getUserSessions, deleteSession, deleteAllUserSessions } from '../../../../lib/auth';
import { verifyAccessToken } from '../../../../lib/auth';

// –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–µ—Å—Å–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json(
        { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' },
        { status: 401 }
      );
    }

    const sessions = await getUserSessions(decoded.userId);

    return NextResponse.json({ sessions });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–µ—Å—Å–∏–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

// –£–¥–∞–ª–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é —Å–µ—Å—Å–∏—é
export async function DELETE(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;
    const { sessionId } = await request.json();

    if (!accessToken) {
      return NextResponse.json(
        { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' },
        { status: 401 }
      );
    }

    await deleteSession(sessionId);

    return NextResponse.json({ message: '–°–µ—Å—Å–∏—è —É–¥–∞–ª–µ–Ω–∞' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å–µ—Å—Å–∏–∏:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: friends/request/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/friends/request/route.js
–†–ê–ó–ú–ï–†: 3203 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/friends/request/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { userId } = await request.json();

    if (!userId) {
      return NextResponse.json({ message: 'User ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' }, { status: 400 });
    }

    // –ù–µ–ª—å–∑—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å —Å–∞–º–æ–º—É —Å–µ–±–µ
    if (userId === decoded.userId) {
      return NextResponse.json(
        { message: '–ù–µ–ª—å–∑—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è —Å–∞–º–æ–º—É —Å–µ–±–µ' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const targetUser = await prisma.user.findUnique({
      where: { id: userId }
    });

    if (!targetUser) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ –ª–∏ —É–∂–µ –∑–∞–ø—Ä–æ—Å
    const existingRequest = await prisma.friendRequest.findFirst({
      where: {
        senderId: decoded.userId,
        receiverId: userId
      }
    });

    if (existingRequest) {
      return NextResponse.json(
        { message: '–ó–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è —É–∂–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω' },
        { status: 409 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è—é—Ç—Å—è –ª–∏ —É–∂–µ –¥—Ä—É–∑—å—è–º–∏
    const existingFriendship = await prisma.friendship.findFirst({
      where: {
        OR: [
          { user1Id: decoded.userId, user2Id: userId },
          { user1Id: userId, user2Id: decoded.userId }
        ]
      }
    });

    if (existingFriendship) {
      return NextResponse.json(
        { message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —É –≤–∞—Å –≤ –¥—Ä—É–∑—å—è—Ö' },
        { status: 409 }
      );
    }

    // –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è
    const friendRequest = await prisma.friendRequest.create({
      data: {
        senderId: decoded.userId,
        receiverId: userId,
        status: 'PENDING'
      },
      include: {
        sender: {
          select: {
            id: true,
            name: true,
            avatar: true,
            usertag: true
          }
        }
      }
    });

    // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª—É—á–∞—Ç–µ–ª—è
    await prisma.notification.create({
      data: {
        userId: userId,
        type: 'friend_request',
        title: '–ù–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è',
        message: `${friendRequest.sender.name} —Ö–æ—á–µ—Ç –¥–æ–±–∞–≤–∏—Ç—å –≤–∞—Å –≤ –¥—Ä—É–∑—å—è`,
        data: {
          requestId: friendRequest.id,
          senderId: decoded.userId,
          senderName: friendRequest.sender.name,
          senderAvatar: friendRequest.sender.avatar
        }
      }
    });

    return NextResponse.json({
      message: '–ó–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω',
      request: friendRequest
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞–ø—Ä–æ—Å–∞ –≤ –¥—Ä—É–∑—å—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: friends/respond/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/friends/respond/route.js
–†–ê–ó–ú–ï–†: 3626 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { requestId, accept } = await request.json();

    console.log('üì® –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –¥—Ä—É–∂–±—ã:', { requestId, accept, userId: decoded.userId });

    if (!requestId) {
      return NextResponse.json({ message: 'Request ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' }, { status: 400 });
    }

    // –ù–∞—Ö–æ–¥–∏–º –∑–∞–ø—Ä–æ—Å
    const friendRequest = await prisma.friendRequest.findFirst({
      where: {
        id: requestId,
        receiverId: decoded.userId,
        status: 'PENDING'
      },
      include: {
        sender: {
          select: {
            id: true,
            name: true,
            avatar: true,
            usertag: true
          }
        },
        receiver: {
          select: {
            id: true,
            name: true,
            avatar: true,
            usertag: true
          }
        }
      }
    });

    console.log('üîç –ù–∞–π–¥–µ–Ω –∑–∞–ø—Ä–æ—Å –¥—Ä—É–∂–±—ã:', friendRequest);

    if (!friendRequest) {
      return NextResponse.json({ message: '–ó–∞–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    if (accept) {
      // –ü—Ä–∏–Ω–∏–º–∞–µ–º –∑–∞–ø—Ä–æ—Å - —Å–æ–∑–¥–∞–µ–º –¥—Ä—É–∂–±—É
      const result = await prisma.$transaction(async (tx) => {
        // –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –æ –¥—Ä—É–∂–±–µ (—É–±–µ–¥–∏–º—Å—è, —á—Ç–æ user1Id –≤—Å–µ–≥–¥–∞ –º–µ–Ω—å—à–µ user2Id –¥–ª—è —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏)
        const user1Id = friendRequest.senderId < decoded.userId ? friendRequest.senderId : decoded.userId;
        const user2Id = friendRequest.senderId < decoded.userId ? decoded.userId : friendRequest.senderId;

        console.log('üë• –°–æ–∑–¥–∞–µ–º –¥—Ä—É–∂–±—É –º–µ–∂–¥—É:', { user1Id, user2Id });

        const friendship = await tx.friendship.create({
          data: {
            user1Id,
            user2Id
          }
        });

        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–ø—Ä–æ—Å–∞
        await tx.friendRequest.update({
          where: { id: requestId },
          data: { status: 'ACCEPTED' }
        });

        // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è
        await tx.notification.create({
          data: {
            userId: friendRequest.senderId,
            type: 'friend_request_accepted',
            title: '–ó–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è –ø—Ä–∏–Ω—è—Ç',
            message: `${friendRequest.receiver.name} –ø—Ä–∏–Ω—è–ª(–∞) –≤–∞—à –∑–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è`,
            data: {
              friendId: decoded.userId,
              friendName: friendRequest.receiver.name,
              friendAvatar: friendRequest.receiver.avatar,
              friendUsertag: friendRequest.receiver.usertag
            }
          }
        });

        return friendship;
      });

      console.log('‚úÖ –ó–∞–ø—Ä–æ—Å –¥—Ä—É–∂–±—ã –ø—Ä–∏–Ω—è—Ç:', result);

      return NextResponse.json({ 
        message: '–ó–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è –ø—Ä–∏–Ω—è—Ç',
        friendship: result
      });

    } else {
      // –û—Ç–∫–ª–æ–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å
      await prisma.friendRequest.update({
        where: { id: requestId },
        data: { status: 'REJECTED' }
      });

      console.log('‚ùå –ó–∞–ø—Ä–æ—Å –¥—Ä—É–∂–±—ã –æ—Ç–∫–ª–æ–Ω–µ–Ω');

      return NextResponse.json({ message: '–ó–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è –æ—Ç–∫–ª–æ–Ω–µ–Ω' });
    }

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–∞ –≤ –¥—Ä—É–∑—å—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: friends/status/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/friends/status/route.js
–†–ê–ó–ú–ï–†: 2043 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/friends/status/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const targetUserId = searchParams.get('targetUserId');
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    if (!targetUserId) {
      return NextResponse.json({ message: 'Target User ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' }, { status: 400 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥—Ä—É–∂–±—É
    const friendship = await prisma.friendship.findFirst({
      where: {
        OR: [
          { user1Id: decoded.userId, user2Id: targetUserId },
          { user1Id: targetUserId, user2Id: decoded.userId }
        ]
      }
    });

    if (friendship) {
      return NextResponse.json({ status: 'friends' });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏—Å—Ö–æ–¥—è—â–∏–π –∑–∞–ø—Ä–æ—Å
    const outgoingRequest = await prisma.friendRequest.findFirst({
      where: {
        senderId: decoded.userId,
        receiverId: targetUserId,
        status: 'PENDING'
      }
    });

    if (outgoingRequest) {
      return NextResponse.json({ status: 'pending' });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Ö–æ–¥—è—â–∏–π –∑–∞–ø—Ä–æ—Å
    const incomingRequest = await prisma.friendRequest.findFirst({
      where: {
        senderId: targetUserId,
        receiverId: decoded.userId,
        status: 'PENDING'
      }
    });

    if (incomingRequest) {
      return NextResponse.json({ status: 'incoming' });
    }

    return NextResponse.json({ status: 'none' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ –¥—Ä—É–∂–±—ã:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: invitations/[id]/respond/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/invitations/[id]/respond/route.js
–†–ê–ó–ú–ï–†: 4777 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/invitations/[id]/respond/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function POST(request, { params }) {
  try {
    const { id: invitationId } = await params;
    const { accept } = await request.json();
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –∏–∑ –±–∞–∑—ã
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: { id: true, name: true, email: true }
    });

    if (!user) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    // –ù–∞—Ö–æ–¥–∏–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
    const invitation = await prisma.invitation.findFirst({
      where: {
        id: invitationId,
        email: user.email // –ò—Å–ø–æ–ª—å–∑—É–µ–º email –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
      },
      include: {
        vacation: true,
        invitedBy: {
          select: { name: true }
        }
      }
    });

    if (!invitation) {
      return NextResponse.json({ message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' }, { status: 404 });
    }

    if (invitation.status !== 'pending') {
      return NextResponse.json({ message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ' }, { status: 400 });
    }

    if (new Date() > invitation.expiresAt) {
      return NextResponse.json({ message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –∏—Å—Ç–µ–∫–ª–æ' }, { status: 400 });
    }

    if (accept) {
      // –ü—Ä–∏–Ω–∏–º–∞–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
      await prisma.$transaction(async (tx) => {
        // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∫–∞–∫ —É—á–∞—Å—Ç–Ω–∏–∫–∞
        await tx.vacationMember.create({
          data: {
            vacationId: invitation.vacationId,
            userId: user.id,
            role: 'member',
            status: 'accepted',
            joinedAt: new Date()
          }
        });

        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è
        await tx.invitation.update({
          where: { id: invitationId },
          data: { status: 'accepted' }
        });

        // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –≤–ª–∞–¥–µ–ª—å—Ü–∞
        await tx.notification.create({
          data: {
            userId: invitation.invitedById,
            type: 'info',
            title: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –ø—Ä–∏–Ω—è—Ç–æ',
            message: `${user.name} –ø—Ä–∏–Ω—è–ª(–∞) –≤–∞—à–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –æ—Ç–ø—É—Å–∫ "${invitation.vacation.title}"`,
            data: {
              vacationId: invitation.vacationId,
              acceptedByName: user.name
            }
          }
        });

        // –û–±–Ω–æ–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await tx.notification.updateMany({
          where: {
            userId: user.id,
            type: 'invitation',
            data: {
              path: ['invitationId'],
              equals: invitationId
            }
          },
          data: {
            data: {
              ...invitation.data,
              status: 'accepted'
            }
          }
        });
      });

      return NextResponse.json({ 
        message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –ø—Ä–∏–Ω—è—Ç–æ',
        vacationId: invitation.vacationId
      });
    } else {
      // –û—Ç–∫–ª–æ–Ω—è–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
      await prisma.$transaction(async (tx) => {
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è
        await tx.invitation.update({
          where: { id: invitationId },
          data: { status: 'rejected' }
        });

        // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –≤–ª–∞–¥–µ–ª—å—Ü–∞
        await tx.notification.create({
          data: {
            userId: invitation.invitedById,
            type: 'info',
            title: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ',
            message: `${user.name} –æ—Ç–∫–ª–æ–Ω–∏–ª(–∞) –≤–∞—à–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –æ—Ç–ø—É—Å–∫ "${invitation.vacation.title}"`,
            data: {
              vacationId: invitation.vacationId,
              rejectedByName: user.name
            }
          }
        });

        // –û–±–Ω–æ–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await tx.notification.updateMany({
          where: {
            userId: user.id,
            type: 'invitation',
            data: {
              path: ['invitationId'],
              equals: invitationId
            }
          },
          data: {
            data: {
              ...invitation.data,
              status: 'rejected'
            }
          }
        });
      });

      return NextResponse.json({ message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ' });
    }

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: memories/capture/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/memories/capture/route.js
–†–ê–ó–ú–ï–†: 3546 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/memories/capture/route.js
import { NextResponse } from 'next/server';
import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const formData = await request.formData();
    const vacationId = formData.get('vacationId');
    const photos = formData.getAll('photos');

    if (!vacationId || photos.length === 0) {
      return NextResponse.json(
        { message: '–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ –æ—Ç–ø—É—Å–∫—É
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: vacationId,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π –Ω–∞ –¥–µ–Ω—å (3 —Ñ–æ—Ç–æ)
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const todayMemories = await prisma.memory.count({
      where: {
        vacationId,
        authorId: decoded.userId,
        createdAt: {
          gte: today,
          lt: tomorrow
        }
      }
    });

    if (todayMemories + photos.length > 3) {
      return NextResponse.json(
        { message: '–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –≤ 3 —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –≤ –¥–µ–Ω—å' },
        { status: 400 }
      );
    }

    const createdMemories = [];

    // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –∑–∞–≥—Ä—É–∑–æ–∫ –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç
    const uploadDir = join(process.cwd(), 'public', 'uploads', 'memories');
    try {
      await mkdir(uploadDir, { recursive: true });
    } catch (error) {
      // –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    }

    for (const photo of photos) {
      const bytes = await photo.arrayBuffer();
      const buffer = Buffer.from(bytes);
      
      // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞
      const timestamp = Date.now();
      const filename = `${timestamp}-${photo.name}`;
      const filepath = join(uploadDir, filename);

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª
      await writeFile(filepath, buffer);

      // –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –≤ –±–∞–∑–µ
      const memory = await prisma.memory.create({
        data: {
          title: `–§–æ—Ç–æ –¥–Ω—è - ${new Date().toLocaleDateString('ru-RU')}`,
          description: '–ó–∞–ø–µ—á–∞—Ç–ª–µ–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç',
          imageUrl: `/uploads/memories/${filename}`,
          takenAt: new Date(),
          vacationId,
          authorId: decoded.userId,
          tags: ['captured_moment']
        },
        include: {
          author: {
            select: { id: true, name: true, avatar: true }
          }
        }
      });

      createdMemories.push(memory);
    }

    return NextResponse.json({ 
      message: '–§–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã',
      memories: createdMemories 
    }, { status: 201 });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: notifications/invite/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/notifications/invite/route.js
–†–ê–ó–ú–ï–†: 1259 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/notifications/invite/route.js
import { NextResponse } from 'next/server';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const { userId, vacationId, invitedByName, vacationTitle } = await request.json();

    if (!userId || !vacationId || !invitedByName) {
      return NextResponse.json(
        { message: '–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ' },
        { status: 400 }
      );
    }

    // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–∏
    const notification = await prisma.notification.create({
      data: {
        userId,
        type: 'invitation',
        title: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –æ—Ç–ø—É—Å–∫',
        message: `${invitedByName} –ø—Ä–∏–≥–ª–∞—Å–∏–ª(–∞) –≤–∞—Å –≤ –æ—Ç–ø—É—Å–∫ "${vacationTitle}"`,
        data: {
          vacationId,
          invitedByName,
          vacationTitle
        }
      },
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            avatar: true 
          }
        }
      }
    });

    return NextResponse.json(notification, { status: 201 });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: notifications/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/notifications/route.js
–†–ê–ó–ú–ï–†: 2505 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/notifications/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

// –ü–æ–ª—É—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const notifications = await prisma.notification.findMany({
      where: { 
        userId: decoded.userId 
      },
      orderBy: { 
        createdAt: 'desc' 
      },
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            avatar: true 
          }
        }
      },
      take: 50
    });

    return NextResponse.json(notifications);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

// –ü–æ–º–µ—Ç–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ
export async function PUT(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { notificationIds } = await request.json();

    if (notificationIds && notificationIds.length > 0) {
      // –ü–æ–º–µ—Ç–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ
      await prisma.notification.updateMany({
        where: { 
          id: { in: notificationIds },
          userId: decoded.userId 
        },
        data: { isRead: true }
      });
    } else {
      // –ü–æ–º–µ—Ç–∏—Ç—å –≤—Å–µ –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ
      await prisma.notification.updateMany({
        where: { 
          userId: decoded.userId,
          isRead: false 
        },
        data: { isRead: true }
      });
    }

    return NextResponse.json({ message: '–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–º–µ—á–µ–Ω—ã –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: notifications/test/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/notifications/test/route.js
–†–ê–ó–ú–ï–†: 2783 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/notifications/test/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { type = 'info' } = await request.json();

    // –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
    let notificationData;

    switch (type) {
      case 'invitation':
        notificationData = {
          userId: decoded.userId,
          type: 'invitation',
          title: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –æ—Ç–ø—É—Å–∫',
          message: '–ê–Ω–Ω–∞ –ø—Ä–∏–≥–ª–∞—Å–∏–ª–∞ –≤–∞—Å –≤ –æ—Ç–ø—É—Å–∫ "–û—Ç–¥—ã—Ö –Ω–∞ –ë–∞–ª–∏"',
          data: {
            invitationId: 'test-invitation-123',
            vacationId: 'test-vacation-456',
            invitedByName: '–ê–Ω–Ω–∞',
            vacationTitle: '–û—Ç–¥—ã—Ö –Ω–∞ –ë–∞–ª–∏'
          }
        };
        break;

      case 'activity_update':
        notificationData = {
          userId: decoded.userId,
          type: 'activity_update',
          title: '–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–ª–∞–Ω–æ–≤',
          message: '–í –≤–∞—à–µ–º –æ—Ç–ø—É—Å–∫–µ "–ì–æ—Ä–Ω—ã–µ –ø–æ—Ö–æ–¥—ã" –¥–æ–±–∞–≤–ª–µ–Ω–∞ –Ω–æ–≤–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å',
          data: {
            vacationId: 'test-vacation-789',
            activityId: 'test-activity-123'
          }
        };
        break;

      case 'memory_comment':
        notificationData = {
          userId: decoded.userId,
          type: 'memory_comment',
          title: '–ù–æ–≤—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π',
          message: '–ò–≤–∞–Ω –ø—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–ª –≤–∞—à–µ –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏–µ',
          data: {
            memoryId: 'test-memory-123',
            commentId: 'test-comment-456'
          }
        };
        break;

      default:
        notificationData = {
          userId: decoded.userId,
          type: 'info',
          title: '–¢–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ',
          message: '–≠—Ç–æ —Ç–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–∏—Å—Ç–µ–º—ã',
          data: {
            test: true
          }
        };
    }

    const notification = await prisma.notification.create({
      data: notificationData,
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            avatar: true 
          }
        }
      }
    });

    return NextResponse.json({
      message: '–¢–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ',
      notification
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: profile/posts/[id]/like/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/profile/posts/[id]/like/route.js
–†–ê–ó–ú–ï–†: 1929 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function POST(request, { params }) {
  try {
    const { id: postId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ—Å—Ç–∞
    const post = await prisma.post.findUnique({
      where: { id: postId },
      include: {
        likes: {
          where: { userId: decoded.userId }
        }
      }
    });

    if (!post) {
      return NextResponse.json({ message: '–ó–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞' }, { status: 404 });
    }

    const isLiked = post.likes.length > 0;

    if (isLiked) {
      // –£–¥–∞–ª—è–µ–º –ª–∞–π–∫
      await prisma.postLike.deleteMany({
        where: {
          postId: postId,
          userId: decoded.userId
        }
      });
    } else {
      // –î–æ–±–∞–≤–ª—è–µ–º –ª–∞–π–∫
      await prisma.postLike.create({
        data: {
          postId: postId,
          userId: decoded.userId
        }
      });
    }

    // –ü–æ–ª—É—á–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–∞–π–∫–æ–≤
    const updatedPost = await prisma.post.findUnique({
      where: { id: postId },
      include: {
        likes: {
          select: { userId: true }
        },
        _count: {
          select: {
            likes: true,
            comments: true
          }
        }
      }
    });

    return NextResponse.json({
      liked: !isLiked,
      likesCount: updatedPost._count.likes
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ª–∞–π–∫–∞ –∑–∞–ø–∏—Å–∏:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: profile/posts/[id]/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/profile/posts/[id]/route.js
–†–ê–ó–ú–ï–†: 2003 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/profile/posts/[id]/like/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

export async function POST(request, { params }) {
  try {
    const { id: postId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ—Å—Ç
    const post = await prisma.post.findUnique({
      where: { id: postId },
      include: {
        likes: {
          where: { userId: decoded.userId }
        }
      }
    });

    if (!post) {
      return NextResponse.json({ message: '–ó–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞' }, { status: 404 });
    }

    const isLiked = post.likes.length > 0;

    if (isLiked) {
      // –£–¥–∞–ª—è–µ–º –ª–∞–π–∫
      await prisma.postLike.deleteMany({
        where: {
          postId: postId,
          userId: decoded.userId
        }
      });
    } else {
      // –î–æ–±–∞–≤–ª—è–µ–º –ª–∞–π–∫
      await prisma.postLike.create({
        data: {
          postId: postId,
          userId: decoded.userId
        }
      });
    }

    // –ü–æ–ª—É—á–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–∞–π–∫–æ–≤
    const updatedPost = await prisma.post.findUnique({
      where: { id: postId },
      include: {
        likes: {
          select: { userId: true }
        },
        _count: {
          select: {
            likes: true,
            comments: true
          }
        }
      }
    });

    return NextResponse.json({
      liked: !isLiked,
      likesCount: updatedPost._count.likes
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ª–∞–π–∫–∞ –∑–∞–ø–∏—Å–∏:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: profile/posts/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/profile/posts/route.js
–†–ê–ó–ú–ï–†: 4666 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/profile/posts/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const userId = searchParams.get('userId');
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    if (!userId) {
      return NextResponse.json({ message: 'User ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' }, { status: 400 });
    }

    // –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏
    const profileUser = await prisma.user.findUnique({
      where: { id: userId },
      select: { 
        id: true,
        profileVisibility: true 
      }
    });

    if (!profileUser) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    const currentUserId = decoded.userId;
    const isOwnProfile = currentUserId === userId;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∏–¥–∏–º–æ—Å—Ç—å –ø–æ—Å—Ç–æ–≤
    let canViewPosts = false;
    
    if (isOwnProfile) {
      canViewPosts = true;
    } else {
      switch (profileUser.profileVisibility) {
        case 'PUBLIC':
          canViewPosts = true;
          break;
        case 'FRIENDS_ONLY':
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥—Ä—É–∂–±—É
          const friendship = await prisma.friendship.findFirst({
            where: {
              OR: [
                { user1Id: currentUserId, user2Id: userId },
                { user1Id: userId, user2Id: currentUserId }
              ]
            }
          });
          canViewPosts = !!friendship;
          break;
        case 'PRIVATE':
          canViewPosts = false;
          break;
      }
    }

    if (!canViewPosts) {
      return NextResponse.json([], { status: 200 });
    }

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å—Ç—ã
    const posts = await prisma.post.findMany({
      where: { authorId: userId },
      include: {
        author: {
          select: {
            id: true,
            name: true,
            avatar: true,
            usertag: true
          }
        },
        likes: {
          select: {
            userId: true
          }
        },
        comments: {
          include: {
            author: {
              select: {
                id: true,
                name: true,
                avatar: true
              }
            }
          },
          orderBy: {
            createdAt: 'asc'
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    return NextResponse.json(posts);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ—Å—Ç–æ–≤:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { content } = await request.json();

    if (!content || content.trim().length === 0) {
      return NextResponse.json(
        { message: '–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ' },
        { status: 400 }
      );
    }

    if (content.length > 500) {
      return NextResponse.json(
        { message: '–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –Ω–µ –¥–æ–ª–∂–Ω–æ –ø—Ä–µ–≤—ã—à–∞—Ç—å 500 —Å–∏–º–≤–æ–ª–æ–≤' },
        { status: 400 }
      );
    }

    // –°–æ–∑–¥–∞–µ–º –ø–æ—Å—Ç
    const post = await prisma.post.create({
      data: {
        content: content.trim(),
        authorId: decoded.userId
      },
      include: {
        author: {
          select: {
            id: true,
            name: true,
            avatar: true,
            usertag: true
          }
        },
        likes: {
          select: {
            userId: true
          }
        },
        comments: {
          include: {
            author: {
              select: {
                id: true,
                name: true,
                avatar: true
              }
            }
          }
        }
      }
    });

    return NextResponse.json(post, { status: 201 });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ—Å—Ç–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: profile/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/profile/route.js
–†–ê–ó–ú–ï–†: 6736 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/profile/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';
import { getUserGroup, getLevelProgress } from '../../../lib/userLevels';

export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const usertag = searchParams.get('usertag');
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    if (!usertag) {
      return NextResponse.json({ message: 'Usertag –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' }, { status: 400 });
    }

    // –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ usertag
    const user = await prisma.user.findUnique({
      where: { usertag },
      select: {
        id: true,
        name: true,
        usertag: true,
        email: true,
        avatar: true,
        banner: true,
        bio: true,
        location: true,
        website: true,
        experiencePoints: true,
        createdAt: true,
        profileVisibility: true,
      }
    });

    if (!user) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    const isOwnProfile = decoded.userId === user.id;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥—Ä—É–∂–±—É –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –≤–∏–¥–∏–º–æ—Å—Ç–∏ –ø–æ—Å—Ç–æ–≤
    let canViewPosts = false;
    
    if (isOwnProfile) {
      canViewPosts = true;
    } else {
      switch (user.profileVisibility) {
        case 'PUBLIC':
          canViewPosts = true;
          break;
        case 'FRIENDS_ONLY':
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è—é—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –¥—Ä—É–∑—å—è–º–∏
          const friendship = await prisma.friendship.findFirst({
            where: {
              OR: [
                { user1Id: decoded.userId, user2Id: user.id },
                { user1Id: user.id, user2Id: decoded.userId }
              ]
            }
          });
          canViewPosts = !!friendship;
          break;
        case 'PRIVATE':
          canViewPosts = false;
          break;
      }
    }

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞
    let posts = [];
    if (canViewPosts) {
      posts = await prisma.post.findMany({
        where: { authorId: user.id },
        orderBy: { createdAt: 'desc' },
        include: {
          author: {
            select: { id: true, name: true, avatar: true }
          },
          likes: {
            select: { userId: true }
          },
          comments: {
            select: { id: true }
          }
        }
      });
    }

    // –ü–æ–ª—É—á–∞–µ–º –í–°–ï –æ—Ç–ø—É—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —á–µ—Ä–µ–∑ vacation_members
    const vacationMembers = await prisma.vacationMember.findMany({
      where: {
        userId: user.id,
        status: 'accepted'
      },
      include: {
        vacation: {
          include: {
            user: {
              select: { id: true, name: true, avatar: true }
            },
            members: {
              where: { status: 'accepted' },
              include: {
                user: {
                  select: { id: true, name: true, avatar: true }
                }
              }
            },
            _count: {
              select: {
                activities: true,
                memories: true,
                members: true
              }
            }
          }
        }
      },
      orderBy: { vacation: { startDate: 'desc' } }
    });

    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —Ñ–æ—Ä–º–∞—Ç –æ—Ç–ø—É—Å–∫–æ–≤
    const vacations = vacationMembers.map(member => ({
      ...member.vacation,
      userRole: member.role,
      isOwner: member.role === 'owner'
    }));

    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± —É—Ä–æ–≤–Ω–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const userGroup = await getUserGroup(user.id);
    const levelProgress = await getLevelProgress(user.id);

    // –§–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–ª–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å
    const userProfile = {
      ...user,
      posts,
      vacations,
      canViewPosts,
      // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± —É—Ä–æ–≤–Ω–µ
      userGroup,
      levelProgress
    };

    return NextResponse.json(userProfile);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

// API –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è
export async function PUT(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { name, usertag, bio, location, website, profileVisibility } = await request.json();

    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    if (!name || !usertag) {
      return NextResponse.json(
        { message: '–ò–º—è –∏ usertag –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' },
        { status: 400 }
      );
    }

    if (usertag.length < 3 || usertag.length > 20) {
      return NextResponse.json(
        { message: 'Usertag –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 3 –¥–æ 20 —Å–∏–º–≤–æ–ª–æ–≤' },
        { status: 400 }
      );
    }

    if (!/^[a-z0-9-]+$/.test(usertag)) {
      return NextResponse.json(
        { message: 'Usertag –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ –ª–∞—Ç–∏–Ω—Å–∫–∏–µ –±—É–∫–≤—ã –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ, —Ü–∏—Ñ—Ä—ã –∏ –¥–µ—Ñ–∏—Å—ã' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–Ω—è—Ç –ª–∏ usertag –¥—Ä—É–≥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
    const existingUser = await prisma.user.findFirst({
      where: {
        usertag,
        NOT: {
          id: decoded.userId
        }
      }
    });

    if (existingUser) {
      return NextResponse.json(
        { message: '–≠—Ç–æ—Ç usertag —É–∂–µ –∑–∞–Ω—è—Ç' },
        { status: 409 }
      );
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ—Ñ–∏–ª—å
    const updatedUser = await prisma.user.update({
      where: { id: decoded.userId },
      data: {
        name,
        usertag,
        bio,
        location,
        website,
        profileVisibility
      },
      select: {
        id: true,
        name: true,
        usertag: true,
        email: true,
        avatar: true,
        banner: true,
        bio: true,
        location: true,
        website: true,
        profileVisibility: true,
        createdAt: true
      }
    });

    return NextResponse.json(updatedUser);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è:', error);
    
    if (error.code === 'P2002') {
      return NextResponse.json(
        { message: '–≠—Ç–æ—Ç usertag —É–∂–µ –∑–∞–Ω—è—Ç' },
        { status: 409 }
      );
    }

    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: profile/upload/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/profile/upload/route.js
–†–ê–ó–ú–ï–†: 3048 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/profile/upload/route.js
import { NextResponse } from 'next/server';
import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const formData = await request.formData();
    const image = formData.get('image');
    const type = formData.get('type'); // 'avatar' –∏–ª–∏ 'banner'

    if (!image || !type) {
      return NextResponse.json(
        { message: '–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø —Ñ–∞–π–ª–∞
    if (!image.type.startsWith('image/')) {
      return NextResponse.json(
        { message: '–§–∞–π–ª –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ (–º–∞–∫—Å 5MB)
    if (image.size > 5 * 1024 * 1024) {
      return NextResponse.json(
        { message: '–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –Ω–µ –¥–æ–ª–∂–µ–Ω –ø—Ä–µ–≤—ã—à–∞—Ç—å 5MB' },
        { status: 400 }
      );
    }

    // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç
    const uploadsDir = join(process.cwd(), 'public', 'uploads');
    const avatarsDir = join(uploadsDir, 'avatars');
    const bannersDir = join(uploadsDir, 'banners');
    
    await mkdir(avatarsDir, { recursive: true });
    await mkdir(bannersDir, { recursive: true });

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞
    const timestamp = Date.now();
    const fileExtension = image.name.split('.').pop();
    const filename = `${timestamp}.${fileExtension}`;
    
    const uploadDir = type === 'avatar' ? avatarsDir : bannersDir;
    const filepath = join(uploadDir, filename);
    const publicUrl = `/uploads/${type === 'avatar' ? 'avatars' : 'banners'}/${filename}`;

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª
    const bytes = await image.arrayBuffer();
    const buffer = Buffer.from(bytes);
    await writeFile(filepath, buffer);

    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const updateData = type === 'avatar' 
      ? { avatar: publicUrl }
      : { banner: publicUrl };

    const updatedUser = await prisma.user.update({
      where: { id: decoded.userId },
      data: updateData,
      select: {
        id: true,
        name: true,
        email: true,
        avatar: true,
        banner: true,
        bio: true,
        location: true,
        website: true,
        profileVisibility: true,
        createdAt: true
      }
    });

    return NextResponse.json({
      message: '–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ',
      user: updatedUser
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: users/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/users/route.js
–†–ê–ó–ú–ï–†: 2694 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/users/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const search = searchParams.get('search') || '';
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');
    const skip = (page - 1) * limit;

    // –ë–∞–∑–æ–≤—ã–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –ø–æ–∏—Å–∫–∞
    const where = {
      OR: [
        { name: { contains: search, mode: 'insensitive' } },
        { usertag: { contains: search, mode: 'insensitive' } }
      ],
      // –ò—Å–∫–ª—é—á–∞–µ–º —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      NOT: {
        id: decoded.userId
      }
    };

    console.log('üîç –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å —É—Å–ª–æ–≤–∏—è–º–∏:', { search, page, limit });

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –ø–æ–ª—è–º–∏
    const users = await prisma.user.findMany({
      where,
      select: {
        id: true,
        name: true,
        usertag: true,
        avatar: true,
        bio: true,
        location: true,
        createdAt: true,
        profileVisibility: true,
        _count: {
          select: {
            vacationMembers: {
              where: { status: 'accepted' }
            },
            posts: true,
            friendsAsUser1: true,
            friendsAsUser2: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      skip,
      take: limit
    });

    console.log('‚úÖ –ù–∞–π–¥–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:', users.length);

    // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞
    const formattedUsers = users.map(user => ({
      ...user,
      vacationCount: user._count.vacationMembers,
      postCount: user._count.posts,
      friendCount: user._count.friendsAsUser1 + user._count.friendsAsUser2
    }));

    // –ü–æ–ª—É—á–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
    const total = await prisma.user.count({ where });

    return NextResponse.json({
      users: formattedUsers,
      pagination: {
        page,
        limit,
        total,
        hasNext: skip + users.length < total,
        hasPrev: page > 1
      }
    });

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/activities/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/activities/route.js
–†–ê–ó–ú–ï–†: 2063 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/activities/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

export async function GET(request, { params }) {
  try {
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ –æ—Ç–ø—É—Å–∫—É
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: id,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –ø–æ–ª—è –¥–ª—è –º–æ–¥–µ–ª–∏ Activity
    const activities = await prisma.activity.findMany({
      where: { vacationId: id },
      orderBy: { date: 'asc' },
      include: {
        location: {
          select: { id: true, name: true, address: true }
        },
        participants: {
          include: {
            user: {
              select: { id: true, name: true, avatar: true }
            }
          }
        }
      }
    });

    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    const formattedActivities = activities.map(activity => ({
      ...activity,
      // –ë–µ—Ä–µ–º –ø–µ—Ä–≤–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞ –∫–∞–∫ "–∞–≤—Ç–æ—Ä–∞" –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
      author: activity.participants[0]?.user || null,
      participants: activity.participants.map(p => p.user)
    }));

    return NextResponse.json(formattedActivities);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–µ–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/invite/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/invite/route.js
–†–ê–ó–ú–ï–†: 3568 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/invite/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';
import { randomBytes } from 'crypto';

export async function POST(request, { params }) {
  try {
    // Await params –¥–ª—è Next.js 15
    const { id: vacationId } = await params;
    const { email } = await request.json();
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å - –≤–ª–∞–¥–µ–ª–µ—Ü –æ—Ç–ø—É—Å–∫–∞
    const vacation = await prisma.vacation.findFirst({
      where: {
        id: vacationId,
        userId: decoded.userId
      },
      include: {
        user: {
          select: { name: true }
        }
      }
    });

    if (!vacation) {
      return NextResponse.json({ message: '–û—Ç–ø—É—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ—Ç –ø—Ä–∞–≤' }, { status: 404 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email
    const invitedUser = await prisma.user.findUnique({
      where: { email }
    });

    if (!invitedUser) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω –ª–∏ —É–∂–µ —ç—Ç–æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    const existingInvitation = await prisma.invitation.findFirst({
      where: {
        vacationId,
        email
      }
    });

    if (existingInvitation) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω' }, { status: 409 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–º
    const existingMember = await prisma.vacationMember.findFirst({
      where: {
        vacationId,
        userId: invitedUser.id
      }
    });

    if (existingMember) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —è–≤–ª—è–µ—Ç—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–º' }, { status: 409 });
    }

    // –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
    const token = randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 –¥–Ω–µ–π

    const invitation = await prisma.invitation.create({
      data: {
        vacationId,
        email,
        token,
        invitedById: decoded.userId,
        expiresAt
      }
    });

    // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –ø—Ä–∏–≥–ª–∞—à–µ–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const notification = await prisma.notification.create({
      data: {
        userId: invitedUser.id,
        type: 'invitation',
        title: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –æ—Ç–ø—É—Å–∫',
        message: `${vacation.user.name} –ø—Ä–∏–≥–ª–∞—Å–∏–ª(–∞) –≤–∞—Å –≤ –æ—Ç–ø—É—Å–∫ "${vacation.title}"`,
        data: {
          invitationId: invitation.id,
          vacationId: vacation.id,
          invitedByName: vacation.user.name,
          vacationTitle: vacation.title
        }
      },
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            avatar: true 
          }
        }
      }
    });

    return NextResponse.json({ 
      message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ',
      invitation: {
        id: invitation.id,
        email: invitation.email,
        status: invitation.status
      },
      notification
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/members/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/members/route.js
–†–ê–ó–ú–ï–†: 1629 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/members/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

export async function GET(request, { params }) {
  try {
    // Await params –¥–ª—è Next.js 15
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ –æ—Ç–ø—É—Å–∫—É
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: id,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    const members = await prisma.vacationMember.findMany({
      where: { vacationId: id },
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            email: true, 
            avatar: true 
          }
        }
      },
      orderBy: { createdAt: 'asc' }
    });

    return NextResponse.json(members);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/memories/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/memories/route.js
–†–ê–ó–ú–ï–†: 1553 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/memories/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

export async function GET(request, { params }) {
  try {
    // Await params –¥–ª—è Next.js 15
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ –æ—Ç–ø—É—Å–∫—É
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: id,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    const memories = await prisma.memory.findMany({
      where: { vacationId: id },
      orderBy: { createdAt: 'desc' },
      include: {
        author: {
          select: { id: true, name: true, avatar: true }
        }
      }
    });

    return NextResponse.json(memories);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/route.js
–†–ê–ó–ú–ï–†: 3109 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function GET(request, { params }) {
  try {
    const { id } = await params;
    console.log('üîç –ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç–ø—É—Å–∫–∞ —Å ID:', id);
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      console.log('‚ùå –ù–µ—Ç access token');
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      console.log('‚ùå –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π —Ç–æ–∫–µ–Ω');
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    console.log('üë§ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', decoded.userId);

    const vacation = await prisma.vacation.findFirst({
      where: {
        id: id,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      },
      include: {
        user: {
          select: { id: true, name: true, email: true, avatar: true }
        },
        members: {
          where: { status: 'accepted' },
          include: {
            user: {
              select: { id: true, name: true, email: true, avatar: true }
            }
          }
        },
        activities: {
          orderBy: { date: 'asc' },
          take: 10,
          include: {
            // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –ø–æ–ª—è –¥–ª—è –º–æ–¥–µ–ª–∏ Activity
            location: {
              select: { id: true, name: true, address: true }
            },
            participants: {
              include: {
                user: {
                  select: { id: true, name: true, avatar: true }
                }
              }
            }
          }
        },
        memories: {
          orderBy: { createdAt: 'desc' },
          take: 12,
          include: {
            author: {
              select: { id: true, name: true, avatar: true }
            }
          }
        },
        _count: {
          select: {
            activities: true,
            memories: true,
            members: true,
            locations: true
          }
        }
      }
    });

    if (!vacation) {
      console.log('‚ùå –û—Ç–ø—É—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞');
      return NextResponse.json({ message: '–û—Ç–ø—É—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
    const formattedVacation = {
      ...vacation,
      activities: vacation.activities.map(activity => ({
        ...activity,
        // –ë–µ—Ä–µ–º –ø–µ—Ä–≤–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞ –∫–∞–∫ "–∞–≤—Ç–æ—Ä–∞" –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        author: activity.participants[0]?.user || null,
        participants: activity.participants.map(p => p.user)
      }))
    };

    console.log('‚úÖ –û—Ç–ø—É—Å–∫ –Ω–∞–π–¥–µ–Ω:', formattedVacation.title);
    return NextResponse.json(formattedVacation);

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–ø—É—Å–∫–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/route.js
–†–ê–ó–ú–ï–†: 4163 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

// –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –æ—Ç–ø—É—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json(
        { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' },
        { status: 401 }
      );
    }

    // –ü–æ–ª—É—á–∞–µ–º –æ—Ç–ø—É—Å–∫–∏ –≥–¥–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —è–≤–ª—è–µ—Ç—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–º
    const vacations = await prisma.vacation.findMany({
      where: {
        OR: [
          { userId: decoded.userId }, // –í–ª–∞–¥–µ–ª–µ—Ü
          { members: { some: { userId: decoded.userId, status: 'accepted' } } } // –£—á–∞—Å—Ç–Ω–∏–∫
        ]
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        members: {
          where: {
            status: 'accepted'
          },
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                avatar: true
              }
            }
          }
        },
        activities: {
          orderBy: { date: 'asc' }
        },
        memories: true,
        locations: true,
        _count: {
          select: {
            activities: true,
            memories: true,
            members: true,
            locations: true
          }
        }
      },
      orderBy: { startDate: 'asc' }
    });

    return NextResponse.json(vacations);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–ø—É—Å–∫–æ–≤:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

// –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –æ—Ç–ø—É—Å–∫
export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json(
        { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' },
        { status: 401 }
      );
    }

    const { title, description, destination, startDate, endDate } = await request.json();

    if (!title || !startDate || !endDate) {
      return NextResponse.json(
        { message: '–ù–∞–∑–≤–∞–Ω–∏–µ –∏ –¥–∞—Ç—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' },
        { status: 400 }
      );
    }

    // –°–æ–∑–¥–∞–µ–º –æ—Ç–ø—É—Å–∫
    const vacation = await prisma.vacation.create({
      data: {
        title,
        description,
        destination,
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        userId: decoded.userId,
        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ–º –≤–ª–∞–¥–µ–ª—å—Ü–∞ –∫–∞–∫ —É—á–∞—Å—Ç–Ω–∏–∫–∞
        members: {
          create: {
            userId: decoded.userId,
            role: 'owner',
            status: 'accepted'
          }
        }
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        members: {
          where: {
            status: 'accepted'
          },
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                avatar: true
              }
            }
          }
        },
        activities: true,
        memories: true,
        locations: true,
        _count: {
          select: {
            activities: true,
            memories: true,
            members: true,
            locations: true
          }
        }
      }
    });

    return NextResponse.json(vacation, { status: 201 });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –æ—Ç–ø—É—Å–∫–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}


