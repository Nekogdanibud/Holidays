–û–¢–ß–ï–¢ –û –§–ê–ô–õ–ê–•
–ü–∞–ø–∫–∞: /OTPUSK/otpusk-app/Holidays/src/app/api
–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è: 11/1/2025, 6:14:47 PM
–í—Å–µ–≥–æ —Ñ–∞–π–ª–æ–≤: 38
–ò—Å–∫–ª—é—á–µ–Ω–Ω—ã–µ –ø–∞–ø–∫–∏: posts, admin, api, node_modules, dist, build, .git, .next, cache, temp
–ò—Å–∫–ª—é—á–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã: global.css, favicon.ico
================================================================================


================================================================================
–§–ê–ô–õ: activities/[id]/participate/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/activities/[id]/participate/route.js
–†–ê–ó–ú–ï–†: 4142 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/activities/[id]/participate/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function POST(request, { params }) {
  try {
    const { id: activityId } = await params;
    const { going } = await request.json(); // true = –∏–¥—É, false = –Ω–µ –∏–¥—É
    
    console.log('üéØ –£—á–∞—Å—Ç–∏–µ –≤ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:', { activityId, going });
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
    const activity = await prisma.activity.findFirst({
      where: {
        id: activityId,
        vacation: {
          OR: [
            { userId: decoded.userId },
            { members: { some: { userId: decoded.userId, status: 'ACCEPTED' } } }
          ]
        }
      },
      include: {
        participants: {
          include: {
            user: {
              select: { id: true, name: true, avatar: true }
            }
          }
        }
      }
    });

    if (!activity) {
      return NextResponse.json({ message: '–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞' }, { status: 404 });
    }

    const status = going ? 'GOING' : 'NOT_GOING';

    // –û–±–Ω–æ–≤–ª—è–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º —É—á–∞—Å—Ç–∏–µ
    const participation = await prisma.activityParticipant.upsert({
      where: {
        activityId_userId: {
          activityId,
          userId: decoded.userId
        }
      },
      update: {
        status
      },
      create: {
        activityId,
        userId: decoded.userId,
        status
      },
      include: {
        user: {
          select: { id: true, name: true, avatar: true }
        },
        activity: {
          include: {
            participants: {
              include: {
                user: {
                  select: { id: true, name: true, avatar: true }
                }
              }
            }
          }
        }
      }
    });

    // –ü–æ–ª—É—á–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
    const goingParticipantsCount = await prisma.activityParticipant.count({
      where: {
        activityId,
        status: 'GOING'
      }
    });

    console.log('‚úÖ –°—Ç–∞—Ç—É—Å —É—á–∞—Å—Ç–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω:', { 
      userId: decoded.userId, 
      status, 
      goingParticipantsCount 
    });

    return NextResponse.json({
      participation,
      goingParticipantsCount,
      message: going ? '–í—ã –∏–¥–µ—Ç–µ –Ω–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å!' : '–í—ã –æ—Ç–∫–∞–∑–∞–ª–∏—Å—å –æ—Ç —É—á–∞—Å—Ç–∏—è'
    });

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ —É—á–∞—Å—Ç–∏—è –≤ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

// –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å —É—á–∞—Å—Ç–∏—è —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export async function GET(request, { params }) {
  try {
    const { id: activityId } = await params;
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü–æ–ª—É—á–∞–µ–º —É—á–∞—Å—Ç–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const participation = await prisma.activityParticipant.findUnique({
      where: {
        activityId_userId: {
          activityId,
          userId: decoded.userId
        }
      }
    });

    // –ü–æ–ª—É—á–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
    const goingParticipantsCount = await prisma.activityParticipant.count({
      where: {
        activityId,
        status: 'GOING'
      }
    });

    return NextResponse.json({
      isGoing: participation?.status === 'GOING',
      goingParticipantsCount
    });

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ —É—á–∞—Å—Ç–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: activities/[id]/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/activities/[id]/route.js
–†–ê–ó–ú–ï–†: 10415 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/activities/[id]/route.js (–ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø)
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function GET(request, { params }) {
  try {
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    console.log('üîç –ü–æ–ª—É—á–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:', { activityId: id, userId: decoded.userId });

    // –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Å —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è–º–∏ –¢–û–õ–¨–ö–û —ç—Ç–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
    const activity = await prisma.activity.findFirst({
      where: {
        id: id,
        vacation: {
          OR: [
            { userId: decoded.userId },
            { members: { some: { userId: decoded.userId, status: 'ACCEPTED' } } }
          ]
        }
      },
      include: {
        location: {
          select: {
            id: true,
            name: true,
            address: true,
            description: true,
            latitude: true,
            longitude: true,
            type: true,
            priceLevel: true,
            rating: true,
            website: true,
            phone: true
          }
        },
        vacation: {
          select: {
            id: true,
            title: true,
            destination: true,
            startDate: true,
            endDate: true,
            userId: true,
            members: {
              where: { status: 'ACCEPTED' },
              include: {
                user: {
                  select: { id: true, name: true, avatar: true }
                }
              }
            }
          }
        },
        participants: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                avatar: true,
                usertag: true
              }
            }
          }
        },
        // –í–ê–ñ–ù–û: —Ç–æ–ª—å–∫–æ —Ñ–æ—Ç–æ —Å activityId = —ç—Ç–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        memories: {
          where: {
            activityId: id  // –¢–û–õ–¨–ö–û —Ñ–æ—Ç–æ —ç—Ç–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
          },
          include: {
            author: {
              select: {
                id: true,
                name: true,
                avatar: true,
                usertag: true
              }
            }
          },
          orderBy: { takenAt: 'asc' }
        }
      }
    });

    if (!activity) {
      console.log('‚ùå –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞');
      return NextResponse.json({ message: '–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞' }, { status: 404 });
    }

    console.log('‚úÖ –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞:', {
      title: activity.title,
      activityPhotosCount: activity.memories?.length || 0,
      activityPhotos: activity.memories?.map(m => ({
        id: m.id,
        activityId: m.activityId,
        title: m.title
      }))
    });

    // –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π
    const response = {
      ...activity,
      goingCount: activity.participants?.filter(p => p.status === 'GOING').length || 0,
      goingParticipants: activity.participants?.filter(p => p.status === 'GOING') || []
    };

    return NextResponse.json(response);

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

export async function PUT(request, { params }) {
  try {
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const formData = await request.formData();
    
    const title = formData.get('title');
    const description = formData.get('description');
    const date = formData.get('date');
    const type = formData.get('type');
    const status = formData.get('status');
    const priority = formData.get('priority');
    const startTime = formData.get('startTime');
    const endTime = formData.get('endTime');
    const cost = formData.get('cost');
    const notes = formData.get('notes');
    const locationName = formData.get('locationName');
    const locationAddress = formData.get('locationAddress');
    const bannerImage = formData.get('bannerImage');

    console.log('üìù –ü–æ–ª—É—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:', {
      title, description, date, type, status, priority,
      startTime, endTime, cost, notes,
      locationName, locationAddress,
      hasBanner: !!bannerImage
    });

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –Ω–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
    const activity = await prisma.activity.findFirst({
      where: {
        id: id,
        vacation: {
          OR: [
            { userId: decoded.userId },
            { members: { some: { userId: decoded.userId, role: 'CO_ORGANIZER' } } }
          ]
        }
      },
      include: {
        location: true
      }
    });

    if (!activity) {
      return NextResponse.json({ message: '–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ –Ω–µ—Ç –ø—Ä–∞–≤' }, { status: 404 });
    }

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –¥–ª—è –∞—Ç–æ–º–∞—Ä–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
    const result = await prisma.$transaction(async (tx) => {
      let locationId = activity.locationId;

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ª–æ–∫–∞—Ü–∏–∏
      if (locationName && locationName.trim()) {
        if (activity.locationId) {
          // –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –ª–æ–∫–∞—Ü–∏—é
          await tx.location.update({
            where: { id: activity.locationId },
            data: {
              name: locationName.trim(),
              address: locationAddress?.trim() || null,
              type: type || 'OTHER'
            }
          });
        } else {
          // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –ª–æ–∫–∞—Ü–∏—é
          const newLocation = await tx.location.create({
            data: {
              name: locationName.trim(),
              address: locationAddress?.trim() || null,
              type: type || 'OTHER',
              vacationId: activity.vacationId
            }
          });
          locationId = newLocation.id;
        }
      } else if (activity.locationId) {
        // –£–¥–∞–ª—è–µ–º —Å–≤—è–∑—å —Å –ª–æ–∫–∞—Ü–∏–µ–π –µ—Å–ª–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –æ—á–∏—â–µ–Ω–æ
        locationId = null;
      }

      // –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
      const updateData = {
        title: title?.trim(),
        description: description?.trim() || null,
        date: date ? new Date(date) : undefined,
        type,
        status,
        priority,
        startTime: startTime || null,
        endTime: endTime || null,
        cost: cost ? parseFloat(cost) : null,
        notes: notes?.trim() || null,
        locationId: locationId
      };

      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –±–∞–Ω–Ω–µ—Ä–∞
      if (bannerImage && bannerImage instanceof File && bannerImage.size > 0) {
        // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –±–∞–Ω–Ω–µ—Ä–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        const activityBannerDir = join(process.cwd(), 'public', 'uploads', 'activity-banners', id);
        await mkdir(activityBannerDir, { recursive: true });

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞
        const fileExtension = bannerImage.name.split('.').pop() || 'jpg';
        const filename = `banner.${fileExtension}`;
        const filepath = join(activityBannerDir, filename);
        const bannerUrl = `/uploads/activity-banners/${id}/${filename}`;

        console.log('üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –±–∞–Ω–Ω–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:', {
          activityId: id,
          filename,
          filepath,
          bannerUrl,
          size: bannerImage.size
        });

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª
        const bytes = await bannerImage.arrayBuffer();
        const buffer = Buffer.from(bytes);
        await writeFile(filepath, buffer);

        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –±–∞–Ω–Ω–µ—Ä –µ—Å–ª–∏ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        if (activity.bannerImage) {
          try {
            const oldBannerPath = join(process.cwd(), 'public', activity.bannerImage);
            await unlink(oldBannerPath);
            console.log('üóëÔ∏è –£–¥–∞–ª–µ–Ω —Å—Ç–∞—Ä—ã–π –±–∞–Ω–Ω–µ—Ä:', activity.bannerImage);
          } catch (error) {
            console.warn('‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Å—Ç–∞—Ä—ã–π –±–∞–Ω–Ω–µ—Ä:', error);
          }
        }

        updateData.bannerImage = bannerUrl;
      } else if (bannerImage === 'remove') {
        // –£–¥–∞–ª—è–µ–º –±–∞–Ω–Ω–µ—Ä –µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω–æ 'remove'
        if (activity.bannerImage) {
          try {
            const oldBannerPath = join(process.cwd(), 'public', activity.bannerImage);
            await unlink(oldBannerPath);
            console.log('üóëÔ∏è –ë–∞–Ω–Ω–µ—Ä —É–¥–∞–ª–µ–Ω –ø–æ –∑–∞–ø—Ä–æ—Å—É:', activity.bannerImage);
          } catch (error) {
            console.warn('‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –±–∞–Ω–Ω–µ—Ä:', error);
          }
        }
        updateData.bannerImage = null;
      }

      console.log('üìù –§–∏–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:', updateData);

      // –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
      const updatedActivity = await tx.activity.update({
        where: { id: id },
        data: updateData,
        include: {
          location: {
            select: { id: true, name: true, address: true }
          },
          participants: {
            include: {
              user: {
                select: { id: true, name: true, avatar: true }
              }
            }
          },
          vacation: {
            select: { id: true, title: true }
          }
        }
      });

      return updatedActivity;
    });

    console.log('‚úÖ –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –æ–±–Ω–æ–≤–ª–µ–Ω–∞:', {
      title: result.title,
      hasBanner: !!result.bannerImage,
      location: result.location
    });

    return NextResponse.json(result);

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:', error);
    
    // –ë–æ–ª–µ–µ –¥–µ—Ç–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
    if (error.code === 'P2009') {
      console.error('‚ùå –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ Prisma:', error);
      return NextResponse.json(
        { message: '–û—à–∏–±–∫–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ Prisma Client.' },
        { status: 500 }
      );
    }
    
    if (error.code === 'P2025') {
      return NextResponse.json(
        { message: '–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞' },
        { status: 404 }
      );
    }
    
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: activities/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/activities/route.js
–†–ê–ó–ú–ï–†: 3272 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/activities/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { 
      title, 
      description, 
      date, 
      type, 
      vacationId, 
      locationId, 
      status = 'PLANNED', 
      priority = 'MEDIUM', 
      startTime, 
      endTime, 
      cost, 
      notes 
    } = await request.json();

    if (!title || !date || !type || !vacationId) {
      return NextResponse.json(
        { message: '–û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è: –Ω–∞–∑–≤–∞–Ω–∏–µ, –¥–∞—Ç–∞, —Ç–∏–ø –∏ ID –æ—Ç–ø—É—Å–∫–∞' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ –æ—Ç–ø—É—Å–∫—É
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: vacationId,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'ACCEPTED', role: { in: ['OWNER', 'CO_ORGANIZER'] } } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    // –°–æ–∑–¥–∞–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
    const activity = await prisma.activity.create({
      data: {
        title: title.trim(),
        description: description?.trim() || null,
        date: new Date(date),
        type,
        status,
        priority,
        startTime: startTime || null,
        endTime: endTime || null,
        cost: cost ? parseFloat(cost) : null,
        notes: notes?.trim() || null,
        vacationId,
        locationId: locationId || null
      },
      include: {
        location: {
          select: { id: true, name: true, address: true }
        },
        participants: {
          include: {
            user: {
              select: { id: true, name: true, avatar: true }
            }
          }
        },
        vacation: {
          select: { id: true, title: true }
        }
      }
    });

    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ–º —Å–æ–∑–¥–∞—Ç–µ–ª—è –∫–∞–∫ —É—á–∞—Å—Ç–Ω–∏–∫–∞
    await prisma.activityParticipant.create({
      data: {
        activityId: activity.id,
        userId: decoded.userId,
        status: 'GOING'
      }
    });

    // –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Å —É—á–∞—Å—Ç–Ω–∏–∫–∞–º–∏
    const updatedActivity = await prisma.activity.findUnique({
      where: { id: activity.id },
      include: {
        location: {
          select: { id: true, name: true, address: true }
        },
        participants: {
          include: {
            user: {
              select: { id: true, name: true, avatar: true }
            }
          }
        },
        vacation: {
          select: { id: true, title: true }
        }
      }
    });

    return NextResponse.json(updatedActivity, { status: 201 });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/login/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/login/route.js
–†–ê–ó–ú–ï–†: 2408 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/login/route.js
import { NextResponse } from 'next/server';
import { verifyPassword, createSession } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const { email, password, rememberMe = false } = await request.json();

    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    if (!email || !password) {
      return NextResponse.json(
        { message: 'Email –∏ –ø–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' },
        { status: 400 }
      );
    }

    // –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = await prisma.user.findUnique({
      where: { email }
    });

    if (!user) {
      return NextResponse.json(
        { message: '–ù–µ–≤–µ—Ä–Ω—ã–π email –∏–ª–∏ –ø–∞—Ä–æ–ª—å' },
        { status: 401 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ä–æ–ª—è
    const isPasswordValid = await verifyPassword(password, user.password);
    if (!isPasswordValid) {
      return NextResponse.json(
        { message: '–ù–µ–≤–µ—Ä–Ω—ã–π email –∏–ª–∏ –ø–∞—Ä–æ–ª—å' },
        { status: 401 }
      );
    }

    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–ª–∏–µ–Ω—Ç–µ
    const userAgent = request.headers.get('user-agent');
    const ipAddress = request.headers.get('x-forwarded-for') || request.ip;

    // –°–æ–∑–¥–∞–µ–º —Å–µ—Å—Å–∏—é —Å —É—á–µ—Ç–æ–º rememberMe
    const { accessToken, refreshToken, sessionId } = await createSession(
      user.id, 
      userAgent, 
      ipAddress,
      rememberMe
    );

    const userData = {
      id: user.id,
      name: user.name,
      email: user.email,
      createdAt: user.createdAt
    };

    const response = NextResponse.json(
      { 
        message: '–í—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ',
        user: userData
      },
      { status: 200 }
    );

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º httpOnly –∫—É–∫–∏ —Å —Ä–∞–∑–Ω—ã–º –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏
    response.cookies.set('accessToken', accessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 1000 // 1 —á–∞—Å
    });

    response.cookies.set('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: rememberMe 
        ? 365 * 24 * 60 * 60 * 1000 // 1 –≥–æ–¥ –¥–ª—è "–ó–∞–ø–æ–º–Ω–∏—Ç—å –º–µ–Ω—è"
        : 30 * 24 * 60 * 60 * 1000 // 30 –¥–Ω–µ–π –¥–ª—è –æ–±—ã—á–Ω–æ–π —Å–µ—Å—Å–∏–∏
    });

    return response;

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/logout/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/logout/route.js
–†–ê–ó–ú–ï–†: 1175 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/logout/route.js
import { NextResponse } from 'next/server';
import { deleteSession } from '../../../../lib/auth';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (accessToken) {
      const { verifyAccessToken } = await import('../../../../lib/auth');
      const decoded = verifyAccessToken(accessToken);
      
      if (decoded?.sessionId) {
        await deleteSession(decoded.sessionId);
      }
    }

    const response = NextResponse.json(
      { message: '–í—ã—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ' },
      { status: 200 }
    );

    // –û—á–∏—â–∞–µ–º –∫—É–∫–∏
    response.cookies.set('accessToken', '', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 0
    });

    response.cookies.set('refreshToken', '', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 0
    });

    return response;

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –≤—ã—Ö–æ–¥–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/me/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/me/route.js
–†–ê–ó–ú–ï–†: 1665 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/me/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function GET(request) {
  try {
    console.log('üîç Checking auth...');
    
    const accessToken = request.cookies.get('accessToken')?.value;
    console.log('Access token exists:', !!accessToken);

    if (!accessToken) {
      console.log('‚ùå No access token');
      return NextResponse.json(
        { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    console.log('Decoded token:', decoded);

    if (!decoded) {
      console.log('‚ùå Invalid token');
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' },
        { status: 401 }
      );
    }

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã —Å usertag
    console.log('üë§ Fetching user:', decoded.userId);
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: {
        id: true,
        name: true,
        usertag: true, // –î–û–ë–ê–í–õ–ï–ù–û
        email: true,
        avatar: true,
        createdAt: true
      }
    });

    console.log('User found:', !!user);
    console.log('User usertag:', user?.usertag);

    if (!user) {
      return NextResponse.json(
        { message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' },
        { status: 404 }
      );
    }

    return NextResponse.json(user);

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/refresh/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/refresh/route.js
–†–ê–ó–ú–ï–†: 1271 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/refresh/route.js
import { NextResponse } from 'next/server';
import { verifySession, generateAccessToken } from '../../../../lib/auth';

export async function POST(request) {
  try {
    const refreshToken = request.cookies.get('refreshToken')?.value;

    if (!refreshToken) {
      return NextResponse.json(
        { message: 'Refresh token –Ω–µ –Ω–∞–π–¥–µ–Ω' },
        { status: 401 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–µ—Å—Å–∏—é
    const session = await verifySession(refreshToken);
    if (!session) {
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞—è —Å–µ—Å—Å–∏—è' },
        { status: 401 }
      );
    }

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π access token
    const newAccessToken = generateAccessToken(session.userId, session.id);

    const response = NextResponse.json(
      { message: 'Token –æ–±–Ω–æ–≤–ª–µ–Ω' },
      { status: 200 }
    );

    response.cookies.set('accessToken', newAccessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 1000 // 1 —á–∞—Å
    });

    return response;

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/register/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/register/route.js
–†–ê–ó–ú–ï–†: 3926 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/register/route.js (–æ–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
import { NextResponse } from 'next/server';
import { hashPassword, createSession } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const { name, usertag, email, password, rememberMe = false } = await request.json();

    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    if (!name || !usertag || !email || !password) {
      return NextResponse.json(
        { message: '–í—Å–µ –ø–æ–ª—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è' },
        { status: 400 }
      );
    }

    if (password.length < 6) {
      return NextResponse.json(
        { message: '–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 6 —Å–∏–º–≤–æ–ª–æ–≤' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ usertag
    if (!/^[a-z0-9-]+$/.test(usertag)) {
      return NextResponse.json(
        { message: 'Usertag –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ –ª–∞—Ç–∏–Ω—Å–∫–∏–µ –±—É–∫–≤—ã –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ, —Ü–∏—Ñ—Ä—ã –∏ –¥–µ—Ñ–∏—Å—ã' },
        { status: 400 }
      );
    }

    if (usertag.length < 3 || usertag.length > 20) {
      return NextResponse.json(
        { message: 'Usertag –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 3 –¥–æ 20 —Å–∏–º–≤–æ–ª–æ–≤' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ email –∏ usertag
    const existingUser = await prisma.user.findFirst({
      where: {
        OR: [
          { email },
          { usertag }
        ]
      }
    });

    if (existingUser) {
      if (existingUser.email === email) {
        return NextResponse.json(
          { message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç' },
          { status: 409 }
        );
      }
      if (existingUser.usertag === usertag) {
        return NextResponse.json(
          { message: '–≠—Ç–æ—Ç usertag —É–∂–µ –∑–∞–Ω—è—Ç' },
          { status: 409 }
        );
      }
    }

    // –•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–æ–ª—è
    const hashedPassword = await hashPassword(password);

    // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const newUser = await prisma.user.create({
      data: {
        name,
        usertag,
        email,
        password: hashedPassword,
      },
      select: {
        id: true,
        name: true,
        usertag: true,
        email: true,
        createdAt: true
      }
    });

    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–ª–∏–µ–Ω—Ç–µ
    const userAgent = request.headers.get('user-agent');
    const ipAddress = request.headers.get('x-forwarded-for') || request.ip;

    // –°–æ–∑–¥–∞–µ–º —Å–µ—Å—Å–∏—é —Å —É—á–µ—Ç–æ–º rememberMe
    const { accessToken, refreshToken, sessionId } = await createSession(
      newUser.id, 
      userAgent, 
      ipAddress,
      rememberMe
    );

    const response = NextResponse.json(
      { 
        message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω',
        user: newUser
      },
      { status: 201 }
    );

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º httpOnly –∫—É–∫–∏ —Å —Ä–∞–∑–Ω—ã–º –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏
    response.cookies.set('accessToken', accessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 1000 // 1 —á–∞—Å
    });

    response.cookies.set('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: rememberMe 
        ? 365 * 24 * 60 * 60 * 1000 // 1 –≥–æ–¥ –¥–ª—è "–ó–∞–ø–æ–º–Ω–∏—Ç—å –º–µ–Ω—è"
        : 30 * 24 * 60 * 60 * 1000 // 30 –¥–Ω–µ–π –¥–ª—è –æ–±—ã—á–Ω–æ–π —Å–µ—Å—Å–∏–∏
    });

    return response;

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:', error);
    
    if (error.code === 'P2002') {
      const field = error.meta?.target?.[0];
      if (field === 'email') {
        return NextResponse.json(
          { message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç' },
          { status: 409 }
        );
      }
      if (field === 'usertag') {
        return NextResponse.json(
          { message: '–≠—Ç–æ—Ç usertag —É–∂–µ –∑–∞–Ω—è—Ç' },
          { status: 409 }
        );
      }
    }

    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/sessions/all/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/sessions/all/route.js
–†–ê–ó–ú–ï–†: 1334 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/sessions/all/route.js
import { NextResponse } from 'next/server';
import { deleteAllUserSessions } from '../../../../../lib/auth';
import { verifyAccessToken } from '../../../../../lib/auth';

// –£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Å–µ—Å—Å–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–∫—Ä–æ–º–µ —Ç–µ–∫—É—â–µ–π)
export async function DELETE(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json(
        { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' },
        { status: 401 }
      );
    }

    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Å–µ—Å—Å–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const { getUserSessions, deleteSession } = await import('../../../../../lib/auth');
    const sessions = await getUserSessions(decoded.userId);

    // –£–¥–∞–ª—è–µ–º –≤—Å–µ —Å–µ—Å—Å–∏–∏ –∫—Ä–æ–º–µ —Ç–µ–∫—É—â–µ–π
    for (const session of sessions) {
      if (session.id !== decoded.sessionId) {
        await deleteSession(session.id);
      }
    }

    return NextResponse.json({ message: '–í—Å–µ –¥—Ä—É–≥–∏–µ —Å–µ—Å—Å–∏–∏ —É–¥–∞–ª–µ–Ω—ã' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å–µ—Å—Å–∏–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/sessions/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/sessions/route.js
–†–ê–ó–ú–ï–†: 1817 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/sessions/route.js
import { NextResponse } from 'next/server';
import { getUserSessions, deleteSession, deleteAllUserSessions } from '../../../../lib/auth';
import { verifyAccessToken } from '../../../../lib/auth';

// –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–µ—Å—Å–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json(
        { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' },
        { status: 401 }
      );
    }

    const sessions = await getUserSessions(decoded.userId);

    return NextResponse.json({ sessions });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–µ—Å—Å–∏–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

// –£–¥–∞–ª–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é —Å–µ—Å—Å–∏—é
export async function DELETE(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;
    const { sessionId } = await request.json();

    if (!accessToken) {
      return NextResponse.json(
        { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' },
        { status: 401 }
      );
    }

    await deleteSession(sessionId);

    return NextResponse.json({ message: '–°–µ—Å—Å–∏—è —É–¥–∞–ª–µ–Ω–∞' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å–µ—Å—Å–∏–∏:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: friends/list/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/friends/list/route.js
–†–ê–ó–ú–ï–†: 1561 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/friends/list/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü–æ–ª—É—á–∞–µ–º –¥—Ä—É–∑–µ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const friendships = await prisma.friendship.findMany({
      where: {
        OR: [
          { user1Id: decoded.userId },
          { user2Id: decoded.userId }
        ]
      },
      include: {
        user1: {
          select: {
            id: true,
            name: true,
            usertag: true,
            avatar: true
          }
        },
        user2: {
          select: {
            id: true,
            name: true,
            usertag: true,
            avatar: true
          }
        }
      }
    });

    // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ –¥—Ä—É–∑–µ–π
    const friends = friendships.map(friendship => 
      friendship.user1Id === decoded.userId ? friendship.user2 : friendship.user1
    );

    return NextResponse.json({ friends });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –¥—Ä—É–∑–µ–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: friends/request/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/friends/request/route.js
–†–ê–ó–ú–ï–†: 3203 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/friends/request/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { userId } = await request.json();

    if (!userId) {
      return NextResponse.json({ message: 'User ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' }, { status: 400 });
    }

    // –ù–µ–ª—å–∑—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å —Å–∞–º–æ–º—É —Å–µ–±–µ
    if (userId === decoded.userId) {
      return NextResponse.json(
        { message: '–ù–µ–ª—å–∑—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è —Å–∞–º–æ–º—É —Å–µ–±–µ' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const targetUser = await prisma.user.findUnique({
      where: { id: userId }
    });

    if (!targetUser) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ –ª–∏ —É–∂–µ –∑–∞–ø—Ä–æ—Å
    const existingRequest = await prisma.friendRequest.findFirst({
      where: {
        senderId: decoded.userId,
        receiverId: userId
      }
    });

    if (existingRequest) {
      return NextResponse.json(
        { message: '–ó–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è —É–∂–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω' },
        { status: 409 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è—é—Ç—Å—è –ª–∏ —É–∂–µ –¥—Ä—É–∑—å—è–º–∏
    const existingFriendship = await prisma.friendship.findFirst({
      where: {
        OR: [
          { user1Id: decoded.userId, user2Id: userId },
          { user1Id: userId, user2Id: decoded.userId }
        ]
      }
    });

    if (existingFriendship) {
      return NextResponse.json(
        { message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —É –≤–∞—Å –≤ –¥—Ä—É–∑—å—è—Ö' },
        { status: 409 }
      );
    }

    // –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è
    const friendRequest = await prisma.friendRequest.create({
      data: {
        senderId: decoded.userId,
        receiverId: userId,
        status: 'PENDING'
      },
      include: {
        sender: {
          select: {
            id: true,
            name: true,
            avatar: true,
            usertag: true
          }
        }
      }
    });

    // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª—É—á–∞—Ç–µ–ª—è
    await prisma.notification.create({
      data: {
        userId: userId,
        type: 'friend_request',
        title: '–ù–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è',
        message: `${friendRequest.sender.name} —Ö–æ—á–µ—Ç –¥–æ–±–∞–≤–∏—Ç—å –≤–∞—Å –≤ –¥—Ä—É–∑—å—è`,
        data: {
          requestId: friendRequest.id,
          senderId: decoded.userId,
          senderName: friendRequest.sender.name,
          senderAvatar: friendRequest.sender.avatar
        }
      }
    });

    return NextResponse.json({
      message: '–ó–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω',
      request: friendRequest
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞–ø—Ä–æ—Å–∞ –≤ –¥—Ä—É–∑—å—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: friends/respond/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/friends/respond/route.js
–†–ê–ó–ú–ï–†: 3626 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { requestId, accept } = await request.json();

    console.log('üì® –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –¥—Ä—É–∂–±—ã:', { requestId, accept, userId: decoded.userId });

    if (!requestId) {
      return NextResponse.json({ message: 'Request ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' }, { status: 400 });
    }

    // –ù–∞—Ö–æ–¥–∏–º –∑–∞–ø—Ä–æ—Å
    const friendRequest = await prisma.friendRequest.findFirst({
      where: {
        id: requestId,
        receiverId: decoded.userId,
        status: 'PENDING'
      },
      include: {
        sender: {
          select: {
            id: true,
            name: true,
            avatar: true,
            usertag: true
          }
        },
        receiver: {
          select: {
            id: true,
            name: true,
            avatar: true,
            usertag: true
          }
        }
      }
    });

    console.log('üîç –ù–∞–π–¥–µ–Ω –∑–∞–ø—Ä–æ—Å –¥—Ä—É–∂–±—ã:', friendRequest);

    if (!friendRequest) {
      return NextResponse.json({ message: '–ó–∞–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    if (accept) {
      // –ü—Ä–∏–Ω–∏–º–∞–µ–º –∑–∞–ø—Ä–æ—Å - —Å–æ–∑–¥–∞–µ–º –¥—Ä—É–∂–±—É
      const result = await prisma.$transaction(async (tx) => {
        // –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –æ –¥—Ä—É–∂–±–µ (—É–±–µ–¥–∏–º—Å—è, —á—Ç–æ user1Id –≤—Å–µ–≥–¥–∞ –º–µ–Ω—å—à–µ user2Id –¥–ª—è —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏)
        const user1Id = friendRequest.senderId < decoded.userId ? friendRequest.senderId : decoded.userId;
        const user2Id = friendRequest.senderId < decoded.userId ? decoded.userId : friendRequest.senderId;

        console.log('üë• –°–æ–∑–¥–∞–µ–º –¥—Ä—É–∂–±—É –º–µ–∂–¥—É:', { user1Id, user2Id });

        const friendship = await tx.friendship.create({
          data: {
            user1Id,
            user2Id
          }
        });

        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–ø—Ä–æ—Å–∞
        await tx.friendRequest.update({
          where: { id: requestId },
          data: { status: 'ACCEPTED' }
        });

        // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è
        await tx.notification.create({
          data: {
            userId: friendRequest.senderId,
            type: 'friend_request_accepted',
            title: '–ó–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è –ø—Ä–∏–Ω—è—Ç',
            message: `${friendRequest.receiver.name} –ø—Ä–∏–Ω—è–ª(–∞) –≤–∞—à –∑–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è`,
            data: {
              friendId: decoded.userId,
              friendName: friendRequest.receiver.name,
              friendAvatar: friendRequest.receiver.avatar,
              friendUsertag: friendRequest.receiver.usertag
            }
          }
        });

        return friendship;
      });

      console.log('‚úÖ –ó–∞–ø—Ä–æ—Å –¥—Ä—É–∂–±—ã –ø—Ä–∏–Ω—è—Ç:', result);

      return NextResponse.json({ 
        message: '–ó–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è –ø—Ä–∏–Ω—è—Ç',
        friendship: result
      });

    } else {
      // –û—Ç–∫–ª–æ–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å
      await prisma.friendRequest.update({
        where: { id: requestId },
        data: { status: 'REJECTED' }
      });

      console.log('‚ùå –ó–∞–ø—Ä–æ—Å –¥—Ä—É–∂–±—ã –æ—Ç–∫–ª–æ–Ω–µ–Ω');

      return NextResponse.json({ message: '–ó–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è –æ—Ç–∫–ª–æ–Ω–µ–Ω' });
    }

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–∞ –≤ –¥—Ä—É–∑—å—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: friends/status/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/friends/status/route.js
–†–ê–ó–ú–ï–†: 2043 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/friends/status/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const targetUserId = searchParams.get('targetUserId');
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    if (!targetUserId) {
      return NextResponse.json({ message: 'Target User ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' }, { status: 400 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥—Ä—É–∂–±—É
    const friendship = await prisma.friendship.findFirst({
      where: {
        OR: [
          { user1Id: decoded.userId, user2Id: targetUserId },
          { user1Id: targetUserId, user2Id: decoded.userId }
        ]
      }
    });

    if (friendship) {
      return NextResponse.json({ status: 'friends' });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏—Å—Ö–æ–¥—è—â–∏–π –∑–∞–ø—Ä–æ—Å
    const outgoingRequest = await prisma.friendRequest.findFirst({
      where: {
        senderId: decoded.userId,
        receiverId: targetUserId,
        status: 'PENDING'
      }
    });

    if (outgoingRequest) {
      return NextResponse.json({ status: 'pending' });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Ö–æ–¥—è—â–∏–π –∑–∞–ø—Ä–æ—Å
    const incomingRequest = await prisma.friendRequest.findFirst({
      where: {
        senderId: targetUserId,
        receiverId: decoded.userId,
        status: 'PENDING'
      }
    });

    if (incomingRequest) {
      return NextResponse.json({ status: 'incoming' });
    }

    return NextResponse.json({ status: 'none' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ –¥—Ä—É–∂–±—ã:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: invitations/[id]/respond/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/invitations/[id]/respond/route.js
–†–ê–ó–ú–ï–†: 4837 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/invitations/[id]/respond/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function POST(request, { params }) {
  try {
    const { id: invitationId } = await params;
    const { accept } = await request.json();
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –∏–∑ –±–∞–∑—ã
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: { id: true, name: true, email: true }
    });

    if (!user) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    // –ù–∞—Ö–æ–¥–∏–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
    const invitation = await prisma.invitation.findFirst({
      where: {
        id: invitationId,
        email: user.email // –ò—Å–ø–æ–ª—å–∑—É–µ–º email –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
      },
      include: {
        vacation: true,
        invitedBy: {
          select: { name: true }
        }
      }
    });

    if (!invitation) {
      return NextResponse.json({ message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' }, { status: 404 });
    }

    if (invitation.status !== 'pending') {
      return NextResponse.json({ message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ' }, { status: 400 });
    }

    if (new Date() > invitation.expiresAt) {
      return NextResponse.json({ message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –∏—Å—Ç–µ–∫–ª–æ' }, { status: 400 });
    }

    if (accept) {
      // –ü—Ä–∏–Ω–∏–º–∞–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
      await prisma.$transaction(async (tx) => {
        // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∫–∞–∫ —É—á–∞—Å—Ç–Ω–∏–∫–∞
        await tx.vacationMember.create({
          data: {
            vacationId: invitation.vacationId,
            userId: user.id,
            role: 'MEMBER', // –ò–°–ü–†–ê–í–õ–ï–ù–û: –±—ã–ª–æ 'member'
            status: 'ACCEPTED', // –ò–°–ü–†–ê–í–õ–ï–ù–û: –±—ã–ª–æ 'accepted'
            joinedAt: new Date()
          }
        });

        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è
        await tx.invitation.update({
          where: { id: invitationId },
          data: { status: 'accepted' }
        });

        // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –≤–ª–∞–¥–µ–ª—å—Ü–∞
        await tx.notification.create({
          data: {
            userId: invitation.invitedById,
            type: 'info',
            title: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –ø—Ä–∏–Ω—è—Ç–æ',
            message: `${user.name} –ø—Ä–∏–Ω—è–ª(–∞) –≤–∞—à–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –æ—Ç–ø—É—Å–∫ "${invitation.vacation.title}"`,
            data: {
              vacationId: invitation.vacationId,
              acceptedByName: user.name
            }
          }
        });

        // –û–±–Ω–æ–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await tx.notification.updateMany({
          where: {
            userId: user.id,
            type: 'invitation',
            data: {
              path: ['invitationId'],
              equals: invitationId
            }
          },
          data: {
            data: {
              ...invitation.data,
              status: 'accepted'
            }
          }
        });
      });

      return NextResponse.json({ 
        message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –ø—Ä–∏–Ω—è—Ç–æ',
        vacationId: invitation.vacationId
      });
    } else {
      // –û—Ç–∫–ª–æ–Ω—è–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
      await prisma.$transaction(async (tx) => {
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è
        await tx.invitation.update({
          where: { id: invitationId },
          data: { status: 'rejected' }
        });

        // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –≤–ª–∞–¥–µ–ª—å—Ü–∞
        await tx.notification.create({
          data: {
            userId: invitation.invitedById,
            type: 'info',
            title: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ',
            message: `${user.name} –æ—Ç–∫–ª–æ–Ω–∏–ª(–∞) –≤–∞—à–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –æ—Ç–ø—É—Å–∫ "${invitation.vacation.title}"`,
            data: {
              vacationId: invitation.vacationId,
              rejectedByName: user.name
            }
          }
        });

        // –û–±–Ω–æ–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await tx.notification.updateMany({
          where: {
            userId: user.id,
            type: 'invitation',
            data: {
              path: ['invitationId'],
              equals: invitationId
            }
          },
          data: {
            data: {
              ...invitation.data,
              status: 'rejected'
            }
          }
        });
      });

      return NextResponse.json({ message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ' });
    }

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: memories/[id]/favorite/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/memories/[id]/favorite/route.js
–†–ê–ó–ú–ï–†: 1613 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// app/api/memories/[id]/favorite/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function PUT(request, { params }) {
  try {
    const { id: memoryId } = await params;
    const { isFavorite } = await request.json();
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —è–≤–ª—è–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–æ–º –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏—è
    const memory = await prisma.memory.findFirst({
      where: {
        id: memoryId,
        authorId: decoded.userId
      }
    });

    if (!memory) {
      return NextResponse.json({ message: '–í–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –∏–ª–∏ –Ω–µ—Ç –ø—Ä–∞–≤' }, { status: 404 });
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ
    const updatedMemory = await prisma.memory.update({
      where: { id: memoryId },
      data: { isFavorite },
      include: {
        author: {
          select: { id: true, name: true, avatar: true }
        }
      }
    });

    return NextResponse.json({ 
      message: isFavorite ? '–î–æ–±–∞–≤–ª–µ–Ω–æ –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ' : '–£–±—Ä–∞–Ω–æ –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ',
      memory: updatedMemory
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: memories/[id]/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/memories/[id]/route.js
–†–ê–ó–ú–ï–†: 1670 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// app/api/memories/[id]/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { unlink } from 'fs/promises';
import { join } from 'path';

export async function DELETE(request, { params }) {
  try {
    const { id: memoryId } = await params;
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ù–∞—Ö–æ–¥–∏–º –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏–µ
    const memory = await prisma.memory.findFirst({
      where: {
        id: memoryId,
        authorId: decoded.userId // –¢–æ–ª—å–∫–æ –∞–≤—Ç–æ—Ä –º–æ–∂–µ—Ç —É–¥–∞–ª–∏—Ç—å
      }
    });

    if (!memory) {
      return NextResponse.json({ message: '–í–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –∏–ª–∏ –Ω–µ—Ç –ø—Ä–∞–≤' }, { status: 404 });
    }

    // –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª —Å –¥–∏—Å–∫–∞
    try {
      const filepath = join(process.cwd(), 'public', memory.imageUrl);
      await unlink(filepath);
    } catch (error) {
      console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Ñ–∞–π–ª:', error);
      // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —É–¥–∞–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏ –∏–∑ –ë–î –¥–∞–∂–µ –µ—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω
    }

    // –£–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å—å –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
    await prisma.memory.delete({
      where: { id: memoryId }
    });

    return NextResponse.json({ message: '–í–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏–µ —É–¥–∞–ª–µ–Ω–æ' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: memories/capture/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/memories/capture/route.js
–†–ê–ó–ú–ï–†: 3546 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/memories/capture/route.js
import { NextResponse } from 'next/server';
import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const formData = await request.formData();
    const vacationId = formData.get('vacationId');
    const photos = formData.getAll('photos');

    if (!vacationId || photos.length === 0) {
      return NextResponse.json(
        { message: '–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ –æ—Ç–ø—É—Å–∫—É
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: vacationId,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π –Ω–∞ –¥–µ–Ω—å (3 —Ñ–æ—Ç–æ)
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const todayMemories = await prisma.memory.count({
      where: {
        vacationId,
        authorId: decoded.userId,
        createdAt: {
          gte: today,
          lt: tomorrow
        }
      }
    });

    if (todayMemories + photos.length > 3) {
      return NextResponse.json(
        { message: '–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –≤ 3 —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –≤ –¥–µ–Ω—å' },
        { status: 400 }
      );
    }

    const createdMemories = [];

    // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –∑–∞–≥—Ä—É–∑–æ–∫ –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç
    const uploadDir = join(process.cwd(), 'public', 'uploads', 'memories');
    try {
      await mkdir(uploadDir, { recursive: true });
    } catch (error) {
      // –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    }

    for (const photo of photos) {
      const bytes = await photo.arrayBuffer();
      const buffer = Buffer.from(bytes);
      
      // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞
      const timestamp = Date.now();
      const filename = `${timestamp}-${photo.name}`;
      const filepath = join(uploadDir, filename);

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª
      await writeFile(filepath, buffer);

      // –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –≤ –±–∞–∑–µ
      const memory = await prisma.memory.create({
        data: {
          title: `–§–æ—Ç–æ –¥–Ω—è - ${new Date().toLocaleDateString('ru-RU')}`,
          description: '–ó–∞–ø–µ—á–∞—Ç–ª–µ–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç',
          imageUrl: `/uploads/memories/${filename}`,
          takenAt: new Date(),
          vacationId,
          authorId: decoded.userId,
          tags: ['captured_moment']
        },
        include: {
          author: {
            select: { id: true, name: true, avatar: true }
          }
        }
      });

      createdMemories.push(memory);
    }

    return NextResponse.json({ 
      message: '–§–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã',
      memories: createdMemories 
    }, { status: 201 });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: memories/capture-limits/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/memories/capture-limits/route.js
–†–ê–ó–ú–ï–†: 2401 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/memories/capture-limits/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const vacationId = searchParams.get('vacationId');
    
    const accessToken = request.cookies.get('accessToken')?.value;
    if (!accessToken) return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });

    if (!vacationId) {
      return NextResponse.json({ message: 'Vacation ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' }, { status: 400 });
    }

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    // –ü–æ–ª—É—á–∞–µ–º —Å–µ–≥–æ–¥–Ω—è—à–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
    const todayActivities = await prisma.activity.findMany({
      where: {
        vacationId,
        date: { gte: today, lt: tomorrow }
      },
      select: { id: true, title: true }
    });

    // –°—á–∏—Ç–∞–µ–º –ª–∏–º–∏—Ç—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞
    const dailyMemoriesCount = await prisma.memory.count({
      where: {
        vacationId,
        authorId: decoded.userId,
        captureType: 'DAILY_MOMENT',
        takenAt: { gte: today, lt: tomorrow }
      }
    });

    const activityLimits = await Promise.all(
      todayActivities.map(async (activity) => {
        const count = await prisma.memory.count({
          where: {
            vacationId,
            authorId: decoded.userId,
            activityId: activity.id,
            captureType: 'ACTIVITY_MOMENT',
            takenAt: { gte: today, lt: tomorrow }
          }
        });
        
        return {
          activityId: activity.id,
          title: activity.title,
          used: count,
          total: 3,
          remaining: Math.max(0, 3 - count)
        };
      })
    );

    const limits = {
      daily: {
        used: dailyMemoriesCount,
        total: 3,
        remaining: Math.max(0, 3 - dailyMemoriesCount)
      },
      activities: activityLimits
    };

    return NextResponse.json(limits);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ª–∏–º–∏—Ç–æ–≤:', error);
    return NextResponse.json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' }, { status: 500 });
  }
}



================================================================================
–§–ê–ô–õ: memories/upload/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/memories/upload/route.js
–†–ê–ó–ú–ï–†: 5269 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/memories/upload/route.js
import { NextResponse } from 'next/server';
import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;
    if (!accessToken) return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });

    const formData = await request.formData();
    const vacationId = formData.get('vacationId');
    const activityId = formData.get('activityId') || null;
    const captureType = formData.get('captureType'); // 'DAILY_MOMENT' –∏–ª–∏ 'ACTIVITY_MOMENT'
    const photos = formData.getAll('photos');

    if (!vacationId || photos.length === 0) {
      return NextResponse.json({ message: '–û—Ç–ø—É—Å–∫ –∏ —Ñ–æ—Ç–æ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' }, { status: 400 });
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –æ—Ç–ø—É—Å–∫—É
    const vacation = await prisma.vacation.findFirst({
      where: {
        id: vacationId,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'ACCEPTED' } } }
        ]
      }
    });

    if (!vacation) return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω' }, { status: 403 });

    // === –õ–û–ì–ò–ö–ê –õ–ò–ú–ò–¢–û–í –î–õ–Ø CAPTURE-–§–û–¢–û ===
    if (captureType) {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);

      let allowedCount = 0;

      if (captureType === 'ACTIVITY_MOMENT' && activityId) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Å–µ–≥–æ–¥–Ω—è—à–Ω—è—è
        const activity = await prisma.activity.findFirst({
          where: {
            id: activityId,
            date: { gte: today, lt: tomorrow }
          }
        });

        if (!activity) {
          return NextResponse.json(
            { message: '–Ø—Ä–∫–∏–π –º–æ–º–µ–Ω—Ç –º–æ–∂–Ω–æ –ø—Ä–∏–≤—è–∑–∞—Ç—å —Ç–æ–ª—å–∫–æ –∫ —Å–µ–≥–æ–¥–Ω—è—à–Ω–µ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏' },
            { status: 400 }
          );
        }

        // –õ–∏–º–∏—Ç: 3 —Ñ–æ—Ç–æ –Ω–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –≤ –¥–µ–Ω—å
        const activityMemoriesCount = await prisma.memory.count({
          where: {
            vacationId,
            authorId: decoded.userId,
            activityId,
            captureType: 'ACTIVITY_MOMENT',
            takenAt: { gte: today, lt: tomorrow }
          }
        });

        allowedCount = Math.max(0, 3 - activityMemoriesCount);
      } else if (captureType === 'DAILY_MOMENT') {
        // –õ–∏–º–∏—Ç: 3 —Ñ–æ—Ç–æ –≤ –¥–µ–Ω—å –±–µ–∑ –ø—Ä–∏–≤—è–∑–∫–∏ –∫ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        const dailyMemoriesCount = await prisma.memory.count({
          where: {
            vacationId,
            authorId: decoded.userId,
            captureType: 'DAILY_MOMENT',
            activityId: null,
            takenAt: { gte: today, lt: tomorrow }
          }
        });

        allowedCount = Math.max(0, 3 - dailyMemoriesCount);
      }

      if (photos.length > allowedCount) {
        return NextResponse.json(
          { message: `–õ–∏–º–∏—Ç –ø—Ä–µ–≤—ã—à–µ–Ω. –î–æ—Å—Ç—É–ø–Ω–æ: ${allowedCount} —è—Ä–∫–∏—Ö —Ñ–æ—Ç–æ` },
          { status: 400 }
        );
      }
    }

    // === –ó–ê–ì–†–£–ó–ö–ê –§–ê–ô–õ–û–í ===
    const uploadDir = join(process.cwd(), 'public', 'uploads', 'memories');
    await mkdir(uploadDir, { recursive: true });

    const createdMemories = [];

    for (const photo of photos) {
      const buffer = Buffer.from(await photo.arrayBuffer());
      const ext = photo.name.split('.').pop()?.toLowerCase() || 'jpg';
      const timestamp = Date.now();
      const randomStr = Math.random().toString(36).substring(2, 8);
      const filename = `${timestamp}-${randomStr}.${ext}`;
      const filepath = join(uploadDir, filename);
      
      // –í–ê–ñ–ù–û: –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –ø—É—Ç–µ–º –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∏–∑ –±—Ä–∞—É–∑–µ—Ä–∞
      const publicUrl = `/uploads/memories/${filename}`;

      console.log('üíæ –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ñ–∞–π–ª–∞:', {
        filename,
        filepath,
        publicUrl,
        size: buffer.length
      });

      await writeFile(filepath, buffer);

      const memory = await prisma.memory.create({
        data: {
          title: captureType ? '–Ø—Ä–∫–∏–π –º–æ–º–µ–Ω—Ç' : '–§–æ—Ç–æ –∏–∑ –æ—Ç–ø—É—Å–∫–∞',
          description: '',
          imageUrl: publicUrl,
          takenAt: new Date(),
          vacationId,
          authorId: decoded.userId,
          activityId: captureType === 'ACTIVITY_MOMENT' ? activityId : (activityId || null),
          captureType: captureType || null,
          tags: captureType ? ['capture'] : [],
          isFavorite: false
          // –£–±–∏—Ä–∞–µ–º isCapture - –µ–≥–æ –Ω–µ—Ç –≤ —Å—Ö–µ–º–µ
        },
        include: {
          author: { select: { id: true, name: true, avatar: true, usertag: true } },
          activity: { select: { id: true, title: true } }
        }
      });

      console.log('‚úÖ –°–æ–∑–¥–∞–Ω–∞ –∑–∞–ø–∏—Å—å –ø–∞–º—è—Ç–∏:', memory.id, memory.imageUrl);
      createdMemories.push(memory);
    }

    return NextResponse.json({
      message: '–§–æ—Ç–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã',
      memories: createdMemories
    }, { status: 201 });

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–æ—Ç–æ:', error);
    return NextResponse.json({ message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' }, { status: 500 });
  }
}



================================================================================
–§–ê–ô–õ: notifications/invite/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/notifications/invite/route.js
–†–ê–ó–ú–ï–†: 1259 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/notifications/invite/route.js
import { NextResponse } from 'next/server';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const { userId, vacationId, invitedByName, vacationTitle } = await request.json();

    if (!userId || !vacationId || !invitedByName) {
      return NextResponse.json(
        { message: '–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ' },
        { status: 400 }
      );
    }

    // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–∏
    const notification = await prisma.notification.create({
      data: {
        userId,
        type: 'invitation',
        title: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –æ—Ç–ø—É—Å–∫',
        message: `${invitedByName} –ø—Ä–∏–≥–ª–∞—Å–∏–ª(–∞) –≤–∞—Å –≤ –æ—Ç–ø—É—Å–∫ "${vacationTitle}"`,
        data: {
          vacationId,
          invitedByName,
          vacationTitle
        }
      },
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            avatar: true 
          }
        }
      }
    });

    return NextResponse.json(notification, { status: 201 });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: notifications/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/notifications/route.js
–†–ê–ó–ú–ï–†: 2505 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/notifications/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

// –ü–æ–ª—É—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const notifications = await prisma.notification.findMany({
      where: { 
        userId: decoded.userId 
      },
      orderBy: { 
        createdAt: 'desc' 
      },
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            avatar: true 
          }
        }
      },
      take: 50
    });

    return NextResponse.json(notifications);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

// –ü–æ–º–µ—Ç–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ
export async function PUT(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { notificationIds } = await request.json();

    if (notificationIds && notificationIds.length > 0) {
      // –ü–æ–º–µ—Ç–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ
      await prisma.notification.updateMany({
        where: { 
          id: { in: notificationIds },
          userId: decoded.userId 
        },
        data: { isRead: true }
      });
    } else {
      // –ü–æ–º–µ—Ç–∏—Ç—å –≤—Å–µ –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ
      await prisma.notification.updateMany({
        where: { 
          userId: decoded.userId,
          isRead: false 
        },
        data: { isRead: true }
      });
    }

    return NextResponse.json({ message: '–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–º–µ—á–µ–Ω—ã –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: notifications/test/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/notifications/test/route.js
–†–ê–ó–ú–ï–†: 2783 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/notifications/test/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { type = 'info' } = await request.json();

    // –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
    let notificationData;

    switch (type) {
      case 'invitation':
        notificationData = {
          userId: decoded.userId,
          type: 'invitation',
          title: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –æ—Ç–ø—É—Å–∫',
          message: '–ê–Ω–Ω–∞ –ø—Ä–∏–≥–ª–∞—Å–∏–ª–∞ –≤–∞—Å –≤ –æ—Ç–ø—É—Å–∫ "–û—Ç–¥—ã—Ö –Ω–∞ –ë–∞–ª–∏"',
          data: {
            invitationId: 'test-invitation-123',
            vacationId: 'test-vacation-456',
            invitedByName: '–ê–Ω–Ω–∞',
            vacationTitle: '–û—Ç–¥—ã—Ö –Ω–∞ –ë–∞–ª–∏'
          }
        };
        break;

      case 'activity_update':
        notificationData = {
          userId: decoded.userId,
          type: 'activity_update',
          title: '–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–ª–∞–Ω–æ–≤',
          message: '–í –≤–∞—à–µ–º –æ—Ç–ø—É—Å–∫–µ "–ì–æ—Ä–Ω—ã–µ –ø–æ—Ö–æ–¥—ã" –¥–æ–±–∞–≤–ª–µ–Ω–∞ –Ω–æ–≤–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å',
          data: {
            vacationId: 'test-vacation-789',
            activityId: 'test-activity-123'
          }
        };
        break;

      case 'memory_comment':
        notificationData = {
          userId: decoded.userId,
          type: 'memory_comment',
          title: '–ù–æ–≤—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π',
          message: '–ò–≤–∞–Ω –ø—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–ª –≤–∞—à–µ –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏–µ',
          data: {
            memoryId: 'test-memory-123',
            commentId: 'test-comment-456'
          }
        };
        break;

      default:
        notificationData = {
          userId: decoded.userId,
          type: 'info',
          title: '–¢–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ',
          message: '–≠—Ç–æ —Ç–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–∏—Å—Ç–µ–º—ã',
          data: {
            test: true
          }
        };
    }

    const notification = await prisma.notification.create({
      data: notificationData,
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            avatar: true 
          }
        }
      }
    });

    return NextResponse.json({
      message: '–¢–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ',
      notification
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: profile/delete-temp/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/profile/delete-temp/route.js
–†–ê–ó–ú–ï–†: 1401 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/profile/delete-temp/route.js
import { NextResponse } from 'next/server';
import { unlink } from 'fs/promises';
import { join } from 'path';
import { verifyAccessToken } from '../../../../lib/auth';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { imagePath } = await request.json();
    if (!imagePath || !imagePath.startsWith('/uploads/temp/')) {
      return NextResponse.json({ message: '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π –ø—É—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è' }, { status: 400 });
    }

    const filepath = join(process.cwd(), 'public', imagePath);
    try {
      await unlink(filepath);
      console.log(`Deleted temp file: ${filepath}`);
    } catch (error) {
      if (error.code !== 'ENOENT') {
        console.error(`Error deleting temp file ${filepath}:`, error);
      }
    }

    return NextResponse.json({ message: '–í—Ä–µ–º–µ–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–æ' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: profile/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/profile/route.js
–†–ê–ó–ú–ï–†: 9507 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/profile/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';
import { getUserGroup, getLevelProgress } from '../../../lib/userLevels';
import { writeFile, mkdir, unlink, rename } from 'fs/promises';
import { join } from 'path';

export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const usertag = searchParams.get('usertag');
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    if (!usertag) {
      return NextResponse.json({ message: 'Usertag –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' }, { status: 400 });
    }

    // –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ usertag
    const user = await prisma.user.findUnique({
      where: { usertag },
      select: {
        id: true,
        name: true,
        usertag: true,
        email: true,
        avatar: true,
        banner: true,
        bio: true,
        location: true,
        website: true,
        experiencePoints: true,
        createdAt: true,
        profileVisibility: true,
      }
    });

    if (!user) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    const isOwnProfile = decoded.userId === user.id;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥—Ä—É–∂–±—É –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –≤–∏–¥–∏–º–æ—Å—Ç–∏ –ø–æ—Å—Ç–æ–≤
    let canViewPosts = false;
    
    if (isOwnProfile) {
      canViewPosts = true;
    } else {
      switch (user.profileVisibility) {
        case 'PUBLIC':
          canViewPosts = true;
          break;
        case 'FRIENDS_ONLY':
          const friendship = await prisma.friendship.findFirst({
            where: {
              OR: [
                { user1Id: decoded.userId, user2Id: user.id },
                { user1Id: user.id, user2Id: decoded.userId }
              ]
            }
          });
          canViewPosts = !!friendship;
          break;
        case 'PRIVATE':
          canViewPosts = false;
          break;
      }
    }

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞
    let posts = [];
    if (canViewPosts) {
      posts = await prisma.post.findMany({
        where: { authorId: user.id },
        orderBy: { createdAt: 'desc' },
        include: {
          author: {
            select: { id: true, name: true, avatar: true }
          },
          likes: {
            select: { userId: true }
          },
          comments: {
            select: { id: true }
          }
        }
      });
    }

    // –ü–æ–ª—É—á–∞–µ–º –í–°–ï –æ—Ç–ø—É—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —á–µ—Ä–µ–∑ vacation_members
    const vacationMembers = await prisma.vacationMember.findMany({
      where: {
        userId: user.id,
        status: 'ACCEPTED'
      },
      include: {
        vacation: {
          include: {
            user: {
              select: { id: true, name: true, avatar: true }
            },
            members: {
              where: { status: 'ACCEPTED' },
              include: {
                user: {
                  select: { id: true, name: true, avatar: true }
                }
              }
            },
            _count: {
              select: {
                activities: true,
                memories: true,
                members: true
              }
            }
          }
        }
      },
      orderBy: { vacation: { startDate: 'desc' } }
    });

    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —Ñ–æ—Ä–º–∞—Ç –æ—Ç–ø—É—Å–∫–æ–≤
    const vacations = vacationMembers.map(member => ({
      ...member.vacation,
      userRole: member.role,
      isOwner: member.role === 'owner'
    }));

    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± —É—Ä–æ–≤–Ω–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const userGroup = await getUserGroup(user.id);
    const levelProgress = await getLevelProgress(user.id);

    // –§–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–ª–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å
    const userProfile = {
      ...user,
      posts,
      vacations,
      canViewPosts,
      userGroup,
      levelProgress
    };

    return NextResponse.json(userProfile);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

export async function PUT(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { name, usertag, bio, location, website, profileVisibility, avatar, banner } = await request.json();

    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    if (!name || !usertag) {
      return NextResponse.json(
        { message: '–ò–º—è –∏ usertag –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' },
        { status: 400 }
      );
    }

    if (usertag.length < 3 || usertag.length > 20) {
      return NextResponse.json(
        { message: 'Usertag –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 3 –¥–æ 20 —Å–∏–º–≤–æ–ª–æ–≤' },
        { status: 400 }
      );
    }

    if (!/^[a-z0-9-]+$/.test(usertag)) {
      return NextResponse.json(
        { message: 'Usertag –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ –ª–∞—Ç–∏–Ω—Å–∫–∏–µ –±—É–∫–≤—ã –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ, —Ü–∏—Ñ—Ä—ã –∏ –¥–µ—Ñ–∏—Å—ã' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–Ω—è—Ç –ª–∏ usertag –¥—Ä—É–≥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
    const existingUser = await prisma.user.findFirst({
      where: {
        usertag,
        NOT: {
          id: decoded.userId
        }
      }
    });

    if (existingUser) {
      return NextResponse.json(
        { message: '–≠—Ç–æ—Ç usertag —É–∂–µ –∑–∞–Ω—è—Ç' },
        { status: 409 }
      );
    }

    // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –ø—Ä–æ—Ñ–∏–ª—å –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ä—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    const currentUser = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: { avatar: true, banner: true }
    });

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    const updateData = { name, usertag, bio, location, website, profileVisibility };
    
    if (avatar && avatar.startsWith('/uploads/temp/')) {
      const filename = avatar.split('/').pop();
      const tempPath = join(process.cwd(), 'public', avatar);
      const finalPath = join(process.cwd(), 'public', 'uploads', 'avatars', filename);
      await mkdir(join(process.cwd(), 'public', 'uploads', 'avatars'), { recursive: true });
      
      // –ü–µ—Ä–µ–º–µ—â–∞–µ–º —Ñ–∞–π–ª
      try {
        await rename(tempPath, finalPath);
        updateData.avatar = `/uploads/avatars/${filename}`;
        
        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –∞–≤–∞—Ç–∞—Ä, –µ—Å–ª–∏ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        if (currentUser.avatar && currentUser.avatar.startsWith('/uploads/avatars/')) {
          const oldAvatarPath = join(process.cwd(), 'public', currentUser.avatar);
          try {
            await unlink(oldAvatarPath);
            console.log(`Deleted old avatar: ${oldAvatarPath}`);
          } catch (error) {
            if (error.code !== 'ENOENT') {
              console.error(`Error deleting old avatar ${oldAvatarPath}:`, error);
            }
          }
        }
      } catch (error) {
        console.error(`Error moving avatar ${tempPath}:`, error);
        return NextResponse.json(
          { message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∞–≤–∞—Ç–∞—Ä–∞' },
          { status: 500 }
        );
      }
    }

    if (banner && banner.startsWith('/uploads/temp/')) {
      const filename = banner.split('/').pop();
      const tempPath = join(process.cwd(), 'public', banner);
      const finalPath = join(process.cwd(), 'public', 'uploads', 'banners', filename);
      await mkdir(join(process.cwd(), 'public', 'uploads', 'banners'), { recursive: true });
      
      // –ü–µ—Ä–µ–º–µ—â–∞–µ–º —Ñ–∞–π–ª
      try {
        await rename(tempPath, finalPath);
        updateData.banner = `/uploads/banners/${filename}`;
        
        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –±–∞–Ω–Ω–µ—Ä, –µ—Å–ª–∏ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        if (currentUser.banner && currentUser.banner.startsWith('/uploads/banners/')) {
          const oldBannerPath = join(process.cwd(), 'public', currentUser.banner);
          try {
            await unlink(oldBannerPath);
            console.log(`Deleted old banner: ${oldBannerPath}`);
          } catch (error) {
            if (error.code !== 'ENOENT') {
              console.error(`Error deleting old banner ${oldBannerPath}:`, error);
            }
          }
        }
      } catch (error) {
        console.error(`Error moving banner ${tempPath}:`, error);
        return NextResponse.json(
          { message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –±–∞–Ω–Ω–µ—Ä–∞' },
          { status: 500 }
        );
      }
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ—Ñ–∏–ª—å
    const updatedUser = await prisma.user.update({
      where: { id: decoded.userId },
      data: updateData,
      select: {
        id: true,
        name: true,
        usertag: true,
        email: true,
        avatar: true,
        banner: true,
        bio: true,
        location: true,
        website: true,
        profileVisibility: true,
        createdAt: true
      }
    });

    return NextResponse.json(updatedUser);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è:', error);
    
    if (error.code === 'P2002') {
      return NextResponse.json(
        { message: '–≠—Ç–æ—Ç usertag —É–∂–µ –∑–∞–Ω—è—Ç' },
        { status: 409 }
      );
    }

    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: profile/upload/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/profile/upload/route.js
–†–ê–ó–ú–ï–†: 2575 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/profile/upload/route.js
import { NextResponse } from 'next/server';
import { writeFile, mkdir, unlink } from 'fs/promises';
import { join } from 'path';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const formData = await request.formData();
    const image = formData.get('image');
    const type = formData.get('type'); // 'avatar' –∏–ª–∏ 'banner'

    if (!image || !type) {
      return NextResponse.json(
        { message: '–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ' },
        { status: 400 }
      );
    }

    if (!image.type.startsWith('image/')) {
      return NextResponse.json(
        { message: '–§–∞–π–ª –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º' },
        { status: 400 }
      );
    }

    if (image.size > 5 * 1024 * 1024) {
      return NextResponse.json(
        { message: '–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –Ω–µ –¥–æ–ª–∂–µ–Ω –ø—Ä–µ–≤—ã—à–∞—Ç—å 5MB' },
        { status: 400 }
      );
    }

    // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
    const tempDir = join(process.cwd(), 'public', 'uploads', 'temp');
    await mkdir(tempDir, { recursive: true });

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞
    const timestamp = Date.now();
    const fileExtension = image.name.split('.').pop();
    const filename = `${decoded.userId}-${type}-${timestamp}.${fileExtension}`;
    const filepath = join(tempDir, filename);
    const tempPath = `/uploads/temp/${filename}`;

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª
    const bytes = await image.arrayBuffer();
    const buffer = Buffer.from(bytes);
    await writeFile(filepath, buffer);

    // –ü–ª–∞–Ω–∏—Ä—É–µ–º —É–¥–∞–ª–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ —á–µ—Ä–µ–∑ 5 –º–∏–Ω—É—Ç
    setTimeout(async () => {
      try {
        await unlink(filepath);
        console.log(`Deleted temp file: ${filepath}`);
      } catch (error) {
        console.error(`Error deleting temp file ${filepath}:`, error);
      }
    }, 5 * 60 * 1000); // 5 –º–∏–Ω—É—Ç

    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –ø—É—Ç—å
    return NextResponse.json({
      message: '–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ',
      tempPath
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: users/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/users/route.js
–†–ê–ó–ú–ï–†: 2722 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/users/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const search = searchParams.get('search') || '';
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');
    const skip = (page - 1) * limit;

    // –ë–∞–∑–æ–≤—ã–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –ø–æ–∏—Å–∫–∞
    const where = {
      OR: [
        { name: { contains: search, mode: 'insensitive' } },
        { usertag: { contains: search, mode: 'insensitive' } }
      ],
      // –ò—Å–∫–ª—é—á–∞–µ–º —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      NOT: {
        id: decoded.userId
      }
    };

    console.log('üîç –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å —É—Å–ª–æ–≤–∏—è–º–∏:', { search, page, limit });

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π - –¢–û–õ–¨–ö–û –û–°–ù–û–í–ù–´–ï –î–ê–ù–ù–´–ï
    const users = await prisma.user.findMany({
      where,
      select: {
        id: true,
        name: true,
        usertag: true,
        avatar: true,
        bio: true,
        location: true,
        createdAt: true,
        profileVisibility: true,
        // –£–ë–†–ê–õ —Å–ª–æ–∂–Ω—ã–µ –ø–æ–¥—Å—á–µ—Ç—ã - –æ–Ω–∏ –Ω–µ –Ω—É–∂–Ω—ã –¥–ª—è –æ–±—â–µ–≥–æ —Å–ø–∏—Å–∫–∞
        _count: {
          select: {
            posts: true,
            // –¢–æ–ª—å–∫–æ –±–∞–∑–æ–≤—ã–µ —Å—á–µ—Ç—á–∏–∫–∏
            friendsAsUser1: true,
            friendsAsUser2: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      skip,
      take: limit
    });

    console.log('‚úÖ –ù–∞–π–¥–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:', users.length);

    // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞
    const formattedUsers = users.map(user => ({
      ...user,
      // –£–ë–†–ê–õ vacationCount - –æ–Ω –Ω–µ –Ω—É–∂–µ–Ω –≤ –æ–±—â–µ–º —Å–ø–∏—Å–∫–µ
      postCount: user._count.posts,
      friendCount: user._count.friendsAsUser1 + user._count.friendsAsUser2
    }));

    // –ü–æ–ª—É—á–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
    const total = await prisma.user.count({ where });

    return NextResponse.json({
      users: formattedUsers,
      pagination: {
        page,
        limit,
        total,
        hasNext: skip + users.length < total,
        hasPrev: page > 1
      }
    });

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/activities/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/activities/route.js
–†–ê–ó–ú–ï–†: 2035 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/activities/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

export async function GET(request, { params }) {
  try {
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ –æ—Ç–ø—É—Å–∫—É
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: id,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'ACCEPTED' } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    // –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
    const activities = await prisma.activity.findMany({
      where: { vacationId: id },
      orderBy: { date: 'asc' },
      include: {
        location: {
          select: { id: true, name: true, address: true }
        },
        participants: {
          include: {
            user: {
              select: { id: true, name: true, avatar: true }
            }
          }
        }
      }
    });

    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    const formattedActivities = activities.map(activity => ({
      ...activity,
      // –ë–µ—Ä–µ–º –ø–µ—Ä–≤–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞ –∫–∞–∫ "–∞–≤—Ç–æ—Ä–∞" –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
      author: activity.participants[0]?.user || null,
      participants: activity.participants.map(p => p.user)
    }));

    return NextResponse.json(formattedActivities);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–µ–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/gallery/GalleryFallback.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/gallery/GalleryFallback.js
–†–ê–ó–ú–ï–†: 1817 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/components/vacation/GalleryFallback.js
'use client';

export default function GalleryFallback({ error, onRetry }) {
  return (
    <div className="bg-white rounded-2xl shadow-lg p-6">
      <div className="text-center py-12">
        <div className="w-20 h-20 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-6">
          <span className="text-3xl">‚ö†Ô∏è</span>
        </div>
        
        <h3 className="text-xl font-semibold text-gray-900 mb-3">
          –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –≥–∞–ª–µ—Ä–µ—é
        </h3>
        
        {error && (
          <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6 max-w-md mx-auto">
            <p className="text-red-700 text-sm font-mono break-words">
              {typeof error === 'string' ? error : JSON.stringify(error)}
            </p>
          </div>
        )}
        
        <div className="flex flex-col sm:flex-row gap-3 justify-center">
          <button
            onClick={onRetry}
            className="bg-emerald-500 text-white px-6 py-3 rounded-lg hover:bg-emerald-600 transition duration-200 font-semibold"
          >
            –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞
          </button>
          
          <button
            onClick={() => window.location.reload()}
            className="bg-gray-500 text-white px-6 py-3 rounded-lg hover:bg-gray-600 transition duration-200 font-semibold"
          >
            –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É
          </button>
        </div>
        
        <div className="mt-6 text-sm text-gray-500">
          <p>–ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ:</p>
          <ul className="mt-2 space-y-1">
            <li>‚Ä¢ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É</li>
            <li>‚Ä¢ –î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π</li>
            <li>‚Ä¢ –ö–æ–Ω—Å–æ–ª—å –±—Ä–∞—É–∑–µ—Ä–∞ –¥–ª—è –¥–µ—Ç–∞–ª–µ–π</li>
          </ul>
        </div>
      </div>
    </div>
  );
}



================================================================================
–§–ê–ô–õ: vacations/[id]/gallery/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/gallery/route.js
–†–ê–ó–ú–ï–†: 4385 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/gallery/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function GET(request, { params }) {
  try {
    const { id: vacationId } = await params;
    const { searchParams } = new URL(request.url);
    const view = searchParams.get('view') || 'all';
    
    console.log('üîÑ –ó–∞–ø—Ä–æ—Å –≥–∞–ª–µ—Ä–µ–∏:', { vacationId, view });

    const accessToken = request.cookies.get('accessToken')?.value;
    if (!accessToken) {
      console.log('‚ùå –ù–µ—Ç access token');
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      console.log('‚ùå –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π —Ç–æ–∫–µ–Ω');
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –æ—Ç–ø—É—Å–∫—É
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: vacationId,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'ACCEPTED' } } }
        ]
      }
    });

    if (!vacationAccess) {
      console.log('‚ùå –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω –¥–ª—è vacation:', vacationId);
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω' }, { status: 403 });
    }

    // –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –∑–∞–ø—Ä–æ—Å memories
    let where = { vacationId };

    if (view === 'capture') {
      where.captureType = { in: ['DAILY_MOMENT', 'ACTIVITY_MOMENT'] };
    } else if (view === 'activities') {
      where.activityId = { not: null };
      where.captureType = null;
    }

    console.log('üìä –£—Å–ª–æ–≤–∏—è –∑–∞–ø—Ä–æ—Å–∞:', where);

    const memories = await prisma.memory.findMany({
      where,
      include: {
        author: {
          select: { id: true, name: true, avatar: true, usertag: true }
        },
        activity: {
          select: { id: true, title: true }
        },
        location: {
          select: { id: true, name: true }
        }
      },
      orderBy: { takenAt: 'desc' }
    });

    console.log('‚úÖ –ù–∞–π–¥–µ–Ω–æ –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏–π:', memories.length);

    // –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π
    let groupedMemories = {};

    try {
      if (view === 'all') {
        const byDay = {};
        memories.forEach(memory => {
          if (!memory || !memory.takenAt) return;
          
          try {
            const dateKey = memory.takenAt.toISOString().split('T')[0];
            if (!byDay[dateKey]) {
              byDay[dateKey] = [];
            }
            byDay[dateKey].push(memory);
          } catch (dateError) {
            console.warn('‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞—Ç—ã:', memory.takenAt);
          }
        });
        groupedMemories.byDay = byDay;
      } else if (view === 'activities') {
        const byActivity = {};
        memories.forEach(memory => {
          if (!memory) return;
          
          const activityKey = memory.activityId || 'no-activity';
          if (!byActivity[activityKey]) {
            byActivity[activityKey] = {
              title: memory.activity?.title || '–ë–µ–∑ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏',
              memories: []
            };
          }
          byActivity[activityKey].memories.push(memory);
        });
        groupedMemories.byActivity = byActivity;
      } else {
        groupedMemories.memories = memories;
      }
    } catch (groupingError) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏:', groupingError);
      // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç—ã–µ –¥–∞–Ω–Ω—ã–µ –≤–º–µ—Å—Ç–æ –æ—à–∏–±–∫–∏
      groupedMemories = view === 'all' ? { byDay: {} } : 
                       view === 'activities' ? { byActivity: {} } : 
                       { memories: [] };
    }

    const response = {
      view,
      memories: groupedMemories,
      total: memories.length
    };

    console.log('üì¶ –û—Ç–≤–µ—Ç –≥–∞–ª–µ—Ä–µ–∏:', { 
      view, 
      total: memories.length,
      groupedKeys: Object.keys(groupedMemories)
    });

    return NextResponse.json(response);

  } catch (error) {
    console.error('‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –≥–∞–ª–µ—Ä–µ–∏:', error);
    
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –±–µ–∑–æ–ø–∞—Å–Ω—ã–π –æ—Ç–≤–µ—Ç –≤–º–µ—Å—Ç–æ –æ—à–∏–±–∫–∏
    return NextResponse.json({
      view: new URL(request.url).searchParams.get('view') || 'all',
      memories: { byDay: {}, byActivity: {}, memories: [] },
      total: 0,
      error: '–í—Ä–µ–º–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏'
    }, { status: 200 }); // –í–æ–∑–≤—Ä–∞—â–∞–µ–º 200 —á—Ç–æ–±—ã —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥ –Ω–µ –ø–∞–¥–∞–ª
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/invite/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/invite/route.js
–†–ê–ó–ú–ï–†: 3568 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/invite/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';
import { randomBytes } from 'crypto';

export async function POST(request, { params }) {
  try {
    // Await params –¥–ª—è Next.js 15
    const { id: vacationId } = await params;
    const { email } = await request.json();
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å - –≤–ª–∞–¥–µ–ª–µ—Ü –æ—Ç–ø—É—Å–∫–∞
    const vacation = await prisma.vacation.findFirst({
      where: {
        id: vacationId,
        userId: decoded.userId
      },
      include: {
        user: {
          select: { name: true }
        }
      }
    });

    if (!vacation) {
      return NextResponse.json({ message: '–û—Ç–ø—É—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ—Ç –ø—Ä–∞–≤' }, { status: 404 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email
    const invitedUser = await prisma.user.findUnique({
      where: { email }
    });

    if (!invitedUser) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω –ª–∏ —É–∂–µ —ç—Ç–æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    const existingInvitation = await prisma.invitation.findFirst({
      where: {
        vacationId,
        email
      }
    });

    if (existingInvitation) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω' }, { status: 409 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–º
    const existingMember = await prisma.vacationMember.findFirst({
      where: {
        vacationId,
        userId: invitedUser.id
      }
    });

    if (existingMember) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —è–≤–ª—è–µ—Ç—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–º' }, { status: 409 });
    }

    // –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
    const token = randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 –¥–Ω–µ–π

    const invitation = await prisma.invitation.create({
      data: {
        vacationId,
        email,
        token,
        invitedById: decoded.userId,
        expiresAt
      }
    });

    // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –ø—Ä–∏–≥–ª–∞—à–µ–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const notification = await prisma.notification.create({
      data: {
        userId: invitedUser.id,
        type: 'invitation',
        title: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –æ—Ç–ø—É—Å–∫',
        message: `${vacation.user.name} –ø—Ä–∏–≥–ª–∞—Å–∏–ª(–∞) –≤–∞—Å –≤ –æ—Ç–ø—É—Å–∫ "${vacation.title}"`,
        data: {
          invitationId: invitation.id,
          vacationId: vacation.id,
          invitedByName: vacation.user.name,
          vacationTitle: vacation.title
        }
      },
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            avatar: true 
          }
        }
      }
    });

    return NextResponse.json({ 
      message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ',
      invitation: {
        id: invitation.id,
        email: invitation.email,
        status: invitation.status
      },
      notification
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/invite-by-usertag/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/invite-by-usertag/route.js
–†–ê–ó–ú–ï–†: 3318 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/invite-by-usertag/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';
import { randomBytes } from 'crypto';

export async function POST(request, { params }) {
  try {
    const { id: vacationId } = await params;
    const { usertag } = await request.json();
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –≤–ª–∞–¥–µ–ª—å—Ü–∞
    const vacation = await prisma.vacation.findFirst({
      where: {
        id: vacationId,
        userId: decoded.userId
      },
      include: {
        user: {
          select: { name: true }
        }
      }
    });

    if (!vacation) {
      return NextResponse.json({ message: '–û—Ç–ø—É—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ—Ç –ø—Ä–∞–≤' }, { status: 404 });
    }

    // –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ usertag
    const invitedUser = await prisma.user.findUnique({
      where: { usertag }
    });

    if (!invitedUser) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º usertag –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω –ª–∏ —É–∂–µ
    const existingInvitation = await prisma.invitation.findFirst({
      where: {
        vacationId,
        email: invitedUser.email
      }
    });

    if (existingInvitation) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω' }, { status: 409 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —É–∂–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–º
    const existingMember = await prisma.vacationMember.findFirst({
      where: {
        vacationId,
        userId: invitedUser.id
      }
    });

    if (existingMember) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —è–≤–ª—è–µ—Ç—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–º' }, { status: 409 });
    }

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–æ–∫–µ–Ω –¥–ª—è –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è
    const token = randomBytes(32).toString('hex');

    // –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
    const invitation = await prisma.invitation.create({
      data: {
        vacationId,
        email: invitedUser.email,
        token: token,
        invitedById: decoded.userId,
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 –¥–Ω–µ–π
      }
    });

    // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
    await prisma.notification.create({
      data: {
        userId: invitedUser.id,
        type: 'invitation',
        title: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –æ—Ç–ø—É—Å–∫',
        message: `${vacation.user.name} –ø—Ä–∏–≥–ª–∞—Å–∏–ª(–∞) –≤–∞—Å –≤ –æ—Ç–ø—É—Å–∫ "${vacation.title}"`,
        data: {
          invitationId: invitation.id,
          vacationId: vacation.id,
          invitedByName: vacation.user.name,
          vacationTitle: vacation.title
        }
      }
    });

    return NextResponse.json({ 
      message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ',
      user: {
        id: invitedUser.id,
        name: invitedUser.name,
        usertag: invitedUser.usertag
      }
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è –ø–æ usertag:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/invite-friend/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/invite-friend/route.js
–†–ê–ó–ú–ï–†: 4411 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/invite-friend/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';
import { randomBytes } from 'crypto';

export async function POST(request, { params }) {
  try {
    const { id: vacationId } = await params;
    const { friendId } = await request.json();
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å - –≤–ª–∞–¥–µ–ª–µ—Ü –æ—Ç–ø—É—Å–∫–∞
    const vacation = await prisma.vacation.findFirst({
      where: {
        id: vacationId,
        userId: decoded.userId
      },
      include: {
        user: {
          select: { name: true }
        }
      }
    });

    if (!vacation) {
      return NextResponse.json({ message: '–û—Ç–ø—É—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ—Ç –ø—Ä–∞–≤' }, { status: 404 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ friendId - –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –¥—Ä—É–≥
    const friendship = await prisma.friendship.findFirst({
      where: {
        OR: [
          { user1Id: decoded.userId, user2Id: friendId },
          { user1Id: friendId, user2Id: decoded.userId }
        ]
      }
    });

    if (!friendship) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –≤–∞—à–∏–º –¥—Ä—É–≥–æ–º' }, { status: 403 });
    }

    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –¥—Ä—É–≥–µ
    const friend = await prisma.user.findUnique({
      where: { id: friendId },
      select: { id: true, name: true, email: true, usertag: true }
    });

    if (!friend) {
      return NextResponse.json({ message: '–î—Ä—É–≥ –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–º
    const existingMember = await prisma.vacationMember.findFirst({
      where: {
        vacationId,
        userId: friend.id,
        status: 'ACCEPTED'
      }
    });

    if (existingMember) {
      return NextResponse.json({ 
        message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —è–≤–ª—è–µ—Ç—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–º —ç—Ç–æ–≥–æ –æ—Ç–ø—É—Å–∫–∞' 
      }, { status: 409 });
    }

    // –ê–¢–û–ú–ê–†–ù–ê–Ø –û–ü–ï–†–ê–¶–ò–Ø: —Å–æ–∑–¥–∞–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
    const invitation = await prisma.invitation.upsert({
      where: {
        vacationId_email: {
          vacationId,
          email: friend.email
        }
      },
      update: {
        // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –±—ã–ª–æ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ/–∏—Å—Ç–µ–∫–ª–æ
        token: randomBytes(32).toString('hex'),
        invitedById: decoded.userId,
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
        status: 'pending',
        createdAt: new Date()
      },
      create: {
        vacationId,
        email: friend.email,
        token: randomBytes(32).toString('hex'),
        invitedById: decoded.userId,
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
        status: 'pending'
      }
    });

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –±—ã–ª–æ –ª–∏ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ —á—Ç–æ —Å–æ–∑–¥–∞–Ω–æ –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–æ –∏–∑ –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Å—Ç–∞—Ç—É—Å–∞
    const shouldNotify = invitation.status === 'pending' && 
                        invitation.expiresAt > new Date();

    if (shouldNotify) {
      // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –ø—Ä–∏–≥–ª–∞—à–µ–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      await prisma.notification.create({
        data: {
          userId: friend.id,
          type: 'invitation',
          title: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –æ—Ç–ø—É—Å–∫',
          message: `${vacation.user.name} –ø—Ä–∏–≥–ª–∞—Å–∏–ª(–∞) –≤–∞—Å –≤ –æ—Ç–ø—É—Å–∫ "${vacation.title}"`,
          data: {
            invitationId: invitation.id,
            vacationId: vacation.id,
            invitedByName: vacation.user.name,
            vacationTitle: vacation.title
          }
        }
      });
    }

    return NextResponse.json({ 
      message: shouldNotify ? '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ' : '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ',
      user: {
        id: friend.id,
        name: friend.name,
        usertag: friend.usertag
      }
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è –¥—Ä—É–≥—É:', error);
    
    if (error.code === 'P2002') {
      return NextResponse.json({ 
        message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç' 
      }, { status: 409 });
    }
    
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/members/[memberId]/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/members/[memberId]/route.js
–†–ê–ó–ú–ï–†: 4801 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/members/[memberId]/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function DELETE(request, { params }) {
  try {
    const { id: vacationId, memberId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    console.log('üîß –£–¥–∞–ª–µ–Ω–∏–µ —É—á–∞—Å—Ç–Ω–∏–∫–∞:', { vacationId, memberId, userId: decoded.userId });

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å - –≤–ª–∞–¥–µ–ª–µ—Ü –æ—Ç–ø—É—Å–∫–∞
    const vacation = await prisma.vacation.findFirst({
      where: {
        id: vacationId,
        userId: decoded.userId // –¢–æ–ª—å–∫–æ –≤–ª–∞–¥–µ–ª–µ—Ü –º–æ–∂–µ—Ç —É–¥–∞–ª—è—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
      },
      include: {
        members: {
          include: {
            user: {
              select: {
                id: true,
                name: true
              }
            }
          }
        }
      }
    });

    if (!vacation) {
      return NextResponse.json({ 
        message: '–û—Ç–ø—É—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–∞–º–∏' 
      }, { status: 404 });
    }

    // –ù–∞—Ö–æ–¥–∏–º —É—á–∞—Å—Ç–Ω–∏–∫–∞ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è
    const memberToDelete = vacation.members.find(m => m.id === memberId);
    if (!memberToDelete) {
      return NextResponse.json({ message: '–£—á–∞—Å—Ç–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    // –ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –≤–ª–∞–¥–µ–ª—å—Ü–∞
    if (memberToDelete.userId === decoded.userId) {
      return NextResponse.json({ 
        message: '–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å —Å–µ–±—è –∏–∑ –æ—Ç–ø—É—Å–∫–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é —É–¥–∞–ª–µ–Ω–∏—è –æ—Ç–ø—É—Å–∫–∞.' 
      }, { status: 400 });
    }

    // –£–¥–∞–ª—è–µ–º —É—á–∞—Å—Ç–Ω–∏–∫–∞
    await prisma.vacationMember.delete({
      where: { id: memberId }
    });

    console.log('‚úÖ –£—á–∞—Å—Ç–Ω–∏–∫ —É–¥–∞–ª–µ–Ω:', memberToDelete.user.name);

    // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    try {
      await prisma.notification.create({
        data: {
          userId: memberToDelete.userId,
          type: 'info',
          title: '–£–¥–∞–ª–µ–Ω –∏–∑ –æ—Ç–ø—É—Å–∫–∞',
          message: `–í–∞—Å —É–¥–∞–ª–∏–ª–∏ –∏–∑ –æ—Ç–ø—É—Å–∫–∞ "${vacation.title}"`,
          data: {
            vacationId: vacationId,
            vacationTitle: vacation.title,
            removedByName: decoded.name || '–í–ª–∞–¥–µ–ª–µ—Ü –æ—Ç–ø—É—Å–∫–∞'
          }
        }
      });
    } catch (notificationError) {
      console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ:', notificationError);
    }

    return NextResponse.json({ 
      message: '–£—á–∞—Å—Ç–Ω–∏–∫ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω',
      removedUser: {
        id: memberToDelete.userId,
        name: memberToDelete.user.name
      }
    });

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–∞:', error);
    
    if (error.code === 'P2025') {
      return NextResponse.json({ message: '–£—á–∞—Å—Ç–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }
    
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

// –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–æ–ª–∏ —É—á–∞—Å—Ç–Ω–∏–∫–∞
export async function PATCH(request, { params }) {
  try {
    const { id: vacationId, memberId } = await params;
    const { role } = await request.json();
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å - –≤–ª–∞–¥–µ–ª–µ—Ü –æ—Ç–ø—É—Å–∫–∞
    const vacation = await prisma.vacation.findFirst({
      where: {
        id: vacationId,
        userId: decoded.userId
      }
    });

    if (!vacation) {
      return NextResponse.json({ 
        message: '–û—Ç–ø—É—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ —É –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–∞–º–∏' 
      }, { status: 404 });
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–æ–ª—å —É—á–∞—Å—Ç–Ω–∏–∫–∞
    const updatedMember = await prisma.vacationMember.update({
      where: { id: memberId },
      data: { role },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            avatar: true
          }
        }
      }
    });

    return NextResponse.json({
      message: '–†–æ–ª—å —É—á–∞—Å—Ç–Ω–∏–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞',
      member: updatedMember
    });

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ä–æ–ª–∏ —É—á–∞—Å—Ç–Ω–∏–∫–∞:', error);
    
    if (error.code === 'P2025') {
      return NextResponse.json({ message: '–£—á–∞—Å—Ç–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }
    
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/members/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/members/route.js
–†–ê–ó–ú–ï–†: 1629 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/members/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

export async function GET(request, { params }) {
  try {
    // Await params –¥–ª—è Next.js 15
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ –æ—Ç–ø—É—Å–∫—É
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: id,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'ACCEPTED' } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    const members = await prisma.vacationMember.findMany({
      where: { vacationId: id },
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            email: true, 
            avatar: true 
          }
        }
      },
      orderBy: { createdAt: 'asc' }
    });

    return NextResponse.json(members);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/memories/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/memories/route.js
–†–ê–ó–ú–ï–†: 3602 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/memories/route.ts

import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { cookies } from 'next/headers';

export async function GET(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  // –ñ–¥—ë–º params ‚Äî —Ç–µ–ø–µ—Ä—å —ç—Ç–æ Promise
  const { id } = await params;

  // –ñ–¥—ë–º cookies() ‚Äî —Ç–µ–ø–µ—Ä—å —ç—Ç–æ —Ç–æ–∂–µ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
  const cookieStore = await cookies();
  const accessToken = cookieStore.get('accessToken')?.value;

  if (!accessToken) {
    return NextResponse.json(
      { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
      { status: 401 }
    );
  }

  try {
    const memories = await prisma.memory.findMany({
      where: { vacationId: id },
      include: {
        author: {
          select: {
            id: true,
            name: true,
            avatar: true,
            usertag: true,
          },
        },
        likes: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                avatar: true,
              },
            },
          },
        },
        comments: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                avatar: true,
              },
            },
          },
          orderBy: { createdAt: 'asc' },
        },
      },
      orderBy: { takenAt: 'desc' },
    });

    return NextResponse.json(memories, { status: 200 });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏–π:', error);
    return NextResponse.json(
      { message: '–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏–π' },
      { status: 500 }
    );
  }
}

// –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: POST –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏—è
export async function POST(
  request: Request,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id: vacationId } = await params;
  const cookieStore = await cookies();
  const accessToken = cookieStore.get('accessToken')?.value;

  if (!accessToken) {
    return NextResponse.json(
      { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
      { status: 401 }
    );
  }

  try {
    const body = await request.json();
    const {
      title,
      description,
      imageUrl,
      isCapture,
      locationId,
      activityId,
      tags,
      takenAt,
    } = body;

    // –ü—Ä–æ–≤–µ—Ä–∫–∞: –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–æ–º –æ—Ç–ø—É—Å–∫–∞
    const member = await prisma.vacationMember.findUnique({
      where: {
        vacationId_userId: {
          vacationId,
          userId: accessToken, // –≤—Ä–µ–º–µ–Ω–Ω–æ ‚Äî –ø–æ—Ç–æ–º –±—É–¥–µ—Ç JWT —Å userId
        },
      },
    });

    if (!member || member.status !== 'ACCEPTED') {
      return NextResponse.json(
        { message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω: –≤—ã –Ω–µ —É—á–∞—Å—Ç–Ω–∏–∫ —ç—Ç–æ–≥–æ –æ—Ç–ø—É—Å–∫–∞' },
        { status: 403 }
      );
    }

    const memory = await prisma.memory.create({
      data: {
        title,
        description: description ?? null,
        imageUrl,
        isCapture: isCapture ?? false,
        locationId: locationId ?? null,
        activityId: activityId ?? null,
        tags: tags ?? [],
        takenAt: new Date(takenAt),
        vacationId,
        authorId: accessToken, // –∑–∞–º–µ–Ω–∏—Ç—å –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π userId –∏–∑ JWT
      },
      include: {
        author: {
          select: { id: true, name: true, avatar: true },
        },
      },
    });

    return NextResponse.json(memory, { status: 201 });
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏—è' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/route.js
–†–ê–ó–ú–ï–†: 3563 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function GET(request, { params }) {
  try {
    const { id } = await params;
    console.log('üîç –ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç–ø—É—Å–∫–∞ —Å ID:', id);
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      console.log('‚ùå –ù–µ—Ç access token');
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      console.log('‚ùå –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π —Ç–æ–∫–µ–Ω');
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    console.log('üë§ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', decoded.userId);

    const vacation = await prisma.vacation.findFirst({
      where: {
        id: id,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'ACCEPTED' } } }
        ]
      },
      include: {
        user: {
          select: { id: true, name: true, email: true, avatar: true }
        },
        members: {
          where: { status: 'ACCEPTED' },
          include: {
            user: {
              select: { id: true, name: true, email: true, avatar: true, usertag: true }
            }
          }
        },
        activities: {
          orderBy: { date: 'asc' },
          take: 10,
          include: {
            location: {
              select: { id: true, name: true, address: true }
            },
            participants: {
              include: {
                user: {
                  select: { id: true, name: true, avatar: true }
                }
              }
            }
          }
        },
        memories: {
          orderBy: { createdAt: 'desc' },
          take: 12,
          select: {
            id: true,
            title: true,
            description: true,
            imageUrl: true,
            createdAt: true,
            updatedAt: true,
            isFavorite: true,
            captureType: true, // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ –ø–æ–ª–µ
            locationId: true,
            activityId: true,
            tags: true,
            takenAt: true,
            authorId: true,
            vacationId: true,
            author: {
              select: { id: true, name: true, avatar: true }
            },
            location: {
              select: { id: true, name: true, address: true }
            }
          }
        },
        _count: {
          select: {
            activities: true,
            memories: true,
            members: {
              where: { status: 'ACCEPTED' }
            },
            locations: true
          }
        }
      }
    });

    if (!vacation) {
      console.log('‚ùå –û—Ç–ø—É—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞');
      return NextResponse.json({ message: '–û—Ç–ø—É—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
    const formattedVacation = {
      ...vacation,
      activities: vacation.activities.map(activity => ({
        ...activity,
        author: activity.participants[0]?.user || null,
        participants: activity.participants.map(p => p.user)
      }))
    };

    console.log('‚úÖ –û—Ç–ø—É—Å–∫ –Ω–∞–π–¥–µ–Ω:', formattedVacation.title);
    return NextResponse.json(formattedVacation);

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–ø—É—Å–∫–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/route.js
–†–ê–ó–ú–ï–†: 6741 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

// –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –æ—Ç–ø—É—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json(
        { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' },
        { status: 401 }
      );
    }

    // –ü–æ–ª—É—á–∞–µ–º –æ—Ç–ø—É—Å–∫–∏ –≥–¥–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —è–≤–ª—è–µ—Ç—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–º
    const vacations = await prisma.vacation.findMany({
      where: {
        OR: [
          { userId: decoded.userId }, // –í–ª–∞–¥–µ–ª–µ—Ü
          { members: { some: { userId: decoded.userId, status: 'ACCEPTED' } } } // –£—á–∞—Å—Ç–Ω–∏–∫
        ]
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            avatar: true
          }
        },
        members: {
          where: {
            status: 'ACCEPTED'
          },
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                avatar: true,
                usertag: true
              }
            }
          }
        },
        activities: {
          orderBy: { date: 'asc' },
          include: {
            location: {
              select: { id: true, name: true, address: true }
            },
            participants: {
              include: {
                user: {
                  select: { id: true, name: true, avatar: true }
                }
              }
            }
          }
        },
        memories: {
          orderBy: { createdAt: 'desc' },
          take: 12,
          select: {
            id: true,
            title: true,
            description: true,
            imageUrl: true,
            createdAt: true,
            updatedAt: true,
            isFavorite: true,
            captureType: true, // –ò—Å–ø–æ–ª—å–∑—É–µ–º captureType –≤–º–µ—Å—Ç–æ isCapture
            locationId: true,
            activityId: true,
            tags: true,
            takenAt: true,
            authorId: true,
            vacationId: true,
            author: {
              select: { id: true, name: true, avatar: true }
            },
            location: {
              select: { id: true, name: true, address: true }
            }
          }
        },
        _count: {
          select: {
            activities: true,
            memories: true,
            members: {
              where: { status: 'ACCEPTED' }
            },
            locations: true
          }
        }
      },
      orderBy: { startDate: 'asc' }
    });

    return NextResponse.json(vacations);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–ø—É—Å–∫–æ–≤:', error);
    
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–∫–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–µ–≥–æ –ø–æ–ª—è
    if (error.code === 'P2022') {
      console.error('–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ø–æ–ª–µ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö:', error.meta);
      return NextResponse.json(
        { message: '–û—à–∏–±–∫–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –º–∏–≥—Ä–∞—Ü–∏—é.' },
        { status: 500 }
      );
    }
    
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

// –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –æ—Ç–ø—É—Å–∫
export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json(
        { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' },
        { status: 401 }
      );
    }

    const { title, description, destination, startDate, endDate, coverImage, isPublic = false } = await request.json();

    if (!title || !startDate || !endDate) {
      return NextResponse.json(
        { message: '–ù–∞–∑–≤–∞–Ω–∏–µ –∏ –¥–∞—Ç—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' },
        { status: 400 }
      );
    }

    // –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞—Ç
    const start = new Date(startDate);
    const end = new Date(endDate);
    
    if (start >= end) {
      return NextResponse.json(
        { message: '–î–∞—Ç–∞ –Ω–∞—á–∞–ª–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ä–∞–Ω—å—à–µ –¥–∞—Ç—ã –æ–∫–æ–Ω—á–∞–Ω–∏—è' },
        { status: 400 }
      );
    }

    if (start < new Date()) {
      return NextResponse.json(
        { message: '–î–∞—Ç–∞ –Ω–∞—á–∞–ª–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤ –ø—Ä–æ—à–ª–æ–º' },
        { status: 400 }
      );
    }

    // –°–æ–∑–¥–∞–µ–º –æ—Ç–ø—É—Å–∫
    const vacation = await prisma.vacation.create({
      data: {
        title: title.trim(),
        description: description?.trim() || null,
        destination: destination?.trim() || null,
        startDate: start,
        endDate: end,
        coverImage: coverImage || null,
        isPublic: Boolean(isPublic),
        userId: decoded.userId,
        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ–º –≤–ª–∞–¥–µ–ª—å—Ü–∞ –∫–∞–∫ —É—á–∞—Å—Ç–Ω–∏–∫–∞
        members: {
          create: {
            userId: decoded.userId,
            role: 'OWNER',
            status: 'ACCEPTED',
            joinedAt: new Date()
          }
        }
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true,
            avatar: true
          }
        },
        members: {
          where: {
            status: 'ACCEPTED'
          },
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                avatar: true,
                usertag: true
              }
            }
          }
        },
        activities: {
          orderBy: { date: 'asc' },
          take: 5
        },
        memories: {
          orderBy: { createdAt: 'desc' },
          take: 6,
          select: {
            id: true,
            title: true,
            imageUrl: true,
            captureType: true,
            takenAt: true
          }
        },
        _count: {
          select: {
            activities: true,
            memories: true,
            members: true,
            locations: true
          }
        }
      }
    });

    return NextResponse.json(vacation, { status: 201 });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –æ—Ç–ø—É—Å–∫–∞:', error);
    
    if (error.code === 'P2002') {
      return NextResponse.json(
        { message: '–û—Ç–ø—É—Å–∫ —Å —Ç–∞–∫–∏–º –Ω–∞–∑–≤–∞–Ω–∏–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç' },
        { status: 409 }
      );
    }
    
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}


