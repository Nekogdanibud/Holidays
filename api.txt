–û–¢–ß–ï–¢ –û –§–ê–ô–õ–ê–•
–ü–∞–ø–∫–∞: /OTPUSK/otpusk-app/Holidays/src/app/api
–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è: 10/21/2025, 9:41:33 PM
–í—Å–µ–≥–æ —Ñ–∞–π–ª–æ–≤: 39
–ò—Å–∫–ª—é—á–µ–Ω–Ω—ã–µ –ø–∞–ø–∫–∏: api, node_modules, dist, build, .git, .next, cache, temp
–ò—Å–∫–ª—é—á–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã: global.css, favicon.ico
================================================================================


================================================================================
–§–ê–ô–õ: activities/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/activities/route.js
–†–ê–ó–ú–ï–†: 2924 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/activities/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { title, description, date, type, vacationId, locationId } = await request.json();

    if (!title || !date || !type || !vacationId) {
      return NextResponse.json(
        { message: '–û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è: –Ω–∞–∑–≤–∞–Ω–∏–µ, –¥–∞—Ç–∞, —Ç–∏–ø –∏ ID –æ—Ç–ø—É—Å–∫–∞' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ –æ—Ç–ø—É—Å–∫—É
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: vacationId,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    // –°–æ–∑–¥–∞–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
    const activity = await prisma.activity.create({
      data: {
        title,
        description,
        date: new Date(date),
        type,
        vacationId,
        locationId: locationId || null
      },
      include: {
        location: {
          select: { id: true, name: true, address: true }
        },
        participants: {
          include: {
            user: {
              select: { id: true, name: true, avatar: true }
            }
          }
        }
      }
    });

    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ–º —Å–æ–∑–¥–∞—Ç–µ–ª—è –∫–∞–∫ —É—á–∞—Å—Ç–Ω–∏–∫–∞
    await prisma.activityParticipant.create({
      data: {
        activityId: activity.id,
        userId: decoded.userId,
        status: 'going'
      }
    });

    // –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Å —É—á–∞—Å—Ç–Ω–∏–∫–∞–º–∏
    const updatedActivity = await prisma.activity.findUnique({
      where: { id: activity.id },
      include: {
        location: {
          select: { id: true, name: true, address: true }
        },
        participants: {
          include: {
            user: {
              select: { id: true, name: true, avatar: true }
            }
          }
        }
      }
    });

    // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–ª—è –æ—Ç–≤–µ—Ç–∞
    const formattedActivity = {
      ...updatedActivity,
      author: updatedActivity.participants[0]?.user || null,
      participants: updatedActivity.participants.map(p => p.user)
    };

    return NextResponse.json(formattedActivity, { status: 201 });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: admin/check/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/admin/check/route.js
–†–ê–ó–ú–ï–†: 1037 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: { role: true }
    });

    if (user?.role !== 'ADMIN') {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    return NextResponse.json({ isAdmin: true });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: admin/groups/[id]/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/admin/groups/[id]/route.js
–†–ê–ó–ú–ï–†: 3983 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

async function isAdmin(userId) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true }
  });
  return user?.role === 'ADMIN';
}

export async function GET(request, { params }) {
  try {
    // –û–∂–∏–¥–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    const { id: groupId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    const group = await prisma.group.findUnique({
      where: { id: groupId },
      include: {
        _count: {
          select: {
            userGroups: true
          }
        },
        userGroups: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                usertag: true,
                avatar: true,
                experiencePoints: true
              }
            }
          },
          orderBy: { joinedAt: 'desc' }
        }
      }
    });

    if (!group) {
      return NextResponse.json({ message: '–ì—Ä—É–ø–ø–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞' }, { status: 404 });
    }

    return NextResponse.json({ group });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≥—Ä—É–ø–ø—ã:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

export async function PUT(request, { params }) {
  try {
    // –û–∂–∏–¥–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    const { id: groupId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    const updates = await request.json();

    const validFields = [
      'name', 'description', 'level', 'minPoints', 'maxPoints',
      'color', 'bgColor', 'icon', 'badgeText', 'isExclusive'
    ];

    const updateData = {};
    Object.keys(updates).forEach(key => {
      if (validFields.includes(key)) {
        updateData[key] = updates[key];
      }
    });

    const updatedGroup = await prisma.group.update({
      where: { id: groupId },
      data: updateData
    });

    return NextResponse.json({
      message: '–ì—Ä—É–ø–ø–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∞',
      group: updatedGroup
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≥—Ä—É–ø–ø—ã:', error);
    
    if (error.code === 'P2002') {
      return NextResponse.json(
        { message: '–ì—Ä—É–ø–ø–∞ —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º –∏–ª–∏ —É—Ä–æ–≤–Ω–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç' },
        { status: 409 }
      );
    }

    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

export async function DELETE(request, { params }) {
  try {
    // –û–∂–∏–¥–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    const { id: groupId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    await prisma.group.delete({
      where: { id: groupId }
    });

    return NextResponse.json({ message: '–ì—Ä—É–ø–ø–∞ —É–¥–∞–ª–µ–Ω–∞' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –≥—Ä—É–ø–ø—ã:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: admin/groups/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/admin/groups/route.js
–†–ê–ó–ú–ï–†: 3608 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

async function isAdmin(userId) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true }
  });
  return user?.role === 'ADMIN';
}

export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');
    const search = searchParams.get('search') || '';
    const skip = (page - 1) * limit;

    const where = search ? {
      OR: [
        { name: { contains: search, mode: 'insensitive' } },
        { description: { contains: search, mode: 'insensitive' } }
      ]
    } : {};

    const [groups, total] = await Promise.all([
      prisma.group.findMany({
        where,
        include: {
          _count: {
            select: {
              userGroups: true
            }
          }
        },
        orderBy: { level: 'asc' },
        skip,
        take: limit
      }),
      prisma.group.count({ where })
    ]);

    return NextResponse.json({
      groups,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≥—Ä—É–ø–ø:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    const groupData = await request.json();

    const requiredFields = ['name', 'description', 'level', 'minPoints', 'color', 'icon', 'badgeText'];
    for (const field of requiredFields) {
      if (!groupData[field]) {
        return NextResponse.json(
          { message: `–ü–æ–ª–µ ${field} –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ` },
          { status: 400 }
        );
      }
    }

    const newGroup = await prisma.group.create({
      data: {
        name: groupData.name,
        description: groupData.description,
        level: groupData.level,
        minPoints: groupData.minPoints,
        maxPoints: groupData.maxPoints,
        color: groupData.color,
        bgColor: groupData.bgColor,
        icon: groupData.icon,
        badgeText: groupData.badgeText,
        isExclusive: groupData.isExclusive || false
      }
    });

    return NextResponse.json({
      message: '–ì—Ä—É–ø–ø–∞ —Å–æ–∑–¥–∞–Ω–∞',
      group: newGroup
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –≥—Ä—É–ø–ø—ã:', error);
    
    if (error.code === 'P2002') {
      return NextResponse.json(
        { message: '–ì—Ä—É–ø–ø–∞ —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º –∏–ª–∏ —É—Ä–æ–≤–Ω–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç' },
        { status: 409 }
      );
    }

    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: admin/stats/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/admin/stats/route.js
–†–ê–ó–ú–ï–†: 1391 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

async function isAdmin(userId) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true }
  });
  return user?.role === 'ADMIN';
}

export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    const [totalUsers, totalVacations, activeVacations, totalGroups] = await Promise.all([
      prisma.user.count(),
      prisma.vacation.count(),
      prisma.vacation.count({
        where: {
          startDate: { lte: new Date() },
          endDate: { gte: new Date() }
        }
      }),
      prisma.group.count()
    ]);

    return NextResponse.json({
      totalUsers,
      totalVacations,
      activeVacations,
      totalGroups
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: admin/users/[id]/groups/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/admin/users/[id]/groups/route.js
–†–ê–ó–ú–ï–†: 6471 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../../lib/auth';
import { prisma } from '../../../../../../lib/prisma';

async function isAdmin(userId) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true }
  });
  return user?.role === 'ADMIN';
}

export async function GET(request, { params }) {
  try {
    // –û–∂–∏–¥–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    const { id: userId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    const userGroups = await prisma.userGroup.findMany({
      where: { userId },
      include: {
        group: {
          select: {
            id: true,
            name: true,
            description: true,
            level: true,
            minPoints: true,
            maxPoints: true,
            color: true,
            bgColor: true,
            icon: true,
            badgeText: true,
            isExclusive: true
          }
        }
      }
    });

    return NextResponse.json({ userGroups });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≥—Ä—É–ø–ø –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

export async function POST(request, { params }) {
  try {
    // –û–∂–∏–¥–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    const { id: userId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    const { groupId } = await request.json();

    if (!groupId) {
      return NextResponse.json(
        { message: 'Group ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' },
        { status: 400 }
      );
    }

    console.log('Adding user', userId, 'to group', groupId);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = await prisma.user.findUnique({ 
      where: { id: userId } 
    });

    if (!user) {
      console.log('User not found:', userId);
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –≥—Ä—É–ø–ø—ã
    const group = await prisma.group.findUnique({ 
      where: { id: groupId } 
    });

    if (!group) {
      console.log('Group not found:', groupId);
      return NextResponse.json({ message: '–ì—Ä—É–ø–ø–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞' }, { status: 404 });
    }

    console.log('User and group found, creating userGroup...');

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —Å–æ—Å—Ç–æ–∏—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –≤ —ç—Ç–æ–π –≥—Ä—É–ø–ø–µ
    const existingUserGroup = await prisma.userGroup.findUnique({
      where: {
        userId_groupId: {
          userId,
          groupId
        }
      }
    });

    if (existingUserGroup) {
      return NextResponse.json(
        { message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —Å–æ—Å—Ç–æ–∏—Ç –≤ —ç—Ç–æ–π –≥—Ä—É–ø–ø–µ' },
        { status: 409 }
      );
    }

    // –°–æ–∑–¥–∞–µ–º —Å–≤—è–∑—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –≥—Ä—É–ø–ø–æ–π
    const userGroup = await prisma.userGroup.create({
      data: {
        userId,
        groupId,
        joinedAt: new Date()
      },
      include: {
        group: {
          select: {
            id: true,
            name: true,
            description: true,
            level: true,
            minPoints: true,
            maxPoints: true,
            color: true,
            bgColor: true,
            icon: true,
            badgeText: true,
            isExclusive: true
          }
        }
      }
    });

    console.log('UserGroup created successfully:', userGroup);

    return NextResponse.json({
      message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –¥–æ–±–∞–≤–ª–µ–Ω –≤ –≥—Ä—É–ø–ø—É',
      userGroup
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –≥—Ä—É–ø–ø—É:', error);
    
    if (error.code === 'P2002') {
      return NextResponse.json(
        { message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —Å–æ—Å—Ç–æ–∏—Ç –≤ —ç—Ç–æ–π –≥—Ä—É–ø–ø–µ' },
        { status: 409 }
      );
    }

    if (error.code === 'P2003') {
      return NextResponse.json(
        { message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏–ª–∏ –≥—Ä—É–ø–ø–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã' },
        { status: 404 }
      );
    }

    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: ' + error.message },
      { status: 500 }
    );
  }
}

export async function DELETE(request, { params }) {
  try {
    // –û–∂–∏–¥–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    const { id: userId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    const { searchParams } = new URL(request.url);
    const groupId = searchParams.get('groupId');

    if (!groupId) {
      return NextResponse.json(
        { message: 'Group ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' },
        { status: 400 }
      );
    }

    console.log('Removing user', userId, 'from group', groupId);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Å–≤—è–∑–∏
    const existingUserGroup = await prisma.userGroup.findUnique({
      where: {
        userId_groupId: {
          userId,
          groupId
        }
      }
    });

    if (!existingUserGroup) {
      return NextResponse.json(
        { message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ —Å–æ—Å—Ç–æ–∏—Ç –≤ —ç—Ç–æ–π –≥—Ä—É–ø–ø–µ' },
        { status: 404 }
      );
    }

    await prisma.userGroup.delete({
      where: {
        userId_groupId: {
          userId,
          groupId
        }
      }
    });

    console.log('UserGroup deleted successfully');

    return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–¥–∞–ª–µ–Ω –∏–∑ –≥—Ä—É–ø–ø—ã' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –≥—Ä—É–ø–ø—ã:', error);
    
    if (error.code === 'P2025') {
      return NextResponse.json(
        { message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ —Å–æ—Å—Ç–æ–∏—Ç –≤ —ç—Ç–æ–π –≥—Ä—É–ø–ø–µ' },
        { status: 404 }
      );
    }

    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: ' + error.message },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: admin/users/[id]/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/admin/users/[id]/route.js
–†–ê–ó–ú–ï–†: 5095 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

async function isAdmin(userId) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true }
  });
  return user?.role === 'ADMIN';
}

export async function GET(request, { params }) {
  try {
    // –û–∂–∏–¥–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    const { id: userId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: {
        id: true,
        name: true,
        usertag: true,
        email: true,
        avatar: true,
        banner: true,
        bio: true,
        role: true,
        location: true,
        website: true,
        profileVisibility: true,
        experiencePoints: true,
        createdAt: true,
        updatedAt: true,
        _count: {
          select: {
            vacationMembers: true,
            ownedVacations: true,
            posts: true,
            friendsAsUser1: true,
            friendsAsUser2: true,
            memories: true,
            achievements: true
          }
        },
        ownedVacations: {
          select: {
            id: true,
            title: true,
            startDate: true,
            endDate: true,
            destination: true,
            coverImage: true,
            _count: {
              select: {
                members: true,
                memories: true,
                activities: true
              }
            }
          },
          orderBy: { createdAt: 'desc' },
          take: 5
        },
        posts: {
          select: {
            id: true,
            content: true,
            createdAt: true,
            _count: {
              select: {
                comments: true,
                likes: true
              }
            }
          },
          orderBy: { createdAt: 'desc' },
          take: 10
        },
        userGroups: {
          include: {
            group: {
              select: {
                id: true,
                name: true,
                icon: true,
                badgeText: true,
                bgColor: true,
                color: true,
                isExclusive: true
              }
            }
          }
        },
        achievements: {
          select: {
            id: true,
            type: true,
            title: true,
            description: true,
            icon: true,
            earnedAt: true
          },
          orderBy: { earnedAt: 'desc' },
          take: 10
        }
      }
    });

    if (!user) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    return NextResponse.json({ user });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

export async function PUT(request, { params }) {
  try {
    // –û–∂–∏–¥–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    const { id: userId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    const updates = await request.json();

    const validFields = [
      'name', 'email', 'usertag', 'bio', 'location', 'website', 
      'profileVisibility', 'experiencePoints', 'avatar', 'banner'
    ];

    const updateData = {};
    Object.keys(updates).forEach(key => {
      if (validFields.includes(key)) {
        updateData[key] = updates[key];
      }
    });

    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: updateData,
      select: {
        id: true,
        name: true,
        usertag: true,
        email: true,
        bio: true,
        location: true,
        website: true,
        profileVisibility: true,
        experiencePoints: true,
        avatar: true,
        banner: true
      }
    });

    return NextResponse.json({
      message: '–î–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω—ã',
      user: updatedUser
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', error);
    
    if (error.code === 'P2002') {
      return NextResponse.json(
        { message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email –∏–ª–∏ usertag —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç' },
        { status: 409 }
      );
    }

    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: admin/users/role/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/admin/users/role/route.js
–†–ê–ó–ú–ï–†: 1838 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

async function isAdmin(userId) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true }
  });
  return user?.role === 'ADMIN';
}

export async function PUT(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    const { userId, role } = await request.json();

    if (!userId || !role) {
      return NextResponse.json(
        { message: 'User ID –∏ —Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' },
        { status: 400 }
      );
    }

    const validRoles = ['USER', 'ADMIN', 'MODERATOR'];
    if (!validRoles.includes(role)) {
      return NextResponse.json(
        { message: '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º–∞—è —Ä–æ–ª—å' },
        { status: 400 }
      );
    }

    if (userId === decoded.userId) {
      return NextResponse.json(
        { message: '–ù–µ–ª—å–∑—è –∏–∑–º–µ–Ω–∏—Ç—å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—É—é —Ä–æ–ª—å' },
        { status: 400 }
      );
    }

    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: { role },
      select: {
        id: true,
        name: true,
        email: true,
        role: true
      }
    });

    return NextResponse.json({
      message: '–†–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∞',
      user: updatedUser
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ä–æ–ª–∏:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: admin/users/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/admin/users/route.js
–†–ê–ó–ú–ï–†: 3496 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

async function isAdmin(userId) {
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true }
  });
  return user?.role === 'ADMIN';
}

export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    const { searchParams } = new URL(request.url);
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');
    const search = searchParams.get('search') || '';
    const skip = (page - 1) * limit;

    const where = search ? {
      OR: [
        { name: { contains: search, mode: 'insensitive' } },
        { email: { contains: search, mode: 'insensitive' } },
        { usertag: { contains: search, mode: 'insensitive' } }
      ]
    } : {};

    const [users, total] = await Promise.all([
      prisma.user.findMany({
        where,
        select: {
          id: true,
          name: true,
          usertag: true,
          email: true,
          avatar: true,
          role: true,
          createdAt: true,
          location: true,
          website: true,
          experiencePoints: true,
          _count: {
            select: {
              vacationMembers: {
                where: { status: 'accepted' }
              }
            }
          }
        },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit
      }),
      prisma.user.count({ where })
    ]);

    const formattedUsers = users.map(user => ({
      ...user,
      vacationCount: user._count.vacationMembers
    }));

    return NextResponse.json({
      users: formattedUsers,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

export async function DELETE(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded || !(await isAdmin(decoded.userId))) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    const { userId } = await request.json();

    if (!userId) {
      return NextResponse.json({ message: 'User ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' }, { status: 400 });
    }

    if (userId === decoded.userId) {
      return NextResponse.json(
        { message: '–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π –∞–∫–∫–∞—É–Ω—Ç' },
        { status: 400 }
      );
    }

    await prisma.user.delete({
      where: { id: userId }
    });

    return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–¥–∞–ª–µ–Ω' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/login/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/login/route.js
–†–ê–ó–ú–ï–†: 2408 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/login/route.js
import { NextResponse } from 'next/server';
import { verifyPassword, createSession } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const { email, password, rememberMe = false } = await request.json();

    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    if (!email || !password) {
      return NextResponse.json(
        { message: 'Email –∏ –ø–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' },
        { status: 400 }
      );
    }

    // –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = await prisma.user.findUnique({
      where: { email }
    });

    if (!user) {
      return NextResponse.json(
        { message: '–ù–µ–≤–µ—Ä–Ω—ã–π email –∏–ª–∏ –ø–∞—Ä–æ–ª—å' },
        { status: 401 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ä–æ–ª—è
    const isPasswordValid = await verifyPassword(password, user.password);
    if (!isPasswordValid) {
      return NextResponse.json(
        { message: '–ù–µ–≤–µ—Ä–Ω—ã–π email –∏–ª–∏ –ø–∞—Ä–æ–ª—å' },
        { status: 401 }
      );
    }

    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–ª–∏–µ–Ω—Ç–µ
    const userAgent = request.headers.get('user-agent');
    const ipAddress = request.headers.get('x-forwarded-for') || request.ip;

    // –°–æ–∑–¥–∞–µ–º —Å–µ—Å—Å–∏—é —Å —É—á–µ—Ç–æ–º rememberMe
    const { accessToken, refreshToken, sessionId } = await createSession(
      user.id, 
      userAgent, 
      ipAddress,
      rememberMe
    );

    const userData = {
      id: user.id,
      name: user.name,
      email: user.email,
      createdAt: user.createdAt
    };

    const response = NextResponse.json(
      { 
        message: '–í—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ',
        user: userData
      },
      { status: 200 }
    );

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º httpOnly –∫—É–∫–∏ —Å —Ä–∞–∑–Ω—ã–º –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏
    response.cookies.set('accessToken', accessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 1000 // 1 —á–∞—Å
    });

    response.cookies.set('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: rememberMe 
        ? 365 * 24 * 60 * 60 * 1000 // 1 –≥–æ–¥ –¥–ª—è "–ó–∞–ø–æ–º–Ω–∏—Ç—å –º–µ–Ω—è"
        : 30 * 24 * 60 * 60 * 1000 // 30 –¥–Ω–µ–π –¥–ª—è –æ–±—ã—á–Ω–æ–π —Å–µ—Å—Å–∏–∏
    });

    return response;

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/logout/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/logout/route.js
–†–ê–ó–ú–ï–†: 1175 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/logout/route.js
import { NextResponse } from 'next/server';
import { deleteSession } from '../../../../lib/auth';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (accessToken) {
      const { verifyAccessToken } = await import('../../../../lib/auth');
      const decoded = verifyAccessToken(accessToken);
      
      if (decoded?.sessionId) {
        await deleteSession(decoded.sessionId);
      }
    }

    const response = NextResponse.json(
      { message: '–í—ã—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ' },
      { status: 200 }
    );

    // –û—á–∏—â–∞–µ–º –∫—É–∫–∏
    response.cookies.set('accessToken', '', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 0
    });

    response.cookies.set('refreshToken', '', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 0
    });

    return response;

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –≤—ã—Ö–æ–¥–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/me/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/me/route.js
–†–ê–ó–ú–ï–†: 1665 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/me/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function GET(request) {
  try {
    console.log('üîç Checking auth...');
    
    const accessToken = request.cookies.get('accessToken')?.value;
    console.log('Access token exists:', !!accessToken);

    if (!accessToken) {
      console.log('‚ùå No access token');
      return NextResponse.json(
        { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    console.log('Decoded token:', decoded);

    if (!decoded) {
      console.log('‚ùå Invalid token');
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' },
        { status: 401 }
      );
    }

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã —Å usertag
    console.log('üë§ Fetching user:', decoded.userId);
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: {
        id: true,
        name: true,
        usertag: true, // –î–û–ë–ê–í–õ–ï–ù–û
        email: true,
        avatar: true,
        createdAt: true
      }
    });

    console.log('User found:', !!user);
    console.log('User usertag:', user?.usertag);

    if (!user) {
      return NextResponse.json(
        { message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' },
        { status: 404 }
      );
    }

    return NextResponse.json(user);

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/refresh/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/refresh/route.js
–†–ê–ó–ú–ï–†: 1271 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/refresh/route.js
import { NextResponse } from 'next/server';
import { verifySession, generateAccessToken } from '../../../../lib/auth';

export async function POST(request) {
  try {
    const refreshToken = request.cookies.get('refreshToken')?.value;

    if (!refreshToken) {
      return NextResponse.json(
        { message: 'Refresh token –Ω–µ –Ω–∞–π–¥–µ–Ω' },
        { status: 401 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–µ—Å—Å–∏—é
    const session = await verifySession(refreshToken);
    if (!session) {
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞—è —Å–µ—Å—Å–∏—è' },
        { status: 401 }
      );
    }

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π access token
    const newAccessToken = generateAccessToken(session.userId, session.id);

    const response = NextResponse.json(
      { message: 'Token –æ–±–Ω–æ–≤–ª–µ–Ω' },
      { status: 200 }
    );

    response.cookies.set('accessToken', newAccessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 1000 // 1 —á–∞—Å
    });

    return response;

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/register/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/register/route.js
–†–ê–ó–ú–ï–†: 3926 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/register/route.js (–æ–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
import { NextResponse } from 'next/server';
import { hashPassword, createSession } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const { name, usertag, email, password, rememberMe = false } = await request.json();

    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    if (!name || !usertag || !email || !password) {
      return NextResponse.json(
        { message: '–í—Å–µ –ø–æ–ª—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã –¥–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è' },
        { status: 400 }
      );
    }

    if (password.length < 6) {
      return NextResponse.json(
        { message: '–ü–∞—Ä–æ–ª—å –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 6 —Å–∏–º–≤–æ–ª–æ–≤' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ usertag
    if (!/^[a-z0-9-]+$/.test(usertag)) {
      return NextResponse.json(
        { message: 'Usertag –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ –ª–∞—Ç–∏–Ω—Å–∫–∏–µ –±—É–∫–≤—ã –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ, —Ü–∏—Ñ—Ä—ã –∏ –¥–µ—Ñ–∏—Å—ã' },
        { status: 400 }
      );
    }

    if (usertag.length < 3 || usertag.length > 20) {
      return NextResponse.json(
        { message: 'Usertag –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 3 –¥–æ 20 —Å–∏–º–≤–æ–ª–æ–≤' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ email –∏ usertag
    const existingUser = await prisma.user.findFirst({
      where: {
        OR: [
          { email },
          { usertag }
        ]
      }
    });

    if (existingUser) {
      if (existingUser.email === email) {
        return NextResponse.json(
          { message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç' },
          { status: 409 }
        );
      }
      if (existingUser.usertag === usertag) {
        return NextResponse.json(
          { message: '–≠—Ç–æ—Ç usertag —É–∂–µ –∑–∞–Ω—è—Ç' },
          { status: 409 }
        );
      }
    }

    // –•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–æ–ª—è
    const hashedPassword = await hashPassword(password);

    // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const newUser = await prisma.user.create({
      data: {
        name,
        usertag,
        email,
        password: hashedPassword,
      },
      select: {
        id: true,
        name: true,
        usertag: true,
        email: true,
        createdAt: true
      }
    });

    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–ª–∏–µ–Ω—Ç–µ
    const userAgent = request.headers.get('user-agent');
    const ipAddress = request.headers.get('x-forwarded-for') || request.ip;

    // –°–æ–∑–¥–∞–µ–º —Å–µ—Å—Å–∏—é —Å —É—á–µ—Ç–æ–º rememberMe
    const { accessToken, refreshToken, sessionId } = await createSession(
      newUser.id, 
      userAgent, 
      ipAddress,
      rememberMe
    );

    const response = NextResponse.json(
      { 
        message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω',
        user: newUser
      },
      { status: 201 }
    );

    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º httpOnly –∫—É–∫–∏ —Å —Ä–∞–∑–Ω—ã–º –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏
    response.cookies.set('accessToken', accessToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 1000 // 1 —á–∞—Å
    });

    response.cookies.set('refreshToken', refreshToken, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: rememberMe 
        ? 365 * 24 * 60 * 60 * 1000 // 1 –≥–æ–¥ –¥–ª—è "–ó–∞–ø–æ–º–Ω–∏—Ç—å –º–µ–Ω—è"
        : 30 * 24 * 60 * 60 * 1000 // 30 –¥–Ω–µ–π –¥–ª—è –æ–±—ã—á–Ω–æ–π —Å–µ—Å—Å–∏–∏
    });

    return response;

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:', error);
    
    if (error.code === 'P2002') {
      const field = error.meta?.target?.[0];
      if (field === 'email') {
        return NextResponse.json(
          { message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç' },
          { status: 409 }
        );
      }
      if (field === 'usertag') {
        return NextResponse.json(
          { message: '–≠—Ç–æ—Ç usertag —É–∂–µ –∑–∞–Ω—è—Ç' },
          { status: 409 }
        );
      }
    }

    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/sessions/all/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/sessions/all/route.js
–†–ê–ó–ú–ï–†: 1334 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/sessions/all/route.js
import { NextResponse } from 'next/server';
import { deleteAllUserSessions } from '../../../../../lib/auth';
import { verifyAccessToken } from '../../../../../lib/auth';

// –£–¥–∞–ª–∏—Ç—å –≤—Å–µ —Å–µ—Å—Å–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–∫—Ä–æ–º–µ —Ç–µ–∫—É—â–µ–π)
export async function DELETE(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json(
        { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' },
        { status: 401 }
      );
    }

    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Å–µ—Å—Å–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const { getUserSessions, deleteSession } = await import('../../../../../lib/auth');
    const sessions = await getUserSessions(decoded.userId);

    // –£–¥–∞–ª—è–µ–º –≤—Å–µ —Å–µ—Å—Å–∏–∏ –∫—Ä–æ–º–µ —Ç–µ–∫—É—â–µ–π
    for (const session of sessions) {
      if (session.id !== decoded.sessionId) {
        await deleteSession(session.id);
      }
    }

    return NextResponse.json({ message: '–í—Å–µ –¥—Ä—É–≥–∏–µ —Å–µ—Å—Å–∏–∏ —É–¥–∞–ª–µ–Ω—ã' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å–µ—Å—Å–∏–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: auth/sessions/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/auth/sessions/route.js
–†–ê–ó–ú–ï–†: 1817 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/auth/sessions/route.js
import { NextResponse } from 'next/server';
import { getUserSessions, deleteSession, deleteAllUserSessions } from '../../../../lib/auth';
import { verifyAccessToken } from '../../../../lib/auth';

// –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ —Å–µ—Å—Å–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json(
        { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' },
        { status: 401 }
      );
    }

    const sessions = await getUserSessions(decoded.userId);

    return NextResponse.json({ sessions });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–µ—Å—Å–∏–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

// –£–¥–∞–ª–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é —Å–µ—Å—Å–∏—é
export async function DELETE(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;
    const { sessionId } = await request.json();

    if (!accessToken) {
      return NextResponse.json(
        { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' },
        { status: 401 }
      );
    }

    await deleteSession(sessionId);

    return NextResponse.json({ message: '–°–µ—Å—Å–∏—è —É–¥–∞–ª–µ–Ω–∞' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å–µ—Å—Å–∏–∏:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: friends/request/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/friends/request/route.js
–†–ê–ó–ú–ï–†: 3203 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/friends/request/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { userId } = await request.json();

    if (!userId) {
      return NextResponse.json({ message: 'User ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' }, { status: 400 });
    }

    // –ù–µ–ª—å–∑—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å —Å–∞–º–æ–º—É —Å–µ–±–µ
    if (userId === decoded.userId) {
      return NextResponse.json(
        { message: '–ù–µ–ª—å–∑—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è —Å–∞–º–æ–º—É —Å–µ–±–µ' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const targetUser = await prisma.user.findUnique({
      where: { id: userId }
    });

    if (!targetUser) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ –ª–∏ —É–∂–µ –∑–∞–ø—Ä–æ—Å
    const existingRequest = await prisma.friendRequest.findFirst({
      where: {
        senderId: decoded.userId,
        receiverId: userId
      }
    });

    if (existingRequest) {
      return NextResponse.json(
        { message: '–ó–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è —É–∂–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω' },
        { status: 409 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è—é—Ç—Å—è –ª–∏ —É–∂–µ –¥—Ä—É–∑—å—è–º–∏
    const existingFriendship = await prisma.friendship.findFirst({
      where: {
        OR: [
          { user1Id: decoded.userId, user2Id: userId },
          { user1Id: userId, user2Id: decoded.userId }
        ]
      }
    });

    if (existingFriendship) {
      return NextResponse.json(
        { message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —É –≤–∞—Å –≤ –¥—Ä—É–∑—å—è—Ö' },
        { status: 409 }
      );
    }

    // –°–æ–∑–¥–∞–µ–º –∑–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è
    const friendRequest = await prisma.friendRequest.create({
      data: {
        senderId: decoded.userId,
        receiverId: userId,
        status: 'PENDING'
      },
      include: {
        sender: {
          select: {
            id: true,
            name: true,
            avatar: true,
            usertag: true
          }
        }
      }
    });

    // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª—É—á–∞—Ç–µ–ª—è
    await prisma.notification.create({
      data: {
        userId: userId,
        type: 'friend_request',
        title: '–ù–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è',
        message: `${friendRequest.sender.name} —Ö–æ—á–µ—Ç –¥–æ–±–∞–≤–∏—Ç—å –≤–∞—Å –≤ –¥—Ä—É–∑—å—è`,
        data: {
          requestId: friendRequest.id,
          senderId: decoded.userId,
          senderName: friendRequest.sender.name,
          senderAvatar: friendRequest.sender.avatar
        }
      }
    });

    return NextResponse.json({
      message: '–ó–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω',
      request: friendRequest
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∑–∞–ø—Ä–æ—Å–∞ –≤ –¥—Ä—É–∑—å—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: friends/respond/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/friends/respond/route.js
–†–ê–ó–ú–ï–†: 3626 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { requestId, accept } = await request.json();

    console.log('üì® –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –¥—Ä—É–∂–±—ã:', { requestId, accept, userId: decoded.userId });

    if (!requestId) {
      return NextResponse.json({ message: 'Request ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' }, { status: 400 });
    }

    // –ù–∞—Ö–æ–¥–∏–º –∑–∞–ø—Ä–æ—Å
    const friendRequest = await prisma.friendRequest.findFirst({
      where: {
        id: requestId,
        receiverId: decoded.userId,
        status: 'PENDING'
      },
      include: {
        sender: {
          select: {
            id: true,
            name: true,
            avatar: true,
            usertag: true
          }
        },
        receiver: {
          select: {
            id: true,
            name: true,
            avatar: true,
            usertag: true
          }
        }
      }
    });

    console.log('üîç –ù–∞–π–¥–µ–Ω –∑–∞–ø—Ä–æ—Å –¥—Ä—É–∂–±—ã:', friendRequest);

    if (!friendRequest) {
      return NextResponse.json({ message: '–ó–∞–ø—Ä–æ—Å –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    if (accept) {
      // –ü—Ä–∏–Ω–∏–º–∞–µ–º –∑–∞–ø—Ä–æ—Å - —Å–æ–∑–¥–∞–µ–º –¥—Ä—É–∂–±—É
      const result = await prisma.$transaction(async (tx) => {
        // –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –æ –¥—Ä—É–∂–±–µ (—É–±–µ–¥–∏–º—Å—è, —á—Ç–æ user1Id –≤—Å–µ–≥–¥–∞ –º–µ–Ω—å—à–µ user2Id –¥–ª—è —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏)
        const user1Id = friendRequest.senderId < decoded.userId ? friendRequest.senderId : decoded.userId;
        const user2Id = friendRequest.senderId < decoded.userId ? decoded.userId : friendRequest.senderId;

        console.log('üë• –°–æ–∑–¥–∞–µ–º –¥—Ä—É–∂–±—É –º–µ–∂–¥—É:', { user1Id, user2Id });

        const friendship = await tx.friendship.create({
          data: {
            user1Id,
            user2Id
          }
        });

        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–ø—Ä–æ—Å–∞
        await tx.friendRequest.update({
          where: { id: requestId },
          data: { status: 'ACCEPTED' }
        });

        // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è
        await tx.notification.create({
          data: {
            userId: friendRequest.senderId,
            type: 'friend_request_accepted',
            title: '–ó–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è –ø—Ä–∏–Ω—è—Ç',
            message: `${friendRequest.receiver.name} –ø—Ä–∏–Ω—è–ª(–∞) –≤–∞—à –∑–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è`,
            data: {
              friendId: decoded.userId,
              friendName: friendRequest.receiver.name,
              friendAvatar: friendRequest.receiver.avatar,
              friendUsertag: friendRequest.receiver.usertag
            }
          }
        });

        return friendship;
      });

      console.log('‚úÖ –ó–∞–ø—Ä–æ—Å –¥—Ä—É–∂–±—ã –ø—Ä–∏–Ω—è—Ç:', result);

      return NextResponse.json({ 
        message: '–ó–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è –ø—Ä–∏–Ω—è—Ç',
        friendship: result
      });

    } else {
      // –û—Ç–∫–ª–æ–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å
      await prisma.friendRequest.update({
        where: { id: requestId },
        data: { status: 'REJECTED' }
      });

      console.log('‚ùå –ó–∞–ø—Ä–æ—Å –¥—Ä—É–∂–±—ã –æ—Ç–∫–ª–æ–Ω–µ–Ω');

      return NextResponse.json({ message: '–ó–∞–ø—Ä–æ—Å –≤ –¥—Ä—É–∑—å—è –æ—Ç–∫–ª–æ–Ω–µ–Ω' });
    }

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–∞ –≤ –¥—Ä—É–∑—å—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: friends/status/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/friends/status/route.js
–†–ê–ó–ú–ï–†: 2043 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/friends/status/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const targetUserId = searchParams.get('targetUserId');
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    if (!targetUserId) {
      return NextResponse.json({ message: 'Target User ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' }, { status: 400 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥—Ä—É–∂–±—É
    const friendship = await prisma.friendship.findFirst({
      where: {
        OR: [
          { user1Id: decoded.userId, user2Id: targetUserId },
          { user1Id: targetUserId, user2Id: decoded.userId }
        ]
      }
    });

    if (friendship) {
      return NextResponse.json({ status: 'friends' });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏—Å—Ö–æ–¥—è—â–∏–π –∑–∞–ø—Ä–æ—Å
    const outgoingRequest = await prisma.friendRequest.findFirst({
      where: {
        senderId: decoded.userId,
        receiverId: targetUserId,
        status: 'PENDING'
      }
    });

    if (outgoingRequest) {
      return NextResponse.json({ status: 'pending' });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Ö–æ–¥—è—â–∏–π –∑–∞–ø—Ä–æ—Å
    const incomingRequest = await prisma.friendRequest.findFirst({
      where: {
        senderId: targetUserId,
        receiverId: decoded.userId,
        status: 'PENDING'
      }
    });

    if (incomingRequest) {
      return NextResponse.json({ status: 'incoming' });
    }

    return NextResponse.json({ status: 'none' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ –¥—Ä—É–∂–±—ã:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: invitations/[id]/respond/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/invitations/[id]/respond/route.js
–†–ê–ó–ú–ï–†: 4777 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/invitations/[id]/respond/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function POST(request, { params }) {
  try {
    const { id: invitationId } = await params;
    const { accept } = await request.json();
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ –∏–∑ –±–∞–∑—ã
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: { id: true, name: true, email: true }
    });

    if (!user) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    // –ù–∞—Ö–æ–¥–∏–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
    const invitation = await prisma.invitation.findFirst({
      where: {
        id: invitationId,
        email: user.email // –ò—Å–ø–æ–ª—å–∑—É–µ–º email –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
      },
      include: {
        vacation: true,
        invitedBy: {
          select: { name: true }
        }
      }
    });

    if (!invitation) {
      return NextResponse.json({ message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' }, { status: 404 });
    }

    if (invitation.status !== 'pending') {
      return NextResponse.json({ message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ' }, { status: 400 });
    }

    if (new Date() > invitation.expiresAt) {
      return NextResponse.json({ message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –∏—Å—Ç–µ–∫–ª–æ' }, { status: 400 });
    }

    if (accept) {
      // –ü—Ä–∏–Ω–∏–º–∞–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
      await prisma.$transaction(async (tx) => {
        // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∫–∞–∫ —É—á–∞—Å—Ç–Ω–∏–∫–∞
        await tx.vacationMember.create({
          data: {
            vacationId: invitation.vacationId,
            userId: user.id,
            role: 'member',
            status: 'accepted',
            joinedAt: new Date()
          }
        });

        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è
        await tx.invitation.update({
          where: { id: invitationId },
          data: { status: 'accepted' }
        });

        // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –≤–ª–∞–¥–µ–ª—å—Ü–∞
        await tx.notification.create({
          data: {
            userId: invitation.invitedById,
            type: 'info',
            title: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –ø—Ä–∏–Ω—è—Ç–æ',
            message: `${user.name} –ø—Ä–∏–Ω—è–ª(–∞) –≤–∞—à–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –æ—Ç–ø—É—Å–∫ "${invitation.vacation.title}"`,
            data: {
              vacationId: invitation.vacationId,
              acceptedByName: user.name
            }
          }
        });

        // –û–±–Ω–æ–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await tx.notification.updateMany({
          where: {
            userId: user.id,
            type: 'invitation',
            data: {
              path: ['invitationId'],
              equals: invitationId
            }
          },
          data: {
            data: {
              ...invitation.data,
              status: 'accepted'
            }
          }
        });
      });

      return NextResponse.json({ 
        message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –ø—Ä–∏–Ω—è—Ç–æ',
        vacationId: invitation.vacationId
      });
    } else {
      // –û—Ç–∫–ª–æ–Ω—è–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
      await prisma.$transaction(async (tx) => {
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è
        await tx.invitation.update({
          where: { id: invitationId },
          data: { status: 'rejected' }
        });

        // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –≤–ª–∞–¥–µ–ª—å—Ü–∞
        await tx.notification.create({
          data: {
            userId: invitation.invitedById,
            type: 'info',
            title: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ',
            message: `${user.name} –æ—Ç–∫–ª–æ–Ω–∏–ª(–∞) –≤–∞—à–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –æ—Ç–ø—É—Å–∫ "${invitation.vacation.title}"`,
            data: {
              vacationId: invitation.vacationId,
              rejectedByName: user.name
            }
          }
        });

        // –û–±–Ω–æ–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await tx.notification.updateMany({
          where: {
            userId: user.id,
            type: 'invitation',
            data: {
              path: ['invitationId'],
              equals: invitationId
            }
          },
          data: {
            data: {
              ...invitation.data,
              status: 'rejected'
            }
          }
        });
      });

      return NextResponse.json({ message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ' });
    }

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: memories/capture/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/memories/capture/route.js
–†–ê–ó–ú–ï–†: 3546 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/memories/capture/route.js
import { NextResponse } from 'next/server';
import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const formData = await request.formData();
    const vacationId = formData.get('vacationId');
    const photos = formData.getAll('photos');

    if (!vacationId || photos.length === 0) {
      return NextResponse.json(
        { message: '–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ –æ—Ç–ø—É—Å–∫—É
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: vacationId,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π –Ω–∞ –¥–µ–Ω—å (3 —Ñ–æ—Ç–æ)
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);

    const todayMemories = await prisma.memory.count({
      where: {
        vacationId,
        authorId: decoded.userId,
        createdAt: {
          gte: today,
          lt: tomorrow
        }
      }
    });

    if (todayMemories + photos.length > 3) {
      return NextResponse.json(
        { message: '–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –≤ 3 —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –≤ –¥–µ–Ω—å' },
        { status: 400 }
      );
    }

    const createdMemories = [];

    // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –∑–∞–≥—Ä—É–∑–æ–∫ –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç
    const uploadDir = join(process.cwd(), 'public', 'uploads', 'memories');
    try {
      await mkdir(uploadDir, { recursive: true });
    } catch (error) {
      // –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    }

    for (const photo of photos) {
      const bytes = await photo.arrayBuffer();
      const buffer = Buffer.from(bytes);
      
      // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞
      const timestamp = Date.now();
      const filename = `${timestamp}-${photo.name}`;
      const filepath = join(uploadDir, filename);

      // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª
      await writeFile(filepath, buffer);

      // –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –≤ –±–∞–∑–µ
      const memory = await prisma.memory.create({
        data: {
          title: `–§–æ—Ç–æ –¥–Ω—è - ${new Date().toLocaleDateString('ru-RU')}`,
          description: '–ó–∞–ø–µ—á–∞—Ç–ª–µ–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç',
          imageUrl: `/uploads/memories/${filename}`,
          takenAt: new Date(),
          vacationId,
          authorId: decoded.userId,
          tags: ['captured_moment']
        },
        include: {
          author: {
            select: { id: true, name: true, avatar: true }
          }
        }
      });

      createdMemories.push(memory);
    }

    return NextResponse.json({ 
      message: '–§–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã',
      memories: createdMemories 
    }, { status: 201 });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: notifications/invite/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/notifications/invite/route.js
–†–ê–ó–ú–ï–†: 1259 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/notifications/invite/route.js
import { NextResponse } from 'next/server';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const { userId, vacationId, invitedByName, vacationTitle } = await request.json();

    if (!userId || !vacationId || !invitedByName) {
      return NextResponse.json(
        { message: '–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ' },
        { status: 400 }
      );
    }

    // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–∏
    const notification = await prisma.notification.create({
      data: {
        userId,
        type: 'invitation',
        title: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –æ—Ç–ø—É—Å–∫',
        message: `${invitedByName} –ø—Ä–∏–≥–ª–∞—Å–∏–ª(–∞) –≤–∞—Å –≤ –æ—Ç–ø—É—Å–∫ "${vacationTitle}"`,
        data: {
          vacationId,
          invitedByName,
          vacationTitle
        }
      },
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            avatar: true 
          }
        }
      }
    });

    return NextResponse.json(notification, { status: 201 });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: notifications/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/notifications/route.js
–†–ê–ó–ú–ï–†: 2505 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/notifications/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

// –ü–æ–ª—É—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const notifications = await prisma.notification.findMany({
      where: { 
        userId: decoded.userId 
      },
      orderBy: { 
        createdAt: 'desc' 
      },
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            avatar: true 
          }
        }
      },
      take: 50
    });

    return NextResponse.json(notifications);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

// –ü–æ–º–µ—Ç–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ
export async function PUT(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { notificationIds } = await request.json();

    if (notificationIds && notificationIds.length > 0) {
      // –ü–æ–º–µ—Ç–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ
      await prisma.notification.updateMany({
        where: { 
          id: { in: notificationIds },
          userId: decoded.userId 
        },
        data: { isRead: true }
      });
    } else {
      // –ü–æ–º–µ—Ç–∏—Ç—å –≤—Å–µ –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ
      await prisma.notification.updateMany({
        where: { 
          userId: decoded.userId,
          isRead: false 
        },
        data: { isRead: true }
      });
    }

    return NextResponse.json({ message: '–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–æ–º–µ—á–µ–Ω—ã –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã–µ' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: notifications/test/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/notifications/test/route.js
–†–ê–ó–ú–ï–†: 2783 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/notifications/test/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { type = 'info' } = await request.json();

    // –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
    let notificationData;

    switch (type) {
      case 'invitation':
        notificationData = {
          userId: decoded.userId,
          type: 'invitation',
          title: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –æ—Ç–ø—É—Å–∫',
          message: '–ê–Ω–Ω–∞ –ø—Ä–∏–≥–ª–∞—Å–∏–ª–∞ –≤–∞—Å –≤ –æ—Ç–ø—É—Å–∫ "–û—Ç–¥—ã—Ö –Ω–∞ –ë–∞–ª–∏"',
          data: {
            invitationId: 'test-invitation-123',
            vacationId: 'test-vacation-456',
            invitedByName: '–ê–Ω–Ω–∞',
            vacationTitle: '–û—Ç–¥—ã—Ö –Ω–∞ –ë–∞–ª–∏'
          }
        };
        break;

      case 'activity_update':
        notificationData = {
          userId: decoded.userId,
          type: 'activity_update',
          title: '–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–ª–∞–Ω–æ–≤',
          message: '–í –≤–∞—à–µ–º –æ—Ç–ø—É—Å–∫–µ "–ì–æ—Ä–Ω—ã–µ –ø–æ—Ö–æ–¥—ã" –¥–æ–±–∞–≤–ª–µ–Ω–∞ –Ω–æ–≤–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å',
          data: {
            vacationId: 'test-vacation-789',
            activityId: 'test-activity-123'
          }
        };
        break;

      case 'memory_comment':
        notificationData = {
          userId: decoded.userId,
          type: 'memory_comment',
          title: '–ù–æ–≤—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π',
          message: '–ò–≤–∞–Ω –ø—Ä–æ–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–ª –≤–∞—à–µ –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏–µ',
          data: {
            memoryId: 'test-memory-123',
            commentId: 'test-comment-456'
          }
        };
        break;

      default:
        notificationData = {
          userId: decoded.userId,
          type: 'info',
          title: '–¢–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ',
          message: '–≠—Ç–æ —Ç–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–∏—Å—Ç–µ–º—ã',
          data: {
            test: true
          }
        };
    }

    const notification = await prisma.notification.create({
      data: notificationData,
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            avatar: true 
          }
        }
      }
    });

    return NextResponse.json({
      message: '–¢–µ—Å—Ç–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ',
      notification
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: posts/[id]/comments/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/posts/[id]/comments/route.js
–†–ê–ó–ú–ï–†: 4155 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';
import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';

// –ü–æ–ª—É—á–∏—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –ø–æ—Å—Ç–∞
export async function GET(request, { params }) {
  try {
    const { id: postId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const comments = await prisma.comment.findMany({
      where: { postId },
      include: {
        author: {
          select: { id: true, name: true, avatar: true, usertag: true }
        },
        // –ü–†–ê–í–ò–õ–¨–ù–û: images (—Å–æ–≥–ª–∞—Å–Ω–æ —Å—Ö–µ–º–µ)
        images: true
      },
      orderBy: { createdAt: 'asc' }
    });

    return NextResponse.json(comments);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

// –°–æ–∑–¥–∞—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
export async function POST(request, { params }) {
  try {
    const { id: postId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const formData = await request.formData();
    const content = formData.get('content');
    const images = formData.getAll('images');

    if (!content || content.trim().length === 0) {
      return NextResponse.json(
        { message: '–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ—Å—Ç–∞
    const post = await prisma.post.findUnique({
      where: { id: postId }
    });

    if (!post) {
      return NextResponse.json({ message: '–ü–æ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    const result = await prisma.$transaction(async (tx) => {
      // –°–æ–∑–¥–∞–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
      const comment = await tx.comment.create({
        data: {
          content: content.trim(),
          authorId: decoded.userId,
          postId
        },
        include: {
          author: {
            select: { id: true, name: true, avatar: true, usertag: true }
          },
          // –ü–†–ê–í–ò–õ–¨–ù–û: images (—Å–æ–≥–ª–∞—Å–Ω–æ —Å—Ö–µ–º–µ)
          images: true
        }
      });

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
      if (images && images.length > 0) {
        const commentImages = [];

        for (const image of images) {
          if (image.size > 0) {
            // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –∑–∞–≥—Ä—É–∑–æ–∫
            const uploadDir = join(process.cwd(), 'public', 'uploads', 'comments');
            await mkdir(uploadDir, { recursive: true });

            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞
            const timestamp = Date.now();
            const filename = `${timestamp}-${image.name}`;
            const filepath = join(uploadDir, filename);

            // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª
            const bytes = await image.arrayBuffer();
            const buffer = Buffer.from(bytes);
            await writeFile(filepath, buffer);

            // –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –≤ –±–∞–∑–µ - –ü–†–ê–í–ò–õ–¨–ù–û
            const commentImage = await tx.commentImage.create({
              data: {
                url: `/uploads/comments/${filename}`,
                commentId: comment.id
              }
            });

            commentImages.push(commentImage);
          }
        }

        comment.images = commentImages;
      }

      return comment;
    });

    return NextResponse.json(result, { status: 201 });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: posts/[id]/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/posts/[id]/route.js
–†–ê–ó–ú–ï–†: 4919 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

// –ü–æ–ª—É—á–∏—Ç—å –ø–æ—Å—Ç
export async function GET(request, { params }) {
  try {
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const post = await prisma.post.findUnique({
      where: { id },
      include: {
        author: {
          select: { id: true, name: true, avatar: true, usertag: true }
        },
        // –ü–†–ê–í–ò–õ–¨–ù–û: images (—Å–æ–≥–ª–∞—Å–Ω–æ —Å—Ö–µ–º–µ)
        images: true,
        likes: {
          select: { userId: true }
        },
        comments: {
          include: {
            author: {
              select: { id: true, name: true, avatar: true, usertag: true }
            },
            // –ü–†–ê–í–ò–õ–¨–ù–û: images (—Å–æ–≥–ª–∞—Å–Ω–æ —Å—Ö–µ–º–µ)
            images: true
          },
          orderBy: { createdAt: 'asc' }
        }
      }
    });

    if (!post) {
      return NextResponse.json({ message: '–ü–æ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    return NextResponse.json(post);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ—Å—Ç–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

// –û–±–Ω–æ–≤–∏—Ç—å –ø–æ—Å—Ç
export async function PUT(request, { params }) {
  try {
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { content, imageUrls } = await request.json();

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —è–≤–ª—è–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–æ–º –ø–æ—Å—Ç–∞
    const existingPost = await prisma.post.findFirst({
      where: { 
        id,
        authorId: decoded.userId 
      }
    });

    if (!existingPost) {
      return NextResponse.json({ message: '–ü–æ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ—Ç –ø—Ä–∞–≤' }, { status: 404 });
    }

    const result = await prisma.$transaction(async (tx) => {
      // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ—Å—Ç
      const updatedPost = await tx.post.update({
        where: { id },
        data: { 
          content,
          updatedAt: new Date()
        },
        include: {
          author: {
            select: { id: true, name: true, avatar: true, usertag: true }
          },
          // –ü–†–ê–í–ò–õ–¨–ù–û: images (—Å–æ–≥–ª–∞—Å–Ω–æ —Å—Ö–µ–º–µ)
          images: true,
          likes: {
            select: { userId: true }
          }
        }
      });

      // –ï—Å–ª–∏ –µ—Å—Ç—å –Ω–æ–≤—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –æ–±–Ω–æ–≤–ª—è–µ–º –∏—Ö
      if (imageUrls && imageUrls.length > 0) {
        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        await tx.postImage.deleteMany({
          where: { postId: id }
        });

        // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        const postImages = imageUrls.map(url => ({
          url,
          postId: id
        }));

        await tx.postImage.createMany({
          data: postImages
        });

        // –ü–æ–ª—É—á–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
        updatedPost.images = await tx.postImage.findMany({
          where: { postId: id }
        });
      }

      return updatedPost;
    });

    return NextResponse.json(result);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ—Å—Ç–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

// –£–¥–∞–ª–∏—Ç—å –ø–æ—Å—Ç
export async function DELETE(request, { params }) {
  try {
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —è–≤–ª—è–µ—Ç—Å—è –∞–≤—Ç–æ—Ä–æ–º –ø–æ—Å—Ç–∞
    const existingPost = await prisma.post.findFirst({
      where: { 
        id,
        authorId: decoded.userId 
      }
    });

    if (!existingPost) {
      return NextResponse.json({ message: '–ü–æ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ—Ç –ø—Ä–∞–≤' }, { status: 404 });
    }

    // –£–¥–∞–ª—è–µ–º –ø–æ—Å—Ç (–∫–∞—Å–∫–∞–¥–Ω–æ —É–¥–∞–ª—è—Ç—Å—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –ª–∞–π–∫–∏ –∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏)
    await prisma.post.delete({
      where: { id }
    });

    return NextResponse.json({ message: '–ü–æ—Å—Ç —É–¥–∞–ª–µ–Ω' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –ø–æ—Å—Ç–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: profile/delete-temp/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/profile/delete-temp/route.js
–†–ê–ó–ú–ï–†: 1401 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/profile/delete-temp/route.js
import { NextResponse } from 'next/server';
import { unlink } from 'fs/promises';
import { join } from 'path';
import { verifyAccessToken } from '../../../../lib/auth';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { imagePath } = await request.json();
    if (!imagePath || !imagePath.startsWith('/uploads/temp/')) {
      return NextResponse.json({ message: '–ù–µ–¥–æ–ø—É—Å—Ç–∏–º—ã–π –ø—É—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è' }, { status: 400 });
    }

    const filepath = join(process.cwd(), 'public', imagePath);
    try {
      await unlink(filepath);
      console.log(`Deleted temp file: ${filepath}`);
    } catch (error) {
      if (error.code !== 'ENOENT') {
        console.error(`Error deleting temp file ${filepath}:`, error);
      }
    }

    return NextResponse.json({ message: '–í—Ä–µ–º–µ–Ω–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —É–¥–∞–ª–µ–Ω–æ' });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: profile/posts/[id]/like/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/profile/posts/[id]/like/route.js
–†–ê–ó–ú–ï–†: 1929 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

import { NextResponse } from 'next/server';
import { verifyAccessToken } from '@/lib/auth';
import { prisma } from '@/lib/prisma';

export async function POST(request, { params }) {
  try {
    const { id: postId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ—Å—Ç–∞
    const post = await prisma.post.findUnique({
      where: { id: postId },
      include: {
        likes: {
          where: { userId: decoded.userId }
        }
      }
    });

    if (!post) {
      return NextResponse.json({ message: '–ó–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞' }, { status: 404 });
    }

    const isLiked = post.likes.length > 0;

    if (isLiked) {
      // –£–¥–∞–ª—è–µ–º –ª–∞–π–∫
      await prisma.postLike.deleteMany({
        where: {
          postId: postId,
          userId: decoded.userId
        }
      });
    } else {
      // –î–æ–±–∞–≤–ª—è–µ–º –ª–∞–π–∫
      await prisma.postLike.create({
        data: {
          postId: postId,
          userId: decoded.userId
        }
      });
    }

    // –ü–æ–ª—É—á–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–∞–π–∫–æ–≤
    const updatedPost = await prisma.post.findUnique({
      where: { id: postId },
      include: {
        likes: {
          select: { userId: true }
        },
        _count: {
          select: {
            likes: true,
            comments: true
          }
        }
      }
    });

    return NextResponse.json({
      liked: !isLiked,
      likesCount: updatedPost._count.likes
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ª–∞–π–∫–∞ –∑–∞–ø–∏—Å–∏:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: profile/posts/[id]/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/profile/posts/[id]/route.js
–†–ê–ó–ú–ï–†: 2003 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/profile/posts/[id]/like/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

export async function POST(request, { params }) {
  try {
    const { id: postId } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ—Å—Ç
    const post = await prisma.post.findUnique({
      where: { id: postId },
      include: {
        likes: {
          where: { userId: decoded.userId }
        }
      }
    });

    if (!post) {
      return NextResponse.json({ message: '–ó–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞' }, { status: 404 });
    }

    const isLiked = post.likes.length > 0;

    if (isLiked) {
      // –£–¥–∞–ª—è–µ–º –ª–∞–π–∫
      await prisma.postLike.deleteMany({
        where: {
          postId: postId,
          userId: decoded.userId
        }
      });
    } else {
      // –î–æ–±–∞–≤–ª—è–µ–º –ª–∞–π–∫
      await prisma.postLike.create({
        data: {
          postId: postId,
          userId: decoded.userId
        }
      });
    }

    // –ü–æ–ª—É—á–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–∞–π–∫–æ–≤
    const updatedPost = await prisma.post.findUnique({
      where: { id: postId },
      include: {
        likes: {
          select: { userId: true }
        },
        _count: {
          select: {
            likes: true,
            comments: true
          }
        }
      }
    });

    return NextResponse.json({
      liked: !isLiked,
      likesCount: updatedPost._count.likes
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ª–∞–π–∫–∞ –∑–∞–ø–∏—Å–∏:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: profile/posts/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/profile/posts/route.js
–†–ê–ó–ú–ï–†: 7584 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/profile/posts/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';
import { writeFile, mkdir } from 'fs/promises';
import { join } from 'path';

export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const userId = searchParams.get('userId');
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    if (!userId) {
      return NextResponse.json({ message: 'User ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' }, { status: 400 });
    }

    // –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç–∏
    const profileUser = await prisma.user.findUnique({
      where: { id: userId },
      select: { 
        id: true,
        profileVisibility: true 
      }
    });

    if (!profileUser) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    const currentUserId = decoded.userId;
    const isOwnProfile = currentUserId === userId;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∏–¥–∏–º–æ—Å—Ç—å –ø–æ—Å—Ç–æ–≤
    let canViewPosts = false;
    
    if (isOwnProfile) {
      canViewPosts = true;
    } else {
      switch (profileUser.profileVisibility) {
        case 'PUBLIC':
          canViewPosts = true;
          break;
        case 'FRIENDS_ONLY':
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥—Ä—É–∂–±—É
          const friendship = await prisma.friendship.findFirst({
            where: {
              OR: [
                { user1Id: currentUserId, user2Id: userId },
                { user1Id: userId, user2Id: currentUserId }
              ]
            }
          });
          canViewPosts = !!friendship;
          break;
        case 'PRIVATE':
          canViewPosts = false;
          break;
      }
    }

    if (!canViewPosts) {
      return NextResponse.json([], { status: 200 });
    }

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å—Ç—ã
    const posts = await prisma.post.findMany({
      where: { authorId: userId },
      include: {
        author: {
          select: {
            id: true,
            name: true,
            avatar: true,
            usertag: true
          }
        },
        // –ü–†–ê–í–ò–õ–¨–ù–û–ï –∏–º—è –æ—Ç–Ω–æ—à–µ–Ω–∏—è —Å–æ–≥–ª–∞—Å–Ω–æ —Å—Ö–µ–º–µ
        images: {
          select: {
            id: true,
            url: true
          }
        },
        likes: {
          select: {
            userId: true
          }
        },
        comments: {
          include: {
            author: {
              select: {
                id: true,
                name: true,
                avatar: true
              }
            },
            // –ü–†–ê–í–ò–õ–¨–ù–û–ï –∏–º—è –æ—Ç–Ω–æ—à–µ–Ω–∏—è –¥–ª—è –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤
            images: true
          },
          orderBy: {
            createdAt: 'asc'
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    return NextResponse.json(posts);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ—Å—Ç–æ–≤:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const formData = await request.formData();
    const content = formData.get('content');
    const imageFiles = formData.getAll('images');

    // –í–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞
    if (!content || typeof content !== 'string' || content.trim().length === 0) {
      return NextResponse.json(
        { message: '–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ' },
        { status: 400 }
      );
    }

    const trimmedContent = content.trim();
    if (trimmedContent.length > 500) {
      return NextResponse.json(
        { message: '–°–æ–¥–µ—Ä–∂–∞–Ω–∏–µ –Ω–µ –¥–æ–ª–∂–Ω–æ –ø—Ä–µ–≤—ã—à–∞—Ç—å 500 —Å–∏–º–≤–æ–ª–æ–≤' },
        { status: 400 }
      );
    }

    // –í–∞–ª–∏–¥–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    if (imageFiles && imageFiles.length > 0) {
      for (const image of imageFiles) {
        if (image.size === 0) continue;
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–∞ —Ñ–∞–π–ª–∞
        const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
        if (!allowedTypes.includes(image.type)) {
          return NextResponse.json(
            { message: '–†–∞–∑—Ä–µ—à–µ–Ω—ã —Ç–æ–ª—å–∫–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ JPEG, PNG –∏–ª–∏ WebP' },
            { status: 400 }
          );
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–º–µ—Ä–∞ —Ñ–∞–π–ª–∞ (5MB –º–∞–∫—Å–∏–º—É–º)
        const maxSize = 5 * 1024 * 1024;
        if (image.size > maxSize) {
          return NextResponse.json(
            { message: '–†–∞–∑–º–µ—Ä –∫–∞–∂–¥–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–µ –¥–æ–ª–∂–µ–Ω –ø—Ä–µ–≤—ã—à–∞—Ç—å 5MB' },
            { status: 400 }
          );
        }
      }
    }

    // –°–æ–∑–¥–∞–µ–º –ø–æ—Å—Ç –∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
    const result = await prisma.$transaction(async (tx) => {
      // –°–æ–∑–¥–∞–µ–º –ø–æ—Å—Ç
      const post = await tx.post.create({
        data: {
          content: trimmedContent,
          authorId: decoded.userId
        }
      });

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
      if (imageFiles && imageFiles.length > 0) {
        for (const image of imageFiles) {
          if (image.size === 0) continue;

          // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –∑–∞–≥—Ä—É–∑–æ–∫
          const uploadDir = join(process.cwd(), 'public', 'uploads', 'posts');
          await mkdir(uploadDir, { recursive: true });

          // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞
          const timestamp = Date.now();
          const randomString = Math.random().toString(36).substring(2, 15);
          const fileExtension = image.name.split('.').pop();
          const filename = `${timestamp}-${randomString}.${fileExtension}`;
          const filepath = join(uploadDir, filename);

          // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª
          const bytes = await image.arrayBuffer();
          const buffer = Buffer.from(bytes);
          await writeFile(filepath, buffer);

          // –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –≤ –±–∞–∑–µ
          await tx.postImage.create({
            data: {
              url: `/uploads/posts/${filename}`,
              postId: post.id
            }
          });
        }
      }

      // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ—Å—Ç–∞
      const postWithData = await tx.post.findUnique({
        where: { id: post.id },
        include: {
          author: {
            select: {
              id: true,
              name: true,
              avatar: true,
              usertag: true
            }
          },
          // –ü–†–ê–í–ò–õ–¨–ù–û–ï –∏–º—è –æ—Ç–Ω–æ—à–µ–Ω–∏—è
          images: {
            select: {
              id: true,
              url: true
            }
          },
          likes: {
            select: {
              userId: true
            }
          },
          comments: {
            include: {
              author: {
                select: {
                  id: true,
                  name: true,
                  avatar: true
                }
              }
            }
          }
        }
      });

      return postWithData;
    });

    return NextResponse.json(result, { status: 201 });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ—Å—Ç–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: profile/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/profile/route.js
–†–ê–ó–ú–ï–†: 9507 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/profile/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';
import { getUserGroup, getLevelProgress } from '../../../lib/userLevels';
import { writeFile, mkdir, unlink, rename } from 'fs/promises';
import { join } from 'path';

export async function GET(request) {
  try {
    const { searchParams } = new URL(request.url);
    const usertag = searchParams.get('usertag');
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    if (!usertag) {
      return NextResponse.json({ message: 'Usertag –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω' }, { status: 400 });
    }

    // –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ usertag
    const user = await prisma.user.findUnique({
      where: { usertag },
      select: {
        id: true,
        name: true,
        usertag: true,
        email: true,
        avatar: true,
        banner: true,
        bio: true,
        location: true,
        website: true,
        experiencePoints: true,
        createdAt: true,
        profileVisibility: true,
      }
    });

    if (!user) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    const isOwnProfile = decoded.userId === user.id;

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥—Ä—É–∂–±—É –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –≤–∏–¥–∏–º–æ—Å—Ç–∏ –ø–æ—Å—Ç–æ–≤
    let canViewPosts = false;
    
    if (isOwnProfile) {
      canViewPosts = true;
    } else {
      switch (user.profileVisibility) {
        case 'PUBLIC':
          canViewPosts = true;
          break;
        case 'FRIENDS_ONLY':
          const friendship = await prisma.friendship.findFirst({
            where: {
              OR: [
                { user1Id: decoded.userId, user2Id: user.id },
                { user1Id: user.id, user2Id: decoded.userId }
              ]
            }
          });
          canViewPosts = !!friendship;
          break;
        case 'PRIVATE':
          canViewPosts = false;
          break;
      }
    }

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞
    let posts = [];
    if (canViewPosts) {
      posts = await prisma.post.findMany({
        where: { authorId: user.id },
        orderBy: { createdAt: 'desc' },
        include: {
          author: {
            select: { id: true, name: true, avatar: true }
          },
          likes: {
            select: { userId: true }
          },
          comments: {
            select: { id: true }
          }
        }
      });
    }

    // –ü–æ–ª—É—á–∞–µ–º –í–°–ï –æ—Ç–ø—É—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —á–µ—Ä–µ–∑ vacation_members
    const vacationMembers = await prisma.vacationMember.findMany({
      where: {
        userId: user.id,
        status: 'accepted'
      },
      include: {
        vacation: {
          include: {
            user: {
              select: { id: true, name: true, avatar: true }
            },
            members: {
              where: { status: 'accepted' },
              include: {
                user: {
                  select: { id: true, name: true, avatar: true }
                }
              }
            },
            _count: {
              select: {
                activities: true,
                memories: true,
                members: true
              }
            }
          }
        }
      },
      orderBy: { vacation: { startDate: 'desc' } }
    });

    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —Ñ–æ—Ä–º–∞—Ç –æ—Ç–ø—É—Å–∫–æ–≤
    const vacations = vacationMembers.map(member => ({
      ...member.vacation,
      userRole: member.role,
      isOwner: member.role === 'owner'
    }));

    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± —É—Ä–æ–≤–Ω–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const userGroup = await getUserGroup(user.id);
    const levelProgress = await getLevelProgress(user.id);

    // –§–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–ª–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å
    const userProfile = {
      ...user,
      posts,
      vacations,
      canViewPosts,
      userGroup,
      levelProgress
    };

    return NextResponse.json(userProfile);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

export async function PUT(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { name, usertag, bio, location, website, profileVisibility, avatar, banner } = await request.json();

    // –í–∞–ª–∏–¥–∞—Ü–∏—è
    if (!name || !usertag) {
      return NextResponse.json(
        { message: '–ò–º—è –∏ usertag –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' },
        { status: 400 }
      );
    }

    if (usertag.length < 3 || usertag.length > 20) {
      return NextResponse.json(
        { message: 'Usertag –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 3 –¥–æ 20 —Å–∏–º–≤–æ–ª–æ–≤' },
        { status: 400 }
      );
    }

    if (!/^[a-z0-9-]+$/.test(usertag)) {
      return NextResponse.json(
        { message: 'Usertag –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ –ª–∞—Ç–∏–Ω—Å–∫–∏–µ –±—É–∫–≤—ã –≤ –Ω–∏–∂–Ω–µ–º —Ä–µ–≥–∏—Å—Ç—Ä–µ, —Ü–∏—Ñ—Ä—ã –∏ –¥–µ—Ñ–∏—Å—ã' },
        { status: 400 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–Ω—è—Ç –ª–∏ usertag –¥—Ä—É–≥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
    const existingUser = await prisma.user.findFirst({
      where: {
        usertag,
        NOT: {
          id: decoded.userId
        }
      }
    });

    if (existingUser) {
      return NextResponse.json(
        { message: '–≠—Ç–æ—Ç usertag —É–∂–µ –∑–∞–Ω—è—Ç' },
        { status: 409 }
      );
    }

    // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π –ø—Ä–æ—Ñ–∏–ª—å –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ä—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    const currentUser = await prisma.user.findUnique({
      where: { id: decoded.userId },
      select: { avatar: true, banner: true }
    });

    // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
    const updateData = { name, usertag, bio, location, website, profileVisibility };
    
    if (avatar && avatar.startsWith('/uploads/temp/')) {
      const filename = avatar.split('/').pop();
      const tempPath = join(process.cwd(), 'public', avatar);
      const finalPath = join(process.cwd(), 'public', 'uploads', 'avatars', filename);
      await mkdir(join(process.cwd(), 'public', 'uploads', 'avatars'), { recursive: true });
      
      // –ü–µ—Ä–µ–º–µ—â–∞–µ–º —Ñ–∞–π–ª
      try {
        await rename(tempPath, finalPath);
        updateData.avatar = `/uploads/avatars/${filename}`;
        
        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –∞–≤–∞—Ç–∞—Ä, –µ—Å–ª–∏ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        if (currentUser.avatar && currentUser.avatar.startsWith('/uploads/avatars/')) {
          const oldAvatarPath = join(process.cwd(), 'public', currentUser.avatar);
          try {
            await unlink(oldAvatarPath);
            console.log(`Deleted old avatar: ${oldAvatarPath}`);
          } catch (error) {
            if (error.code !== 'ENOENT') {
              console.error(`Error deleting old avatar ${oldAvatarPath}:`, error);
            }
          }
        }
      } catch (error) {
        console.error(`Error moving avatar ${tempPath}:`, error);
        return NextResponse.json(
          { message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∞–≤–∞—Ç–∞—Ä–∞' },
          { status: 500 }
        );
      }
    }

    if (banner && banner.startsWith('/uploads/temp/')) {
      const filename = banner.split('/').pop();
      const tempPath = join(process.cwd(), 'public', banner);
      const finalPath = join(process.cwd(), 'public', 'uploads', 'banners', filename);
      await mkdir(join(process.cwd(), 'public', 'uploads', 'banners'), { recursive: true });
      
      // –ü–µ—Ä–µ–º–µ—â–∞–µ–º —Ñ–∞–π–ª
      try {
        await rename(tempPath, finalPath);
        updateData.banner = `/uploads/banners/${filename}`;
        
        // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –±–∞–Ω–Ω–µ—Ä, –µ—Å–ª–∏ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        if (currentUser.banner && currentUser.banner.startsWith('/uploads/banners/')) {
          const oldBannerPath = join(process.cwd(), 'public', currentUser.banner);
          try {
            await unlink(oldBannerPath);
            console.log(`Deleted old banner: ${oldBannerPath}`);
          } catch (error) {
            if (error.code !== 'ENOENT') {
              console.error(`Error deleting old banner ${oldBannerPath}:`, error);
            }
          }
        }
      } catch (error) {
        console.error(`Error moving banner ${tempPath}:`, error);
        return NextResponse.json(
          { message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –±–∞–Ω–Ω–µ—Ä–∞' },
          { status: 500 }
        );
      }
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ—Ñ–∏–ª—å
    const updatedUser = await prisma.user.update({
      where: { id: decoded.userId },
      data: updateData,
      select: {
        id: true,
        name: true,
        usertag: true,
        email: true,
        avatar: true,
        banner: true,
        bio: true,
        location: true,
        website: true,
        profileVisibility: true,
        createdAt: true
      }
    });

    return NextResponse.json(updatedUser);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è:', error);
    
    if (error.code === 'P2002') {
      return NextResponse.json(
        { message: '–≠—Ç–æ—Ç usertag —É–∂–µ –∑–∞–Ω—è—Ç' },
        { status: 409 }
      );
    }

    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: profile/upload/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/profile/upload/route.js
–†–ê–ó–ú–ï–†: 2575 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/profile/upload/route.js
import { NextResponse } from 'next/server';
import { writeFile, mkdir, unlink } from 'fs/promises';
import { join } from 'path';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const formData = await request.formData();
    const image = formData.get('image');
    const type = formData.get('type'); // 'avatar' –∏–ª–∏ 'banner'

    if (!image || !type) {
      return NextResponse.json(
        { message: '–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ' },
        { status: 400 }
      );
    }

    if (!image.type.startsWith('image/')) {
      return NextResponse.json(
        { message: '–§–∞–π–ª –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º' },
        { status: 400 }
      );
    }

    if (image.size > 5 * 1024 * 1024) {
      return NextResponse.json(
        { message: '–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞ –Ω–µ –¥–æ–ª–∂–µ–Ω –ø—Ä–µ–≤—ã—à–∞—Ç—å 5MB' },
        { status: 400 }
      );
    }

    // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
    const tempDir = join(process.cwd(), 'public', 'uploads', 'temp');
    await mkdir(tempDir, { recursive: true });

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è —Ñ–∞–π–ª–∞
    const timestamp = Date.now();
    const fileExtension = image.name.split('.').pop();
    const filename = `${decoded.userId}-${type}-${timestamp}.${fileExtension}`;
    const filepath = join(tempDir, filename);
    const tempPath = `/uploads/temp/${filename}`;

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ñ–∞–π–ª
    const bytes = await image.arrayBuffer();
    const buffer = Buffer.from(bytes);
    await writeFile(filepath, buffer);

    // –ü–ª–∞–Ω–∏—Ä—É–µ–º —É–¥–∞–ª–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ —á–µ—Ä–µ–∑ 5 –º–∏–Ω—É—Ç
    setTimeout(async () => {
      try {
        await unlink(filepath);
        console.log(`Deleted temp file: ${filepath}`);
      } catch (error) {
        console.error(`Error deleting temp file ${filepath}:`, error);
      }
    }, 5 * 60 * 1000); // 5 –º–∏–Ω—É—Ç

    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –ø—É—Ç—å
    return NextResponse.json({
      message: '–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ',
      tempPath
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: users/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/users/route.js
–†–ê–ó–ú–ï–†: 2694 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/users/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const search = searchParams.get('search') || '';
    const page = parseInt(searchParams.get('page') || '1');
    const limit = parseInt(searchParams.get('limit') || '20');
    const skip = (page - 1) * limit;

    // –ë–∞–∑–æ–≤—ã–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –ø–æ–∏—Å–∫–∞
    const where = {
      OR: [
        { name: { contains: search, mode: 'insensitive' } },
        { usertag: { contains: search, mode: 'insensitive' } }
      ],
      // –ò—Å–∫–ª—é—á–∞–µ–º —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      NOT: {
        id: decoded.userId
      }
    };

    console.log('üîç –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å —É—Å–ª–æ–≤–∏—è–º–∏:', { search, page, limit });

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –ø–æ–ª—è–º–∏
    const users = await prisma.user.findMany({
      where,
      select: {
        id: true,
        name: true,
        usertag: true,
        avatar: true,
        bio: true,
        location: true,
        createdAt: true,
        profileVisibility: true,
        _count: {
          select: {
            vacationMembers: {
              where: { status: 'accepted' }
            },
            posts: true,
            friendsAsUser1: true,
            friendsAsUser2: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      skip,
      take: limit
    });

    console.log('‚úÖ –ù–∞–π–¥–µ–Ω–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:', users.length);

    // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥–∞
    const formattedUsers = users.map(user => ({
      ...user,
      vacationCount: user._count.vacationMembers,
      postCount: user._count.posts,
      friendCount: user._count.friendsAsUser1 + user._count.friendsAsUser2
    }));

    // –ü–æ–ª—É—á–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
    const total = await prisma.user.count({ where });

    return NextResponse.json({
      users: formattedUsers,
      pagination: {
        page,
        limit,
        total,
        hasNext: skip + users.length < total,
        hasPrev: page > 1
      }
    });

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/activities/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/activities/route.js
–†–ê–ó–ú–ï–†: 2063 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/activities/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

export async function GET(request, { params }) {
  try {
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ –æ—Ç–ø—É—Å–∫—É
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: id,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –ø–æ–ª—è –¥–ª—è –º–æ–¥–µ–ª–∏ Activity
    const activities = await prisma.activity.findMany({
      where: { vacationId: id },
      orderBy: { date: 'asc' },
      include: {
        location: {
          select: { id: true, name: true, address: true }
        },
        participants: {
          include: {
            user: {
              select: { id: true, name: true, avatar: true }
            }
          }
        }
      }
    });

    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
    const formattedActivities = activities.map(activity => ({
      ...activity,
      // –ë–µ—Ä–µ–º –ø–µ—Ä–≤–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞ –∫–∞–∫ "–∞–≤—Ç–æ—Ä–∞" –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
      author: activity.participants[0]?.user || null,
      participants: activity.participants.map(p => p.user)
    }));

    return NextResponse.json(formattedActivities);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–µ–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/invite/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/invite/route.js
–†–ê–ó–ú–ï–†: 3568 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/invite/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';
import { randomBytes } from 'crypto';

export async function POST(request, { params }) {
  try {
    // Await params –¥–ª—è Next.js 15
    const { id: vacationId } = await params;
    const { email } = await request.json();
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å - –≤–ª–∞–¥–µ–ª–µ—Ü –æ—Ç–ø—É—Å–∫–∞
    const vacation = await prisma.vacation.findFirst({
      where: {
        id: vacationId,
        userId: decoded.userId
      },
      include: {
        user: {
          select: { name: true }
        }
      }
    });

    if (!vacation) {
      return NextResponse.json({ message: '–û—Ç–ø—É—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ—Ç –ø—Ä–∞–≤' }, { status: 404 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email
    const invitedUser = await prisma.user.findUnique({
      where: { email }
    });

    if (!invitedUser) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω –ª–∏ —É–∂–µ —ç—Ç–æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    const existingInvitation = await prisma.invitation.findFirst({
      where: {
        vacationId,
        email
      }
    });

    if (existingInvitation) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω' }, { status: 409 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–º
    const existingMember = await prisma.vacationMember.findFirst({
      where: {
        vacationId,
        userId: invitedUser.id
      }
    });

    if (existingMember) {
      return NextResponse.json({ message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–∂–µ —è–≤–ª—è–µ—Ç—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–º' }, { status: 409 });
    }

    // –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ
    const token = randomBytes(32).toString('hex');
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 –¥–Ω–µ–π

    const invitation = await prisma.invitation.create({
      data: {
        vacationId,
        email,
        token,
        invitedById: decoded.userId,
        expiresAt
      }
    });

    // –°–æ–∑–¥–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –ø—Ä–∏–≥–ª–∞—à–µ–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const notification = await prisma.notification.create({
      data: {
        userId: invitedUser.id,
        type: 'invitation',
        title: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –≤ –æ—Ç–ø—É—Å–∫',
        message: `${vacation.user.name} –ø—Ä–∏–≥–ª–∞—Å–∏–ª(–∞) –≤–∞—Å –≤ –æ—Ç–ø—É—Å–∫ "${vacation.title}"`,
        data: {
          invitationId: invitation.id,
          vacationId: vacation.id,
          invitedByName: vacation.user.name,
          vacationTitle: vacation.title
        }
      },
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            avatar: true 
          }
        }
      }
    });

    return NextResponse.json({ 
      message: '–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ',
      invitation: {
        id: invitation.id,
        email: invitation.email,
        status: invitation.status
      },
      notification
    });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/members/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/members/route.js
–†–ê–ó–ú–ï–†: 1629 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/members/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

export async function GET(request, { params }) {
  try {
    // Await params –¥–ª—è Next.js 15
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ –æ—Ç–ø—É—Å–∫—É
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: id,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    const members = await prisma.vacationMember.findMany({
      where: { vacationId: id },
      include: {
        user: {
          select: { 
            id: true, 
            name: true, 
            email: true, 
            avatar: true 
          }
        }
      },
      orderBy: { createdAt: 'asc' }
    });

    return NextResponse.json(members);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/memories/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/memories/route.js
–†–ê–ó–ú–ï–†: 1553 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/memories/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../../lib/auth';
import { prisma } from '../../../../../lib/prisma';

export async function GET(request, { params }) {
  try {
    // Await params –¥–ª—è Next.js 15
    const { id } = await params;
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø –∫ –æ—Ç–ø—É—Å–∫—É
    const vacationAccess = await prisma.vacation.findFirst({
      where: {
        id: id,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      }
    });

    if (!vacationAccess) {
      return NextResponse.json({ message: '–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω' }, { status: 403 });
    }

    const memories = await prisma.memory.findMany({
      where: { vacationId: id },
      orderBy: { createdAt: 'desc' },
      include: {
        author: {
          select: { id: true, name: true, avatar: true }
        }
      }
    });

    return NextResponse.json(memories);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏–π:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/[id]/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/[id]/route.js
–†–ê–ó–ú–ï–†: 3109 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/[id]/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../../lib/auth';
import { prisma } from '../../../../lib/prisma';

export async function GET(request, { params }) {
  try {
    const { id } = await params;
    console.log('üîç –ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Ç–ø—É—Å–∫–∞ —Å ID:', id);
    
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      console.log('‚ùå –ù–µ—Ç access token');
      return NextResponse.json({ message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' }, { status: 401 });
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      console.log('‚ùå –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π —Ç–æ–∫–µ–Ω');
      return NextResponse.json({ message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' }, { status: 401 });
    }

    console.log('üë§ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', decoded.userId);

    const vacation = await prisma.vacation.findFirst({
      where: {
        id: id,
        OR: [
          { userId: decoded.userId },
          { members: { some: { userId: decoded.userId, status: 'accepted' } } }
        ]
      },
      include: {
        user: {
          select: { id: true, name: true, email: true, avatar: true }
        },
        members: {
          where: { status: 'accepted' },
          include: {
            user: {
              select: { id: true, name: true, email: true, avatar: true }
            }
          }
        },
        activities: {
          orderBy: { date: 'asc' },
          take: 10,
          include: {
            // –ò–°–ü–†–ê–í–õ–ï–ù–û: –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –ø–æ–ª—è –¥–ª—è –º–æ–¥–µ–ª–∏ Activity
            location: {
              select: { id: true, name: true, address: true }
            },
            participants: {
              include: {
                user: {
                  select: { id: true, name: true, avatar: true }
                }
              }
            }
          }
        },
        memories: {
          orderBy: { createdAt: 'desc' },
          take: 12,
          include: {
            author: {
              select: { id: true, name: true, avatar: true }
            }
          }
        },
        _count: {
          select: {
            activities: true,
            memories: true,
            members: true,
            locations: true
          }
        }
      }
    });

    if (!vacation) {
      console.log('‚ùå –û—Ç–ø—É—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞');
      return NextResponse.json({ message: '–û—Ç–ø—É—Å–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω' }, { status: 404 });
    }

    // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
    const formattedVacation = {
      ...vacation,
      activities: vacation.activities.map(activity => ({
        ...activity,
        // –ë–µ—Ä–µ–º –ø–µ—Ä–≤–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞ –∫–∞–∫ "–∞–≤—Ç–æ—Ä–∞" –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        author: activity.participants[0]?.user || null,
        participants: activity.participants.map(p => p.user)
      }))
    };

    console.log('‚úÖ –û—Ç–ø—É—Å–∫ –Ω–∞–π–¥–µ–Ω:', formattedVacation.title);
    return NextResponse.json(formattedVacation);

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–ø—É—Å–∫–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}



================================================================================
–§–ê–ô–õ: vacations/route.js
–ü–û–õ–ù–´–ô –ü–£–¢–¨: src/app/api/vacations/route.js
–†–ê–ó–ú–ï–†: 4163 —Å–∏–º–≤–æ–ª–æ–≤
================================================================================

// src/app/api/vacations/route.js
import { NextResponse } from 'next/server';
import { verifyAccessToken } from '../../../lib/auth';
import { prisma } from '../../../lib/prisma';

// –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –æ—Ç–ø—É—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export async function GET(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json(
        { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' },
        { status: 401 }
      );
    }

    // –ü–æ–ª—É—á–∞–µ–º –æ—Ç–ø—É—Å–∫–∏ –≥–¥–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —è–≤–ª—è–µ—Ç—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–º
    const vacations = await prisma.vacation.findMany({
      where: {
        OR: [
          { userId: decoded.userId }, // –í–ª–∞–¥–µ–ª–µ—Ü
          { members: { some: { userId: decoded.userId, status: 'accepted' } } } // –£—á–∞—Å—Ç–Ω–∏–∫
        ]
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        members: {
          where: {
            status: 'accepted'
          },
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                avatar: true
              }
            }
          }
        },
        activities: {
          orderBy: { date: 'asc' }
        },
        memories: true,
        locations: true,
        _count: {
          select: {
            activities: true,
            memories: true,
            members: true,
            locations: true
          }
        }
      },
      orderBy: { startDate: 'asc' }
    });

    return NextResponse.json(vacations);

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–ø—É—Å–∫–æ–≤:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}

// –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—ã–π –æ—Ç–ø—É—Å–∫
export async function POST(request) {
  try {
    const accessToken = request.cookies.get('accessToken')?.value;

    if (!accessToken) {
      return NextResponse.json(
        { message: '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω' },
        { status: 401 }
      );
    }

    const decoded = verifyAccessToken(accessToken);
    if (!decoded) {
      return NextResponse.json(
        { message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' },
        { status: 401 }
      );
    }

    const { title, description, destination, startDate, endDate } = await request.json();

    if (!title || !startDate || !endDate) {
      return NextResponse.json(
        { message: '–ù–∞–∑–≤–∞–Ω–∏–µ –∏ –¥–∞—Ç—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã' },
        { status: 400 }
      );
    }

    // –°–æ–∑–¥–∞–µ–º –æ—Ç–ø—É—Å–∫
    const vacation = await prisma.vacation.create({
      data: {
        title,
        description,
        destination,
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        userId: decoded.userId,
        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ–º –≤–ª–∞–¥–µ–ª—å—Ü–∞ –∫–∞–∫ —É—á–∞—Å—Ç–Ω–∏–∫–∞
        members: {
          create: {
            userId: decoded.userId,
            role: 'owner',
            status: 'accepted'
          }
        }
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        },
        members: {
          where: {
            status: 'accepted'
          },
          include: {
            user: {
              select: {
                id: true,
                name: true,
                email: true,
                avatar: true
              }
            }
          }
        },
        activities: true,
        memories: true,
        locations: true,
        _count: {
          select: {
            activities: true,
            memories: true,
            members: true,
            locations: true
          }
        }
      }
    });

    return NextResponse.json(vacation, { status: 201 });

  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –æ—Ç–ø—É—Å–∫–∞:', error);
    return NextResponse.json(
      { message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' },
      { status: 500 }
    );
  }
}


